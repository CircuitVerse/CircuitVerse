# frozen_string_literal: true
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/api/distribution.proto

require 'google/protobuf'

require 'google/protobuf/any_pb'
require 'google/protobuf/timestamp_pb'


descriptor_data = "\n\x1dgoogle/api/distribution.proto\x12\ngoogle.api\x1a\x19google/protobuf/any.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xd9\x06\n\x0c\x44istribution\x12\r\n\x05\x63ount\x18\x01 \x01(\x03\x12\x0c\n\x04mean\x18\x02 \x01(\x01\x12 \n\x18sum_of_squared_deviation\x18\x03 \x01(\x01\x12-\n\x05range\x18\x04 \x01(\x0b\x32\x1e.google.api.Distribution.Range\x12>\n\x0e\x62ucket_options\x18\x06 \x01(\x0b\x32&.google.api.Distribution.BucketOptions\x12\x15\n\rbucket_counts\x18\x07 \x03(\x03\x12\x34\n\texemplars\x18\n \x03(\x0b\x32!.google.api.Distribution.Exemplar\x1a!\n\x05Range\x12\x0b\n\x03min\x18\x01 \x01(\x01\x12\x0b\n\x03max\x18\x02 \x01(\x01\x1a\xb5\x03\n\rBucketOptions\x12G\n\x0elinear_buckets\x18\x01 \x01(\x0b\x32-.google.api.Distribution.BucketOptions.LinearH\x00\x12Q\n\x13\x65xponential_buckets\x18\x02 \x01(\x0b\x32\x32.google.api.Distribution.BucketOptions.ExponentialH\x00\x12K\n\x10\x65xplicit_buckets\x18\x03 \x01(\x0b\x32/.google.api.Distribution.BucketOptions.ExplicitH\x00\x1a\x43\n\x06Linear\x12\x1a\n\x12num_finite_buckets\x18\x01 \x01(\x05\x12\r\n\x05width\x18\x02 \x01(\x01\x12\x0e\n\x06offset\x18\x03 \x01(\x01\x1aO\n\x0b\x45xponential\x12\x1a\n\x12num_finite_buckets\x18\x01 \x01(\x05\x12\x15\n\rgrowth_factor\x18\x02 \x01(\x01\x12\r\n\x05scale\x18\x03 \x01(\x01\x1a\x1a\n\x08\x45xplicit\x12\x0e\n\x06\x62ounds\x18\x01 \x03(\x01\x42\t\n\x07options\x1as\n\x08\x45xemplar\x12\r\n\x05value\x18\x01 \x01(\x01\x12-\n\ttimestamp\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12)\n\x0b\x61ttachments\x18\x03 \x03(\x0b\x32\x14.google.protobuf.AnyBq\n\x0e\x63om.google.apiB\x11\x44istributionProtoP\x01ZCgoogle.golang.org/genproto/googleapis/api/distribution;distribution\xa2\x02\x04GAPIb\x06proto3"

pool = Google::Protobuf::DescriptorPool.generated_pool

begin
  pool.add_serialized_file(descriptor_data)
rescue TypeError
  # Compatibility code: will be removed in the next major version.
  require 'google/protobuf/descriptor_pb'
  parsed = Google::Protobuf::FileDescriptorProto.decode(descriptor_data)
  parsed.clear_dependency
  serialized = parsed.class.encode(parsed)
  file = pool.add_serialized_file(serialized)
  warn "Warning: Protobuf detected an import path issue while loading generated file #{__FILE__}"
  imports = [
    ["google.protobuf.Timestamp", "google/protobuf/timestamp.proto"],
    ["google.protobuf.Any", "google/protobuf/any.proto"],
  ]
  imports.each do |type_name, expected_filename|
    import_file = pool.lookup(type_name).file_descriptor
    if import_file.name != expected_filename
      warn "- #{file.name} imports #{expected_filename}, but that import was loaded as #{import_file.name}"
    end
  end
  warn "Each proto file must use a consistent fully-qualified name."
  warn "This will become an error in the next major version."
end

module Google
  module Api
    Distribution = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("google.api.Distribution").msgclass
    Distribution::Range = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("google.api.Distribution.Range").msgclass
    Distribution::BucketOptions = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("google.api.Distribution.BucketOptions").msgclass
    Distribution::BucketOptions::Linear = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("google.api.Distribution.BucketOptions.Linear").msgclass
    Distribution::BucketOptions::Exponential = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("google.api.Distribution.BucketOptions.Exponential").msgclass
    Distribution::BucketOptions::Explicit = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("google.api.Distribution.BucketOptions.Explicit").msgclass
    Distribution::Exemplar = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("google.api.Distribution.Exemplar").msgclass
  end
end

#### Source proto file: google/api/distribution.proto ####
#
# // Copyright 2025 Google LLC
# //
# // Licensed under the Apache License, Version 2.0 (the "License");
# // you may not use this file except in compliance with the License.
# // You may obtain a copy of the License at
# //
# //     http://www.apache.org/licenses/LICENSE-2.0
# //
# // Unless required by applicable law or agreed to in writing, software
# // distributed under the License is distributed on an "AS IS" BASIS,
# // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# // See the License for the specific language governing permissions and
# // limitations under the License.
#
# syntax = "proto3";
#
# package google.api;
#
# import "google/protobuf/any.proto";
# import "google/protobuf/timestamp.proto";
#
# option go_package = "google.golang.org/genproto/googleapis/api/distribution;distribution";
# option java_multiple_files = true;
# option java_outer_classname = "DistributionProto";
# option java_package = "com.google.api";
# option objc_class_prefix = "GAPI";
#
# // `Distribution` contains summary statistics for a population of values. It
# // optionally contains a histogram representing the distribution of those values
# // across a set of buckets.
# //
# // The summary statistics are the count, mean, sum of the squared deviation from
# // the mean, the minimum, and the maximum of the set of population of values.
# // The histogram is based on a sequence of buckets and gives a count of values
# // that fall into each bucket. The boundaries of the buckets are given either
# // explicitly or by formulas for buckets of fixed or exponentially increasing
# // widths.
# //
# // Although it is not forbidden, it is generally a bad idea to include
# // non-finite values (infinities or NaNs) in the population of values, as this
# // will render the `mean` and `sum_of_squared_deviation` fields meaningless.
# message Distribution {
#   // The range of the population values.
#   message Range {
#     // The minimum of the population values.
#     double min = 1;
#
#     // The maximum of the population values.
#     double max = 2;
#   }
#
#   // `BucketOptions` describes the bucket boundaries used to create a histogram
#   // for the distribution. The buckets can be in a linear sequence, an
#   // exponential sequence, or each bucket can be specified explicitly.
#   // `BucketOptions` does not include the number of values in each bucket.
#   //
#   // A bucket has an inclusive lower bound and exclusive upper bound for the
#   // values that are counted for that bucket. The upper bound of a bucket must
#   // be strictly greater than the lower bound. The sequence of N buckets for a
#   // distribution consists of an underflow bucket (number 0), zero or more
#   // finite buckets (number 1 through N - 2) and an overflow bucket (number N -
#   // 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the
#   // same as the upper bound of bucket i - 1. The buckets span the whole range
#   // of finite values: lower bound of the underflow bucket is -infinity and the
#   // upper bound of the overflow bucket is +infinity. The finite buckets are
#   // so-called because both bounds are finite.
#   message BucketOptions {
#     // Specifies a linear sequence of buckets that all have the same width
#     // (except overflow and underflow). Each bucket represents a constant
#     // absolute uncertainty on the specific value in the bucket.
#     //
#     // There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
#     // following boundaries:
#     //
#     //    Upper bound (0 <= i < N-1):     offset + (width * i).
#     //
#     //    Lower bound (1 <= i < N):       offset + (width * (i - 1)).
#     message Linear {
#       // Must be greater than 0.
#       int32 num_finite_buckets = 1;
#
#       // Must be greater than 0.
#       double width = 2;
#
#       // Lower bound of the first bucket.
#       double offset = 3;
#     }
#
#     // Specifies an exponential sequence of buckets that have a width that is
#     // proportional to the value of the lower bound. Each bucket represents a
#     // constant relative uncertainty on a specific value in the bucket.
#     //
#     // There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
#     // following boundaries:
#     //
#     //    Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).
#     //
#     //    Lower bound (1 <= i < N):       scale * (growth_factor ^ (i - 1)).
#     message Exponential {
#       // Must be greater than 0.
#       int32 num_finite_buckets = 1;
#
#       // Must be greater than 1.
#       double growth_factor = 2;
#
#       // Must be greater than 0.
#       double scale = 3;
#     }
#
#     // Specifies a set of buckets with arbitrary widths.
#     //
#     // There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following
#     // boundaries:
#     //
#     //    Upper bound (0 <= i < N-1):     bounds[i]
#     //    Lower bound (1 <= i < N);       bounds[i - 1]
#     //
#     // The `bounds` field must contain at least one element. If `bounds` has
#     // only one element, then there are no finite buckets, and that single
#     // element is the common boundary of the overflow and underflow buckets.
#     message Explicit {
#       // The values must be monotonically increasing.
#       repeated double bounds = 1;
#     }
#
#     // Exactly one of these three fields must be set.
#     oneof options {
#       // The linear bucket.
#       Linear linear_buckets = 1;
#
#       // The exponential buckets.
#       Exponential exponential_buckets = 2;
#
#       // The explicit buckets.
#       Explicit explicit_buckets = 3;
#     }
#   }
#
#   // Exemplars are example points that may be used to annotate aggregated
#   // distribution values. They are metadata that gives information about a
#   // particular value added to a Distribution bucket, such as a trace ID that
#   // was active when a value was added. They may contain further information,
#   // such as a example values and timestamps, origin, etc.
#   message Exemplar {
#     // Value of the exemplar point. This value determines to which bucket the
#     // exemplar belongs.
#     double value = 1;
#
#     // The observation (sampling) time of the above value.
#     google.protobuf.Timestamp timestamp = 2;
#
#     // Contextual information about the example value. Examples are:
#     //
#     //   Trace: type.googleapis.com/google.monitoring.v3.SpanContext
#     //
#     //   Literal string: type.googleapis.com/google.protobuf.StringValue
#     //
#     //   Labels dropped during aggregation:
#     //     type.googleapis.com/google.monitoring.v3.DroppedLabels
#     //
#     // There may be only a single attachment of any given message type in a
#     // single exemplar, and this is enforced by the system.
#     repeated google.protobuf.Any attachments = 3;
#   }
#
#   // The number of values in the population. Must be non-negative. This value
#   // must equal the sum of the values in `bucket_counts` if a histogram is
#   // provided.
#   int64 count = 1;
#
#   // The arithmetic mean of the values in the population. If `count` is zero
#   // then this field must be zero.
#   double mean = 2;
#
#   // The sum of squared deviations from the mean of the values in the
#   // population. For values x_i this is:
#   //
#   //     Sum[i=1..n]((x_i - mean)^2)
#   //
#   // Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition
#   // describes Welford's method for accumulating this sum in one pass.
#   //
#   // If `count` is zero then this field must be zero.
#   double sum_of_squared_deviation = 3;
#
#   // If specified, contains the range of the population values. The field
#   // must not be present if the `count` is zero.
#   Range range = 4;
#
#   // Defines the histogram bucket boundaries. If the distribution does not
#   // contain a histogram, then omit this field.
#   BucketOptions bucket_options = 6;
#
#   // The number of values in each bucket of the histogram, as described in
#   // `bucket_options`. If the distribution does not have a histogram, then omit
#   // this field. If there is a histogram, then the sum of the values in
#   // `bucket_counts` must equal the value in the `count` field of the
#   // distribution.
#   //
#   // If present, `bucket_counts` should contain N values, where N is the number
#   // of buckets specified in `bucket_options`. If you supply fewer than N
#   // values, the remaining values are assumed to be 0.
#   //
#   // The order of the values in `bucket_counts` follows the bucket numbering
#   // schemes described for the three bucket types. The first value must be the
#   // count for the underflow bucket (number 0). The next N-2 values are the
#   // counts for the finite buckets (number 1 through N-2). The N'th value in
#   // `bucket_counts` is the count for the overflow bucket (number N-1).
#   repeated int64 bucket_counts = 7;
#
#   // Must be in increasing order of `value` field.
#   repeated Exemplar exemplars = 10;
# }
