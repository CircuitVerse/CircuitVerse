# A blob is a record that contains the metadata about a file and a key for where that file resides on the service.
# Blobs can be created in two ways:
#
# 1. Ahead of the file being uploaded server-side to the service, via <tt>create_and_upload!</tt>. A rewindable
#    <tt>io</tt> with the file contents must be available at the server for this operation.
# 2. Ahead of the file being directly uploaded client-side to the service, via <tt>create_before_direct_upload!</tt>.
#
# The first option doesn't require any client-side JavaScript integration, and can be used by any other back-end
# service that deals with files. The second option is faster, since you're not using your own server as a staging
# point for uploads, and can work with deployments like Heroku that do not provide large amounts of disk space.
#
# Blobs are intended to be immutable in as-so-far as their reference to a specific file goes. You're allowed to
# update a blob's metadata on a subsequent pass, but you should not update the key or change the uploaded file.
# If you need to create a derivative or otherwise change the blob, simply create a new blob and purge the old one.
class ActiveStorage::Blob < ActiveStorage::Record
  # We use constant paths in the following include calls to avoid a gotcha of
  # classic mode: If the parent application defines a top-level Analyzable, for
  # example, and ActiveStorage::Blob::Analyzable is not yet loaded, a bare
  #
  #   include Analyzable
  #
  # would resolve to the top-level one, const_missing would not be triggered,
  # and therefore ActiveStorage::Blob::Analyzable would not be autoloaded.
  #
  # By using qualified names, we ensure const_missing is invoked if needed.
  # Please, note that Ruby 2.5 or newer is required, so Object is not checked
  # when looking up the ancestors of ActiveStorage::Blob.
  #
  # Zeitwerk mode does not have this gotcha. If we ever drop classic mode, this
  # can be simplified, bare constant names would just work.
  # include ActiveStorage::Blob::Analyzable

  # include ActiveStorage::Blob::Identifiable

  # include ActiveStorage::Blob::Representable

  MINIMUM_TOKEN_LENGTH: ::Integer

  # You can use the signed ID of a blob to refer to it on the client side without fear of tampering.
  # This is particularly helpful for direct uploads where the client-side needs to refer to the blob
  # that was created ahead of the upload itself on form submission.
  #
  # The signed ID is also used to create stable URLs for the blob through the BlobsController.
  def self.find_signed: (untyped id, ?record: untyped? record, ?purpose: ::Symbol purpose) -> untyped

  # Works like +find_signed+, but will raise an +ActiveSupport::MessageVerifier::InvalidSignature+
  # exception if the +signed_id+ has either expired, has a purpose mismatch, is for another record,
  # or has been tampered with. It will also raise an +ActiveRecord::RecordNotFound+ exception if
  # the valid signed id can't find a record.
  def self.find_signed!: (untyped id, ?record: untyped? record, ?purpose: ::Symbol purpose) -> untyped

  def self.build_after_upload: (io: untyped io, filename: untyped filename, ?content_type: untyped? content_type, ?metadata: untyped? metadata, ?service_name: untyped? service_name, ?identify: bool identify, ?record: untyped? record) -> untyped

  def self.build_after_unfurling: (io: untyped io, filename: untyped filename, ?key: untyped? key, ?content_type: untyped? content_type, ?metadata: untyped? metadata, ?service_name: untyped? service_name, ?identify: bool identify, ?record: untyped? record) -> untyped

  def self.create_after_unfurling!: (io: untyped io, filename: untyped filename, ?key: untyped? key, ?content_type: untyped? content_type, ?metadata: untyped? metadata, ?service_name: untyped? service_name, ?identify: bool identify, ?record: untyped? record) -> untyped

  # Creates a new blob instance and then uploads the contents of
  # the given <tt>io</tt> to the service. The blob instance is going to
  # be saved before the upload begins to prevent the upload clobbering another due to key collisions.
  # When providing a content type, pass <tt>identify: false</tt> to bypass
  # automatic content type inference.
  def self.create_and_upload!: (io: untyped io, filename: untyped filename, ?key: untyped? key, ?content_type: untyped? content_type, ?metadata: untyped? metadata, ?service_name: untyped? service_name, ?identify: bool identify, ?record: untyped? record) -> untyped

  alias self.create_after_upload! self.create_and_upload!

  # Returns a saved blob _without_ uploading a file to the service. This blob will point to a key where there is
  # no file yet. It's intended to be used together with a client-side upload, which will first create the blob
  # in order to produce the signed URL for uploading. This signed URL points to the key generated by the blob.
  # Once the form using the direct upload is submitted, the blob can be associated with the right record using
  # the signed ID.
  def self.create_before_direct_upload!: (filename: untyped filename, byte_size: untyped byte_size, checksum: untyped checksum, ?key: untyped? key, ?content_type: untyped? content_type, ?metadata: untyped? metadata, ?service_name: untyped? service_name, ?record: untyped? record) -> untyped

  # To prevent problems with case-insensitive filesystems, especially in combination
  # with databases which treat indices as case-sensitive, all blob keys generated are going
  # to only contain the base-36 character alphabet and will therefore be lowercase. To maintain
  # the same or higher amount of entropy as in the base-58 encoding used by `has_secure_token`
  # the number of bytes used is increased to 28 from the standard 24
  def self.generate_unique_secure_token: (?length: untyped length) -> untyped

  def self.combine_signed_id_purposes: (untyped purpose) -> untyped

  def self.signed_id_verifier: () -> untyped

  # Returns a signed ID for this blob that's suitable for reference on the client-side without fear of tampering.
  def signed_id: () -> untyped

  # Returns the key pointing to the file on the service that's associated with this blob. The key is the
  # secure-token format from Rails in lower case. So it'll look like: xtapjjcjiudrlk3tmwyjgpuobabd.
  # This key is not intended to be revealed directly to the user.
  # Always refer to blobs using the signed_id or a verified form of the key.
  def key: () -> untyped

  # Returns an ActiveStorage::Filename instance of the filename that can be
  # queried for basename, extension, and a sanitized version of the filename
  # that's safe to use in URLs.
  def filename: () -> untyped

  # Returns true if the content_type of this blob is in the image range, like image/png.
  def image?: () -> untyped

  # Returns true if the content_type of this blob is in the audio range, like audio/mpeg.
  def audio?: () -> untyped

  # Returns true if the content_type of this blob is in the video range, like video/mp4.
  def video?: () -> untyped

  # Returns true if the content_type of this blob is in the text range, like text/plain.
  def text?: () -> untyped

  # Returns the URL of the blob on the service. This returns a permanent URL for public files, and returns a
  # short-lived URL for private files. Private files are signed, and not for public use. Instead,
  # the URL should only be exposed as a redirect from a stable, possibly authenticated URL. Hiding the
  # URL behind a redirect also allows you to change services without updating all URLs.
  def url: (?expires_in: untyped expires_in, ?disposition: ::Symbol disposition, ?filename: untyped? filename, **untyped options) -> untyped

  alias service_url url

  # Returns a URL that can be used to directly upload a file for this blob on the service. This URL is intended to be
  # short-lived for security and only generated on-demand by the client-side JavaScript responsible for doing the uploading.
  def service_url_for_direct_upload: (?expires_in: untyped expires_in) -> untyped

  # Returns a Hash of headers for +service_url_for_direct_upload+ requests.
  def service_headers_for_direct_upload: () -> untyped

  def content_type_for_serving: () -> untyped

  def forced_disposition_for_serving: () -> untyped

  # Uploads the +io+ to the service on the +key+ for this blob. Blobs are intended to be immutable, so you shouldn't be
  # using this method after a file has already been uploaded to fit with a blob. If you want to create a derivative blob,
  # you should instead simply create a new blob based on the old one.
  #
  # Prior to uploading, we compute the checksum, which is sent to the service for transit integrity validation. If the
  # checksum does not match what the service receives, an exception will be raised. We also measure the size of the +io+
  # and store that in +byte_size+ on the blob record. The content type is automatically extracted from the +io+ unless
  # you specify a +content_type+ and pass +identify+ as false.
  #
  # Normally, you do not have to call this method directly at all. Use the +create_and_upload!+ class method instead.
  # If you do use this method directly, make sure you are using it on a persisted Blob as otherwise another blob's
  # data might get overwritten on the service.
  def upload: (untyped io, ?identify: bool identify) -> untyped

  def unfurl: (untyped io, ?identify: bool identify) -> untyped

  def upload_without_unfurling: (untyped io) -> untyped

  # Downloads the file associated with this blob. If no block is given, the entire file is read into memory and returned.
  # That'll use a lot of RAM for very large files. If a block is given, then the download is streamed and yielded in chunks.
  def download: () { (String) -> void } -> void
              | () -> String

  # Downloads the blob to a tempfile on disk. Yields the tempfile.
  #
  # The tempfile's name is prefixed with +ActiveStorage-+ and the blob's ID. Its extension matches that of the blob.
  #
  # By default, the tempfile is created in <tt>Dir.tmpdir</tt>. Pass +tmpdir:+ to create it in a different directory:
  #
  #   blob.open(tmpdir: "/path/to/tmp") do |file|
  #     # ...
  #   end
  #
  # The tempfile is automatically closed and unlinked after the given block is executed.
  #
  # Raises ActiveStorage::IntegrityError if the downloaded data does not match the blob's checksum.
  def open: (?tmpdir: untyped? tmpdir) { (Tempfile) -> untyped } -> untyped

  def mirror_later: () -> untyped

  # Deletes the files on the service associated with the blob. This should only be done if the blob is going to be
  # deleted as well or you will essentially have a dead reference. It's recommended to use #purge and #purge_later
  # methods in most circumstances.
  def delete: () -> untyped

  # Destroys the blob record and then deletes the file on the service. This is the recommended way to dispose of unwanted
  # blobs. Note, though, that deleting the file off the service will initiate an HTTP connection to the service, which may
  # be slow or prevented, so you should not use this method inside a transaction or in callbacks. Use #purge_later instead.
  def purge: () -> untyped

  # Enqueues an ActiveStorage::PurgeJob to call #purge. This is the recommended way to purge blobs from a transaction,
  # an Active Record callback, or in any other real-time scenario.
  def purge_later: () -> untyped

  # Returns an instance of service, which can be configured globally or per attachment
  def service: () -> untyped
end
