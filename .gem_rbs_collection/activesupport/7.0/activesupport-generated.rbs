# The generated code is based on Ruby on Rails source code
# You can find the license of Ruby on Rails from following.

#Copyright (c) 2005-2019 David Heinemeier Hansson
#
#Permission is hereby granted, free of charge, to any person obtaining
#a copy of this software and associated documentation files (the
#"Software"), to deal in the Software without restriction, including
#without limitation the rights to use, copy, modify, merge, publish,
#distribute, sublicense, and/or sell copies of the Software, and to
#permit persons to whom the Software is furnished to do so, subject to
#the following conditions:
#
#The above copyright notice and this permission notice shall be
#included in all copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
#LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
#OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
#WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

module ActiveSupport
  # Actionable errors let's you define actions to resolve an error.
  #
  # To make an error actionable, include the <tt>ActiveSupport::ActionableError</tt>
  # module and invoke the +action+ class macro to define the action. An action
  # needs a name and a block to execute.
  module ActionableError
    extend Concern

    class NonActionable < StandardError
    end

    def self.actions: (untyped error) -> untyped

    def self.dispatch: (untyped error, untyped name) -> untyped

    module ClassMethods
      # Defines an action that can resolve the error.
      #
      #   class PendingMigrationError < MigrationError
      #     include ActiveSupport::ActionableError
      #
      #     action "Run pending migrations" do
      #       ActiveRecord::Tasks::DatabaseTasks.migrate
      #     end
      #   end
      def action: (untyped name) { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  # Wrapping an array in an +ArrayInquirer+ gives a friendlier way to check
  # its string-like contents:
  #
  #   variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])
  #
  #   variants.phone?    # => true
  #   variants.tablet?   # => true
  #   variants.desktop?  # => false
  class ArrayInquirer[T] < Array[T]
    # Passes each element of +candidates+ collection to ArrayInquirer collection.
    # The method returns true if any element from the ArrayInquirer collection
    # is equal to the stringified or symbolized form of any element in the +candidates+ collection.
    #
    # If +candidates+ collection is not given, method returns true.
    #
    #   variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])
    #
    #   variants.any?                      # => true
    #   variants.any?(:phone, :tablet)     # => true
    #   variants.any?('phone', 'desktop')  # => true
    #   variants.any?(:desktop, :watch)    # => false
    def any?: (*untyped candidates) -> untyped

    private

    def respond_to_missing?: (untyped name, ?bool include_private) -> untyped

    def method_missing: (untyped name, *untyped args) -> untyped
  end
end

module ActiveSupport
  # Backtraces often include many lines that are not relevant for the context
  # under review. This makes it hard to find the signal amongst the backtrace
  # noise, and adds debugging time. With a BacktraceCleaner, filters and
  # silencers are used to remove the noisy lines, so that only the most relevant
  # lines remain.
  #
  # Filters are used to modify lines of data, while silencers are used to remove
  # lines entirely. The typical filter use case is to remove lengthy path
  # information from the start of each line, and view file paths relevant to the
  # app directory instead of the file system root. The typical silencer use case
  # is to exclude the output of a noisy library from the backtrace, so that you
  # can focus on the rest.
  #
  #   bc = ActiveSupport::BacktraceCleaner.new
  #   bc.add_filter   { |line| line.gsub(Rails.root.to_s, '') } # strip the Rails.root prefix
  #   bc.add_silencer { |line| line =~ /puma|rubygems/ } # skip any lines from puma or rubygems
  #   bc.clean(exception.backtrace) # perform the cleanup
  #
  # To reconfigure an existing BacktraceCleaner (like the default one in Rails)
  # and show as much data as possible, you can always call
  # <tt>BacktraceCleaner#remove_silencers!</tt>, which will restore the
  # backtrace to a pristine state. If you need to reconfigure an existing
  # BacktraceCleaner so that it does not filter or modify the paths of any lines
  # of the backtrace, you can call <tt>BacktraceCleaner#remove_filters!</tt>
  # These two methods will give you a completely untouched backtrace.
  #
  # Inspired by the Quiet Backtrace gem by thoughtbot.
  class BacktraceCleaner
    def initialize: () -> untyped

    # Returns the backtrace after all filters and silencers have been run
    # against it. Filters run first, then silencers.
    def clean: (untyped backtrace, ?::Symbol kind) -> untyped

    alias filter clean

    # Adds a filter from the block provided. Each line in the backtrace will be
    # mapped against this filter.
    #
    #   # Will turn "/my/rails/root/app/models/person.rb" into "/app/models/person.rb"
    #   backtrace_cleaner.add_filter { |line| line.gsub(Rails.root, '') }
    def add_filter: () { () -> untyped } -> untyped

    # Adds a silencer from the block provided. If the silencer returns +true+
    # for a given line, it will be excluded from the clean backtrace.
    #
    #   # Will reject all lines that include the word "puma", like "/gems/puma/server.rb" or "/app/my_puma_server/rb"
    #   backtrace_cleaner.add_silencer { |line| line =~ /puma/ }
    def add_silencer: () { () -> untyped } -> untyped

    # Removes all silencers, but leaves in the filters. Useful if your
    # context of debugging suddenly expands as you suspect a bug in one of
    # the libraries you use.
    def remove_silencers!: () -> untyped

    # Removes all filters, but leaves in the silencers. Useful if you suddenly
    # need to see entire filepaths in the backtrace that you had already
    # filtered out.
    def remove_filters!: () -> untyped

    private

    FORMATTED_GEMS_PATTERN: untyped

    def add_gem_filter: () -> (nil | untyped)

    def add_gem_silencer: () -> untyped

    def add_stdlib_silencer: () -> untyped

    def filter_backtrace: (untyped backtrace) -> untyped

    def silence: (untyped backtrace) -> untyped

    def noise: (untyped backtrace) -> untyped
  end
end

module ActiveSupport
  module Benchmarkable
    # Allows you to measure the execution time of a block in a template and
    # records the result to the log. Wrap this block around expensive operations
    # or possible bottlenecks to get a time reading for the operation. For
    # example, let's say you thought your file processing method was taking too
    # long; you could wrap it in a benchmark block.
    #
    #  <% benchmark 'Process data files' do %>
    #    <%= expensive_files_operation %>
    #  <% end %>
    #
    # That would add something like "Process data files (345.2ms)" to the log,
    # which you can then use to compare timings when optimizing your code.
    #
    # You may give an optional logger level (<tt>:debug</tt>, <tt>:info</tt>,
    # <tt>:warn</tt>, <tt>:error</tt>) as the <tt>:level</tt> option. The
    # default logger level value is <tt>:info</tt>.
    #
    #  <% benchmark 'Low-level files', level: :debug do %>
    #    <%= lowlevel_files_operation %>
    #  <% end %>
    #
    # Finally, you can pass true as the third argument to silence all log
    # activity (other than the timing information) from inside the block. This
    # is great for boiling down a noisy block to just a single statement that
    # produces one log line:
    #
    #  <% benchmark 'Process data files', level: :info, silence: true do %>
    #    <%= expensive_and_chatty_files_operation %>
    #  <% end %>
    def benchmark: (?::String message, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped
  end
end

module ActiveSupport
  module Cache
    # A cache store implementation which stores everything on the filesystem.
    #
    # FileStore implements the Strategy::LocalCache strategy which implements
    # an in-memory cache inside of a block.
    class FileStore < Store
      attr_reader cache_path: untyped

      DIR_FORMATTER: ::String

      FILENAME_MAX_SIZE: ::Integer

      FILEPATH_MAX_SIZE: ::Integer

      # max filename size on file system is 255, minus room for timestamp and random characters appended by Tempfile (used by atomic write)
      # max is 1024, plus some room
      GITKEEP_FILES: untyped

      def initialize: (untyped cache_path, ?untyped? options) -> untyped

      # Advertise cache versioning support.
      def self.supports_cache_versioning?: () -> ::TrueClass

      # Deletes all items from the cache. In this case it deletes all the entries in the specified
      # file store directory except for .keep or .gitkeep. Be careful which directory is specified in your
      # config file when using +FileStore+ because everything in that directory will be deleted.
      def clear: (?untyped? options) -> untyped

      # Preemptively iterates through all stored keys and removes the ones which have expired.
      def cleanup: (?untyped? options) -> untyped

      # Increments an already existing integer value that is stored in the cache.
      # If the key is not found nothing is done.
      def increment: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Decrements an already existing integer value that is stored in the cache.
      # If the key is not found nothing is done.
      def decrement: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      def delete_matched: (untyped matcher, ?untyped? options) -> untyped

      private

      def read_entry: (untyped key, **untyped options) -> untyped

      def write_entry: (untyped key, untyped entry, **untyped options) -> (::FalseClass | ::TrueClass)

      def delete_entry: (untyped key, **untyped options) -> untyped

      # Lock a file for a block so only one process can modify it at a time.
      def lock_file: (untyped file_name) { () -> untyped } -> untyped

      # Translate a key into a file path.
      def normalize_key: (untyped key, untyped options) -> untyped

      # Translate a file path into a key.
      def file_path_key: (untyped path) -> untyped

      # Delete empty directories in the cache.
      def delete_empty_directories: (untyped dir) -> (nil | untyped)

      # Make sure a file path's directories exist.
      def ensure_cache_path: (untyped path) -> untyped

      def search_dir: (untyped dir) { () -> untyped } -> (nil | untyped)

      # Modifies the amount of an already existing integer value that is stored in the cache.
      # If the key is not found nothing is done.
      def modify_value: (untyped name, untyped amount, untyped options) -> untyped
    end
  end
end

module ActiveSupport
  module Cache
    # A cache store implementation which stores data in Memcached:
    # https://memcached.org
    #
    # This is currently the most popular cache store for production websites.
    #
    # Special features:
    # - Clustering and load balancing. One can specify multiple memcached servers,
    #   and MemCacheStore will load balance between all available servers. If a
    #   server goes down, then MemCacheStore will ignore it until it comes back up.
    #
    # MemCacheStore implements the Strategy::LocalCache strategy which implements
    # an in-memory cache inside of a block.
    class MemCacheStore < Store
      module LocalCacheWithRaw
        private

        def write_entry: (untyped key, untyped entry, **untyped options) -> untyped
      end

      # Advertise cache versioning support.
      def self.supports_cache_versioning?: () -> ::TrueClass

      ESCAPE_KEY_CHARS: untyped

      def self.build_mem_cache: (*untyped addresses) -> untyped

      # Creates a new MemCacheStore object, with the given memcached server
      # addresses. Each address is either a host name, or a host-with-port string
      # in the form of "host_name:port". For example:
      #
      #   ActiveSupport::Cache::MemCacheStore.new("localhost", "server-downstairs.localnetwork:8229")
      #
      # If no addresses are specified, then MemCacheStore will connect to
      # localhost port 11211 (the default memcached port).
      def initialize: (*untyped addresses) -> untyped

      # Increment a cached value. This method uses the memcached incr atomic
      # operator and can only be used on values written with the :raw option.
      # Calling it on a value not stored with :raw will initialize that value
      # to zero.
      def increment: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Decrement a cached value. This method uses the memcached decr atomic
      # operator and can only be used on values written with the :raw option.
      # Calling it on a value not stored with :raw will initialize that value
      # to zero.
      def decrement: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Clear the entire cache on all memcached servers. This method should
      # be used with care when shared cache is being used.
      def clear: (?untyped? options) -> untyped

      # Get the statistics from the memcached servers.
      def stats: () -> untyped

      private

      # Read an entry from the cache.
      def read_entry: (untyped key, **untyped options) -> untyped

      # Write an entry to the cache.
      def write_entry: (untyped key, untyped entry, **untyped options) -> untyped

      # Reads multiple entries from the cache implementation.
      def read_multi_entries: (untyped names, **untyped options) -> untyped

      # Delete an entry from the cache.
      def delete_entry: (untyped key, **untyped options) -> untyped

      # Memcache keys are binaries. So we need to force their encoding to binary
      # before applying the regular expression to ensure we are escaping all
      # characters properly.
      def normalize_key: (untyped key, untyped options) -> untyped

      def deserialize_entry: (untyped entry) -> untyped

      def rescue_error_with: (untyped fallback) { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Cache
    # A cache store implementation which stores everything into memory in the
    # same process. If you're running multiple Ruby on Rails server processes
    # (which is the case if you're using Phusion Passenger or puma clustered mode),
    # then this means that Rails server process instances won't be able
    # to share cache data with each other and this may not be the most
    # appropriate cache in that scenario.
    #
    # This cache has a bounded size specified by the :size options to the
    # initializer (default is 32Mb). When the cache exceeds the allotted size,
    # a cleanup will occur which tries to prune the cache down to three quarters
    # of the maximum size by removing the least recently used entries.
    #
    # MemoryStore is thread-safe.
    class MemoryStore < Store
      def initialize: (?untyped? options) -> untyped

      # Advertise cache versioning support.
      def self.supports_cache_versioning?: () -> ::TrueClass

      # Delete all data stored in a given cache store.
      def clear: (?untyped? options) -> untyped

      # Preemptively iterates through all stored keys and removes the ones which have expired.
      def cleanup: (?untyped? options) -> untyped

      # To ensure entries fit within the specified memory prune the cache by removing the least
      # recently accessed entries.
      def prune: (untyped target_size, ?untyped? max_time) -> (nil | untyped)

      # Returns true if the cache is currently being pruned.
      def pruning?: () -> untyped

      # Increment an integer value in the cache.
      def increment: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Decrement an integer value in the cache.
      def decrement: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Deletes cache entries if the cache key matches a given pattern.
      def delete_matched: (untyped matcher, ?untyped? options) -> untyped

      def inspect: () -> ::String

      def synchronize: () { () -> untyped } -> untyped

      private

      PER_ENTRY_OVERHEAD: ::Integer

      def cached_size: (untyped key, untyped entry) -> untyped

      def read_entry: (untyped key, **untyped options) -> untyped

      def write_entry: (untyped key, untyped entry, **untyped options) -> (::FalseClass | untyped)

      def delete_entry: (untyped key, **untyped options) -> untyped

      def modify_value: (untyped name, untyped amount, untyped options) -> untyped
    end
  end
end

module ActiveSupport
  module Cache
    # A cache store implementation which doesn't actually store anything. Useful in
    # development and test environments where you don't want caching turned on but
    # need to go through the caching interface.
    #
    # This cache does implement the local cache strategy, so values will actually
    # be cached inside blocks that utilize this strategy. See
    # ActiveSupport::Cache::Strategy::LocalCache for more details.
    class NullStore < Store
      # Advertise cache versioning support.
      def self.supports_cache_versioning?: () -> ::TrueClass

      def clear: (?untyped? options) -> nil

      def cleanup: (?untyped? options) -> nil

      def increment: (untyped name, ?::Integer amount, ?untyped? options) -> nil

      def decrement: (untyped name, ?::Integer amount, ?untyped? options) -> nil

      def delete_matched: (untyped matcher, ?untyped? options) -> nil

      private

      def read_entry: (untyped key, **untyped options) -> nil

      def write_entry: (untyped key, untyped entry, **untyped options) -> ::TrueClass

      def delete_entry: (untyped key, **untyped options) -> ::FalseClass
    end
  end
end

module ActiveSupport
  module Cache
    module ConnectionPoolLike
      def with: () { (untyped) -> untyped } -> untyped
    end

    # Redis cache store.
    #
    # Deployment note: Take care to use a *dedicated Redis cache* rather
    # than pointing this at your existing Redis server. It won't cope well
    # with mixed usage patterns and it won't expire cache entries by default.
    #
    # Redis cache server setup guide: https://redis.io/topics/lru-cache
    #
    # * Supports vanilla Redis, hiredis, and Redis::Distributed.
    # * Supports Memcached-like sharding across Redises with Redis::Distributed.
    # * Fault tolerant. If the Redis server is unavailable, no exceptions are
    #   raised. Cache fetches are all misses and writes are dropped.
    # * Local cache. Hot in-memory primary cache within block/middleware scope.
    # * +read_multi+ and +write_multi+ support for Redis mget/mset. Use Redis::Distributed
    #   4.0.1+ for distributed mget support.
    # * +delete_matched+ support for Redis KEYS globs.
    class RedisCacheStore < Store
      # Keys are truncated with their own SHA2 digest if they exceed 1kB
      MAX_KEY_BYTESIZE: ::Integer

      DEFAULT_REDIS_OPTIONS: ::Hash[untyped, untyped]

      DEFAULT_ERROR_HANDLER: untyped

      # The maximum number of entries to receive per SCAN call.
      SCAN_BATCH_SIZE: ::Integer

      # Advertise cache versioning support.
      def self.supports_cache_versioning?: () -> ::TrueClass

      module LocalCacheWithRaw
        private

        def write_entry: (untyped key, untyped entry, **untyped options) -> untyped

        def write_multi_entries: (untyped entries, **untyped options) -> untyped
      end

      def self.build_redis: (?url: untyped? url, ?redis: untyped? redis, **untyped redis_options) -> untyped

      private

      def self.build_redis_distributed_client: (urls: untyped urls, **untyped redis_options) -> untyped

      def self.build_redis_client: (url: untyped url, **untyped redis_options) -> untyped

      public

      attr_reader redis_options: untyped

      attr_reader max_key_bytesize: untyped

      # Creates a new Redis cache store.
      #
      # Handles four options: :redis block, :redis instance, single :url
      # string, and multiple :url strings.
      #
      #   Option  Class       Result
      #   :redis  Proc    ->  options[:redis].call
      #   :redis  Object  ->  options[:redis]
      #   :url    String  ->  Redis.new(url: (trim non-ascii characters))
      #   :url    Array   ->  Redis::Distributed.new([{ url: (trim non-ascii characters) }, { url: (trim non-ascii characters) }, (trim non-ascii characters)])
      #
      # No namespace is set by default. Provide one if the Redis cache
      # server is shared with other apps: <tt>namespace: 'myapp-cache'</tt>.
      #
      # Compression is enabled by default with a 1kB threshold, so cached
      # values larger than 1kB are automatically compressed. Disable by
      # passing <tt>compress: false</tt> or change the threshold by passing
      # <tt>compress_threshold: 4.kilobytes</tt>.
      #
      # No expiry is set on cache entries by default. Redis is expected to
      # be configured with an eviction policy that automatically deletes
      # least-recently or -frequently used keys when it reaches max memory.
      # See https://redis.io/topics/lru-cache for cache server setup.
      #
      # Race condition TTL is not set by default. This can be used to avoid
      # "thundering herd" cache writes when hot cache entries are expired.
      # See <tt>ActiveSupport::Cache::Store#fetch</tt> for more.
      def initialize: (?error_handler: untyped error_handler, ?race_condition_ttl: untyped? race_condition_ttl, ?expires_in: untyped? expires_in, ?compress_threshold: untyped compress_threshold, ?compress: bool compress, ?namespace: untyped? namespace, **untyped redis_options) -> untyped

      def redis: () -> untyped

      def inspect: () -> ::String

      # Cache Store API implementation.
      #
      # Read multiple values at once. Returns a hash of requested keys ->
      # fetched values.
      def read_multi: (*untyped names) -> untyped

      # Cache Store API implementation.
      #
      # Supports Redis KEYS glob patterns:
      #
      #   h?llo matches hello, hallo and hxllo
      #   h*llo matches hllo and heeeello
      #   h[ae]llo matches hello and hallo, but not hillo
      #   h[^e]llo matches hallo, hbllo, ... but not hello
      #   h[a-b]llo matches hallo and hbllo
      #
      # Use \ to escape special characters if you want to match them verbatim.
      #
      # See https://redis.io/commands/KEYS for more.
      #
      # Failsafe: Raises errors.
      def delete_matched: (untyped matcher, ?untyped? options) -> untyped

      # Cache Store API implementation.
      #
      # Increment a cached value. This method uses the Redis incr atomic
      # operator and can only be used on values written with the :raw option.
      # Calling it on a value not stored with :raw will initialize that value
      # to zero.
      #
      # Failsafe: Raises errors.
      def increment: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Cache Store API implementation.
      #
      # Decrement a cached value. This method uses the Redis decr atomic
      # operator and can only be used on values written with the :raw option.
      # Calling it on a value not stored with :raw will initialize that value
      # to zero.
      #
      # Failsafe: Raises errors.
      def decrement: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Cache Store API implementation.
      #
      # Removes expired entries. Handled natively by Redis least-recently-/
      # least-frequently-used expiry, so manual cleanup is not supported.
      def cleanup: (?untyped? options) -> untyped

      # Clear the entire cache on all Redis servers. Safe to use on
      # shared servers if the cache is namespaced.
      #
      # Failsafe: Raises errors.
      def clear: (?untyped? options) -> untyped

      def mget_capable?: () -> untyped

      def mset_capable?: () -> untyped

      private

      def set_redis_capabilities: () -> untyped

      # Store provider interface:
      # Read an entry from the cache.
      def read_entry: (untyped key, **untyped options) -> untyped

      def read_multi_entries: (untyped names, **untyped options) -> untyped

      def read_multi_mget: (*untyped names) -> (::Hash[untyped, untyped] | untyped)

      # Write an entry to the cache.
      #
      # Requires Redis 2.6.12+ for extended SET options.
      def write_entry: (untyped key, untyped entry, ?race_condition_ttl: untyped? race_condition_ttl, ?expires_in: untyped? expires_in, ?raw: bool raw, ?unless_exist: bool unless_exist, **untyped options) -> untyped

      def write_key_expiry: (untyped client, untyped key, untyped options) -> untyped

      # Delete an entry from the cache.
      def delete_entry: (untyped key, untyped options) -> untyped

      # Nonstandard store provider API to write multiple values at once.
      def write_multi_entries: (untyped entries, ?expires_in: untyped? expires_in, **untyped options) -> untyped

      # Truncate keys that exceed 1kB.
      def normalize_key: (untyped key, untyped options) -> untyped

      def truncate_key: (untyped key) -> untyped

      def deserialize_entry: (untyped serialized_entry, raw: untyped raw) -> untyped

      def serialize_entry: (untyped entry, ?raw: bool raw) -> untyped

      def serialize_entries: (untyped entries, ?raw: bool raw) -> untyped

      def failsafe: (untyped method, ?returning: untyped? returning) { () -> untyped } -> untyped

      def handle_exception: (returning: untyped returning, method: untyped method, exception: untyped exception) -> untyped
    end
  end
end

module ActiveSupport
  module Cache
    module Strategy
      # Caches that implement LocalCache will be backed by an in-memory cache for the
      # duration of a block. Repeated calls to the cache for the same key will hit the
      # in-memory cache for faster access.
      module LocalCache
        class LocalCacheRegistry
          # Class for storing and registering the local caches.
          # :nodoc:
          extend ActiveSupport::PerThreadRegistry

          def initialize: () -> untyped

          def cache_for: (untyped local_cache_key) -> untyped

          def set_cache_for: (untyped local_cache_key, untyped value) -> untyped

          def self.set_cache_for: (untyped l, untyped v) -> untyped

          def self.cache_for: (untyped l) -> untyped
        end

        # Simple memory backed cache. This cache is not thread safe and is intended only
        # for serving as a temporary memory cache for a single thread.
        class LocalStore < Store
          def initialize: () -> untyped

          def synchronize: () { () -> untyped } -> untyped

          def clear: (?untyped? options) -> untyped

          def read_entry: (untyped key, **untyped options) -> untyped

          def read_multi_entries: (untyped keys, **untyped options) -> untyped

          def write_entry: (untyped key, untyped value, **untyped options) -> ::TrueClass

          def delete_entry: (untyped key, **untyped options) -> untyped

          def fetch_entry: (untyped key, ?untyped? options) { () -> untyped } -> untyped
        end

        # Use a local cache for the duration of block.
        def with_local_cache: () { () -> untyped } -> untyped

        # Middleware class can be inserted as a Rack handler to be local cache for the
        # duration of request.
        def middleware: () -> untyped

        def clear: (**untyped options) -> untyped

        def cleanup: (**untyped options) -> untyped

        def increment: (untyped name, ?::Integer amount, **untyped options) -> untyped

        def decrement: (untyped name, ?::Integer amount, **untyped options) -> untyped

        private

        def read_entry: (untyped key, **untyped options) -> untyped

        def read_multi_entries: (untyped keys, **untyped options) -> untyped

        def write_entry: (untyped key, untyped entry, **untyped options) -> untyped

        def delete_entry: (untyped key, **untyped options) -> untyped

        def write_cache_value: (untyped name, untyped value, **untyped options) -> untyped

        def local_cache_key: () -> untyped

        def local_cache: () -> untyped

        def bypass_local_cache: () { () -> untyped } -> untyped

        def use_temporary_local_cache: (untyped temporary_cache) { () -> untyped } -> untyped
      end
    end
  end
end

module ActiveSupport
  module Cache
    module Strategy
      module LocalCache
        class Middleware
          # -
          # This class wraps up local storage for middlewares. Only the middleware method should
          # construct them.
          # :nodoc:
          attr_reader name: untyped

          # -
          # This class wraps up local storage for middlewares. Only the middleware method should
          # construct them.
          # :nodoc:
          attr_reader local_cache_key: untyped

          def initialize: (untyped name, untyped local_cache_key) -> untyped

          def new: (untyped app) -> untyped

          def call: (untyped env) -> untyped
        end
      end
    end
  end
end

module ActiveSupport
  # See ActiveSupport::Cache::Store for documentation.
  module Cache
    # These options mean something to all cache implementations. Individual cache
    # implementations may support additional options.
    UNIVERSAL_OPTIONS: ::Array[untyped]

    module Strategy
    end

    # Creates a new Store object according to the given options.
    #
    # If no arguments are passed to this method, then a new
    # ActiveSupport::Cache::MemoryStore object will be returned.
    #
    # If you pass a Symbol as the first argument, then a corresponding cache
    # store class under the ActiveSupport::Cache namespace will be created.
    # For example:
    #
    #   ActiveSupport::Cache.lookup_store(:memory_store)
    #   # => returns a new ActiveSupport::Cache::MemoryStore object
    #
    #   ActiveSupport::Cache.lookup_store(:mem_cache_store)
    #   # => returns a new ActiveSupport::Cache::MemCacheStore object
    #
    # Any additional arguments will be passed to the corresponding cache store
    # class's constructor:
    #
    #   ActiveSupport::Cache.lookup_store(:file_store, '/tmp/cache')
    #   # => same as: ActiveSupport::Cache::FileStore.new('/tmp/cache')
    #
    # If the first argument is not a Symbol, then it will simply be returned:
    #
    #   ActiveSupport::Cache.lookup_store(MyOwnCacheStore.new)
    #   # => returns MyOwnCacheStore.new
    def self.lookup_store: (?untyped? store, *untyped parameters) -> untyped

    # Expands out the +key+ argument into a key that can be used for the
    # cache store. Optionally accepts a namespace, and all keys will be
    # scoped within that namespace.
    #
    # If the +key+ argument provided is an array, or responds to +to_a+, then
    # each of elements in the array will be turned into parameters/keys and
    # concatenated into a single key. For example:
    #
    #   ActiveSupport::Cache.expand_cache_key([:foo, :bar])               # => "foo/bar"
    #   ActiveSupport::Cache.expand_cache_key([:foo, :bar], "namespace")  # => "namespace/foo/bar"
    #
    # The +key+ argument can also respond to +cache_key+ or +to_param+.
    def self.expand_cache_key: (untyped key, ?untyped? namespace) -> untyped

    private

    def self.retrieve_cache_key: (untyped key) -> untyped

    # Obtains the specified cache store class, given the name of the +store+.
    # Raises an error when the store class cannot be found.
    def self.retrieve_store_class: (untyped store) -> untyped

    public

    # An abstract cache store class. There are multiple cache store
    # implementations, each having its own additional features. See the classes
    # under the ActiveSupport::Cache module, e.g.
    # ActiveSupport::Cache::MemCacheStore. MemCacheStore is currently the most
    # popular cache store for large production websites.
    #
    # Some implementations may not support all methods beyond the basic cache
    # methods of +fetch+, +write+, +read+, +exist?+, and +delete+.
    #
    # ActiveSupport::Cache::Store can store any serializable Ruby object.
    #
    #   cache = ActiveSupport::Cache::MemoryStore.new
    #
    #   cache.read('city')   # => nil
    #   cache.write('city', "Duckburgh")
    #   cache.read('city')   # => "Duckburgh"
    #
    # Keys are always translated into Strings and are case sensitive. When an
    # object is specified as a key and has a +cache_key+ method defined, this
    # method will be called to define the key.  Otherwise, the +to_param+
    # method will be called. Hashes and Arrays can also be used as keys. The
    # elements will be delimited by slashes, and the elements within a Hash
    # will be sorted by key so they are consistent.
    #
    #   cache.read('city') == cache.read(:city)   # => true
    #
    # Nil values can be cached.
    #
    # If your cache is on a shared infrastructure, you can define a namespace
    # for your cache entries. If a namespace is defined, it will be prefixed on
    # to every key. The namespace can be either a static value or a Proc. If it
    # is a Proc, it will be invoked when each key is evaluated so that you can
    # use application logic to invalidate keys.
    #
    #   cache.namespace = -> { @last_mod_time }  # Set the namespace to a variable
    #   @last_mod_time = Time.now  # Invalidate the entire cache by changing namespace
    #
    # Cached data larger than 1kB are compressed by default. To turn off
    # compression, pass <tt>compress: false</tt> to the initializer or to
    # individual +fetch+ or +write+ method calls. The 1kB compression
    # threshold is configurable with the <tt>:compress_threshold</tt> option,
    # specified in bytes.
    class Store
      attr_reader silence: untyped

      attr_reader options: untyped

      alias silence? silence

      private

      def self.retrieve_pool_options: (untyped options) -> untyped

      def self.ensure_connection_pool_added!: () -> untyped

      public

      # Creates a new cache. The options will be passed to any write method calls
      # except for <tt>:namespace</tt> which can be used to set the global
      # namespace for the cache.
      def initialize: (?untyped? options) -> untyped

      # Silences the logger.
      def silence!: () -> untyped

      # Silences the logger within a block.
      def mute: () { () -> untyped } -> untyped

      # Fetches data from the cache, using the given key. If there is data in
      # the cache with the given key, then that data is returned.
      #
      # If there is no such data in the cache (a cache miss), then +nil+ will be
      # returned. However, if a block has been passed, that block will be passed
      # the key and executed in the event of a cache miss. The return value of the
      # block will be written to the cache under the given cache key, and that
      # return value will be returned.
      #
      #   cache.write('today', 'Monday')
      #   cache.fetch('today')  # => "Monday"
      #
      #   cache.fetch('city')   # => nil
      #   cache.fetch('city') do
      #     'Duckburgh'
      #   end
      #   cache.fetch('city')   # => "Duckburgh"
      #
      # You may also specify additional options via the +options+ argument.
      # Setting <tt>force: true</tt> forces a cache "miss," meaning we treat
      # the cache value as missing even if it's present. Passing a block is
      # required when +force+ is true so this always results in a cache write.
      #
      #   cache.write('today', 'Monday')
      #   cache.fetch('today', force: true) { 'Tuesday' } # => 'Tuesday'
      #   cache.fetch('today', force: true) # => ArgumentError
      #
      # The +:force+ option is useful when you're calling some other method to
      # ask whether you should force a cache write. Otherwise, it's clearer to
      # just call <tt>Cache#write</tt>.
      #
      # Setting <tt>skip_nil: true</tt> will not cache nil result:
      #
      #   cache.fetch('foo') { nil }
      #   cache.fetch('bar', skip_nil: true) { nil }
      #   cache.exist?('foo') # => true
      #   cache.exist?('bar') # => false
      #
      #
      # Setting <tt>compress: false</tt> disables compression of the cache entry.
      #
      # Setting <tt>:expires_in</tt> will set an expiration time on the cache.
      # All caches support auto-expiring content after a specified number of
      # seconds. This value can be specified as an option to the constructor
      # (in which case all entries will be affected), or it can be supplied to
      # the +fetch+ or +write+ method to effect just one entry.
      #
      #   cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 5.minutes)
      #   cache.write(key, value, expires_in: 1.minute) # Set a lower value for one entry
      #
      # Setting <tt>:version</tt> verifies the cache stored under <tt>name</tt>
      # is of the same version. nil is returned on mismatches despite contents.
      # This feature is used to support recyclable cache keys.
      #
      # Setting <tt>:race_condition_ttl</tt> is very useful in situations where
      # a cache entry is used very frequently and is under heavy load. If a
      # cache expires and due to heavy load several different processes will try
      # to read data natively and then they all will try to write to cache. To
      # avoid that case the first process to find an expired cache entry will
      # bump the cache expiration time by the value set in <tt>:race_condition_ttl</tt>.
      # Yes, this process is extending the time for a stale value by another few
      # seconds. Because of extended life of the previous cache, other processes
      # will continue to use slightly stale data for a just a bit longer. In the
      # meantime that first process will go ahead and will write into cache the
      # new value. After that all the processes will start getting the new value.
      # The key is to keep <tt>:race_condition_ttl</tt> small.
      #
      # If the process regenerating the entry errors out, the entry will be
      # regenerated after the specified number of seconds. Also note that the
      # life of stale cache is extended only if it expired recently. Otherwise
      # a new value is generated and <tt>:race_condition_ttl</tt> does not play
      # any role.
      #
      #   # Set all values to expire after one minute.
      #   cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 1.minute)
      #
      #   cache.write('foo', 'original value')
      #   val_1 = nil
      #   val_2 = nil
      #   sleep 60
      #
      #   Thread.new do
      #     val_1 = cache.fetch('foo', race_condition_ttl: 10.seconds) do
      #       sleep 1
      #       'new value 1'
      #     end
      #   end
      #
      #   Thread.new do
      #     val_2 = cache.fetch('foo', race_condition_ttl: 10.seconds) do
      #       'new value 2'
      #     end
      #   end
      #
      #   cache.fetch('foo') # => "original value"
      #   sleep 10 # First thread extended the life of cache by another 10 seconds
      #   cache.fetch('foo') # => "new value 1"
      #   val_1 # => "new value 1"
      #   val_2 # => "original value"
      #
      # Other options will be handled by the specific cache store implementation.
      # Internally, #fetch calls #read_entry, and calls #write_entry on a cache
      # miss. +options+ will be passed to the #read and #write calls.
      #
      # For example, MemCacheStore's #write method supports the +:raw+
      # option, which tells the memcached server to store all values as strings.
      # We can use this option with #fetch too:
      #
      #   cache = ActiveSupport::Cache::MemCacheStore.new
      #   cache.fetch("foo", force: true, raw: true) do
      #     :bar
      #   end
      #   cache.fetch('foo') # => "bar"
      def fetch: (untyped name, ?untyped? options) { (untyped) -> untyped } -> untyped

      # Reads data from the cache, using the given key. If there is data in
      # the cache with the given key, then that data is returned. Otherwise,
      # +nil+ is returned.
      #
      # Note, if data was written with the <tt>:expires_in</tt> or
      # <tt>:version</tt> options, both of these conditions are applied before
      # the data is returned.
      #
      # Options are passed to the underlying cache implementation.
      def read: (untyped name, ?untyped? options) -> untyped

      # Reads multiple values at once from the cache. Options can be passed
      # in the last argument.
      #
      # Some cache implementation may optimize this method.
      #
      # Returns a hash mapping the names provided to the values found.
      def read_multi: (*untyped names) -> untyped

      # Cache Storage API to write multiple values at once.
      def write_multi: (untyped hash, ?untyped? options) -> untyped

      # Fetches data from the cache, using the given keys. If there is data in
      # the cache with the given keys, then that data is returned. Otherwise,
      # the supplied block is called for each key for which there was no data,
      # and the result will be written to the cache and returned.
      # Therefore, you need to pass a block that returns the data to be written
      # to the cache. If you do not want to write the cache when the cache is
      # not found, use #read_multi.
      #
      # Returns a hash with the data for each of the names. For example:
      #
      #   cache.write("bim", "bam")
      #   cache.fetch_multi("bim", "unknown_key") do |key|
      #     "Fallback value for key: #{key}"
      #   end
      #   # => { "bim" => "bam",
      #   #      "unknown_key" => "Fallback value for key: unknown_key" }
      #
      # Options are passed to the underlying cache implementation. For example:
      #
      #   cache.fetch_multi("fizz", expires_in: 5.seconds) do |key|
      #     "buzz"
      #   end
      #   # => {"fizz"=>"buzz"}
      #   cache.read("fizz")
      #   # => "buzz"
      #   sleep(6)
      #   cache.read("fizz")
      #   # => nil
      def fetch_multi: (*untyped names) { (untyped) -> untyped } -> untyped

      # Writes the value to the cache, with the key.
      #
      # Options are passed to the underlying cache implementation.
      def write: (untyped name, untyped value, ?untyped? options) -> untyped

      # Deletes an entry in the cache. Returns +true+ if an entry is deleted.
      #
      # Options are passed to the underlying cache implementation.
      def delete: (untyped name, ?untyped? options) -> untyped

      # Returns +true+ if the cache contains an entry for the given key.
      #
      # Options are passed to the underlying cache implementation.
      def exist?: (untyped name, ?untyped? options) -> untyped

      # Deletes all entries with keys matching the pattern.
      #
      # Options are passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def delete_matched: (untyped matcher, ?untyped? options) -> untyped

      # Increments an integer value in the cache.
      #
      # Options are passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def increment: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Decrements an integer value in the cache.
      #
      # Options are passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def decrement: (untyped name, ?::Integer amount, ?untyped? options) -> untyped

      # Cleanups the cache by removing expired entries.
      #
      # Options are passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def cleanup: (?untyped? options) -> untyped

      # Clears the entire cache. Be careful with this method since it could
      # affect other processes if shared cache is being used.
      #
      # The options hash is passed to the underlying cache implementation.
      #
      # Some implementations may not support this method.
      def clear: (?untyped? options) -> untyped

      private

      def key_matcher: (untyped pattern, untyped options) -> untyped

      # Reads an entry from the cache implementation. Subclasses must implement
      # this method.
      def read_entry: (untyped key, **untyped options) -> untyped

      # Writes an entry to the cache implementation. Subclasses must implement
      # this method.
      def write_entry: (untyped key, untyped entry, **untyped options) -> untyped

      # Reads multiple entries from the cache implementation. Subclasses MAY
      # implement this method.
      def read_multi_entries: (untyped names, **untyped options) -> untyped

      # Writes multiple entries to the cache implementation. Subclasses MAY
      # implement this method.
      def write_multi_entries: (untyped hash, **untyped options) -> untyped

      # Deletes an entry from the cache implementation. Subclasses must
      # implement this method.
      def delete_entry: (untyped key, **untyped options) -> untyped

      # Merges the default options with ones specific to a method call.
      def merged_options: (untyped call_options) -> untyped

      # Expands and namespaces the cache key. May be overridden by
      # cache stores to do additional normalization.
      def normalize_key: (untyped key, ?untyped? options) -> untyped

      # Prefix the key with a namespace string:
      #
      #   namespace_key 'foo', namespace: 'cache'
      #   # => 'cache:foo'
      #
      # With a namespace block:
      #
      #   namespace_key 'foo', namespace: -> { 'cache' }
      #   # => 'cache:foo'
      def namespace_key: (untyped key, ?untyped? options) -> untyped

      # Expands key to be a consistent string value. Invokes +cache_key+ if
      # object responds to +cache_key+. Otherwise, +to_param+ method will be
      # called. If the key is a Hash, then keys will be sorted alphabetically.
      def expanded_key: (untyped key) -> untyped

      def normalize_version: (untyped key, ?untyped? options) -> untyped

      def expanded_version: (untyped key) -> untyped

      def instrument: (untyped operation, untyped key, ?untyped? options) { (untyped) -> untyped } -> untyped

      def log: () { () -> untyped } -> (nil | untyped)

      def handle_expired_entry: (untyped entry, untyped key, untyped options) -> untyped

      def get_entry_value: (untyped entry, untyped name, untyped options) -> untyped

      def save_block_result_to_cache: (untyped name, **untyped options) { (untyped) -> untyped } -> untyped
    end

    class Entry
      # This class is used to represent cache entries. Cache entries have a value, an optional
      # expiration time, and an optional version. The expiration time is used to support the :race_condition_ttl option
      # on the cache. The version is used to support the :version option on the cache for rejecting
      # mismatches.
      #
      # Since cache entries in most instances will be serialized, the internals of this class are highly optimized
      # using short instance variable names that are lazily defined.
      # :nodoc:
      attr_reader version: untyped

      DEFAULT_COMPRESS_LIMIT: untyped

      # Creates a new cache entry for the specified value. Options supported are
      # +:compress+, +:compress_threshold+, +:version+ and +:expires_in+.
      def initialize: (untyped value, ?expires_in: untyped? expires_in, ?version: untyped? version, ?compress_threshold: untyped compress_threshold, ?compress: bool compress) -> untyped

      def value: () -> untyped

      def mismatched?: (untyped version) -> untyped

      # Checks if the entry is expired. The +expires_in+ parameter can override
      # the value set when the entry was created.
      def expired?: () -> untyped

      def expires_at: () -> untyped

      def expires_at=: (untyped value) -> untyped

      # Returns the size of the cached value. This could be less than
      # <tt>value.size</tt> if the data is compressed.
      def size: () -> untyped

      # Duplicates the value in a class. This is used by cache implementations that don't natively
      # serialize entries to protect against accidental cache modifications.
      def dup_value!: () -> untyped

      private

      def compress!: (untyped compress_threshold) -> untyped

      def compressed?: () -> untyped

      def uncompress: (untyped value) -> untyped
    end
  end
end

module ActiveSupport
  # Callbacks are code hooks that are run at key points in an object's life cycle.
  # The typical use case is to have a base class define a set of callbacks
  # relevant to the other functionality it supplies, so that subclasses can
  # install callbacks that enhance or modify the base functionality without
  # needing to override or redefine methods of the base class.
  #
  # Mixing in this module allows you to define the events in the object's
  # life cycle that will support callbacks (via +ClassMethods.define_callbacks+),
  # set the instance methods, procs, or callback objects to be called (via
  # +ClassMethods.set_callback+), and run the installed callbacks at the
  # appropriate times (via +run_callbacks+).
  #
  # By default callbacks are halted by throwing +:abort+.
  # See +ClassMethods.define_callbacks+ for details.
  #
  # Three kinds of callbacks are supported: before callbacks, run before a
  # certain event; after callbacks, run after the event; and around callbacks,
  # blocks that surround the event, triggering it when they yield. Callback code
  # can be contained in instance methods, procs or lambdas, or callback objects
  # that respond to certain predetermined methods. See +ClassMethods.set_callback+
  # for details.
  #
  #   class Record
  #     include ActiveSupport::Callbacks
  #     define_callbacks :save
  #
  #     def save
  #       run_callbacks :save do
  #         puts "- save"
  #       end
  #     end
  #   end
  #
  #   class PersonRecord < Record
  #     set_callback :save, :before, :saving_message
  #     def saving_message
  #       puts "saving..."
  #     end
  #
  #     set_callback :save, :after do |object|
  #       puts "saved"
  #     end
  #   end
  #
  #   person = PersonRecord.new
  #   person.save
  #
  # Output:
  #   saving...
  #   - save
  #   saved
  module Callbacks
    extend Concern

    extend ActiveSupport::DescendantsTracker

    CALLBACK_FILTER_TYPES: ::Array[untyped]

    # Runs the callbacks for the given event.
    #
    # Calls the before and around callbacks in the order they were set, yields
    # the block (if given one), and then runs the after callbacks in reverse
    # order.
    #
    # If the callback chain was halted, returns +false+. Otherwise returns the
    # result of the block, +nil+ if no callbacks have been set, or +true+
    # if callbacks have been set but no block is given.
    #
    #   run_callbacks :save do
    #     save
    #   end
    #
    # -
    #
    # As this method is used in many places, and often wraps large portions of
    # user code, it has an additional design goal of minimizing its impact on
    # the visible call stack. An exception from inside a :before or :after
    # callback can be as noisy as it likes -- but when control has passed
    # smoothly through and into the supplied block, we want as little evidence
    # as possible that we were here.
    def run_callbacks: (untyped kind) { () -> untyped } -> untyped

    private

    # A hook invoked every time a before callback is halted.
    # This can be overridden in ActiveSupport::Callbacks implementors in order
    # to provide better debugging/logging.
    def halted_callback_hook: (untyped filter) -> nil

    module Conditionals
      # :nodoc:
      class Value
        def initialize: () { () -> untyped } -> untyped

        def call: (untyped target, untyped value) -> untyped
      end
    end

    module Filters
      class Environment[T] < ::Struct[T]
        attr_accessor target(): untyped

        attr_accessor halted(): untyped

        attr_accessor value(): untyped
      end

      class Before
        def self.build: (untyped callback_sequence, untyped user_callback, untyped user_conditions, untyped chain_config, untyped filter) -> untyped

        def self.halting_and_conditional: (untyped callback_sequence, untyped user_callback, untyped user_conditions, untyped halted_lambda, untyped filter) -> untyped

        def self.halting: (untyped callback_sequence, untyped user_callback, untyped halted_lambda, untyped filter) -> untyped
      end

      class After
        def self.build: (untyped callback_sequence, untyped user_callback, untyped user_conditions, untyped chain_config) -> untyped

        def self.halting_and_conditional: (untyped callback_sequence, untyped user_callback, untyped user_conditions) -> untyped

        def self.halting: (untyped callback_sequence, untyped user_callback) -> untyped

        def self.conditional: (untyped callback_sequence, untyped user_callback, untyped user_conditions) -> untyped

        def self.simple: (untyped callback_sequence, untyped user_callback) -> untyped
      end
    end

    class Callback
      # nodoc:#
      def self.build: (untyped chain, untyped filter, untyped kind, untyped options) -> untyped

      attr_accessor kind: untyped

      attr_accessor name: untyped

      attr_reader chain_config: untyped

      def initialize: (untyped name, untyped filter, untyped kind, untyped options, untyped chain_config) -> untyped

      def filter: () -> untyped

      def raw_filter: () -> untyped

      def merge_conditional_options: (untyped chain, unless_option: untyped unless_option, if_option: untyped if_option) -> untyped

      def matches?: (untyped _kind, untyped _filter) -> untyped

      def duplicates?: (untyped other) -> untyped

      # Wraps code with filter
      def apply: (untyped callback_sequence) -> untyped

      def current_scopes: () -> untyped

      private

      def check_conditionals: (untyped conditionals) -> untyped

      def compute_identifier: (untyped filter) -> untyped

      def conditions_lambdas: () -> untyped
    end

    class CallTemplate
      # A future invocation of user-supplied code (either as a callback,
      # or a condition filter).
      # :nodoc:
      def initialize: (untyped target, untyped method, untyped arguments, untyped block) -> untyped

      # Return the parts needed to make this call, with the given
      # input values.
      #
      # Returns an array of the form:
      #
      #   [target, block, method, *arguments]
      #
      # This array can be used as such:
      #
      #   target.send(method, *arguments, &block)
      #
      # The actual invocation is left up to the caller to minimize
      # call stack pollution.
      def expand: (untyped target, untyped value, untyped block) -> untyped

      # Return a lambda that will make this call when given the input
      # values.
      def make_lambda: () -> untyped

      # Return a lambda that will make this call when given the input
      # values, but then return the boolean inverse of that result.
      def inverted_lambda: () -> untyped

      # Filters support:
      #
      #   Symbols:: A method to call.
      #   Procs::   A proc to call with the object.
      #   Objects:: An object with a <tt>before_foo</tt> method on it to call.
      #
      # All of these objects are converted into a CallTemplate and handled
      # the same after this point.
      def self.build: (untyped filter, untyped callback) -> untyped
    end

    class CallbackSequence
      # Execute before and after filters in a sequence instead of
      # chaining them with nested lambda calls, see:
      # https://github.com/rails/rails/issues/18011
      # :nodoc:
      def initialize: (?untyped? nested, ?untyped? call_template, ?untyped? user_conditions) -> untyped

      def before: () { () -> untyped } -> untyped

      def after: () { () -> untyped } -> untyped

      def around: (untyped call_template, untyped user_conditions) -> CallbackSequence

      def skip?: (untyped arg) -> untyped

      attr_reader nested: untyped

      def final?: () -> untyped

      def expand_call_template: (untyped arg, untyped block) -> untyped

      def invoke_before: (untyped arg) -> untyped

      def invoke_after: (untyped arg) -> untyped
    end

    class CallbackChain
      # nodoc:#
      include Enumerable[untyped]

      attr_reader name: untyped

      attr_reader config: untyped

      def initialize: (untyped name, untyped config) -> untyped

      def each: () { (untyped) -> untyped } -> untyped

      def index: (untyped o) -> untyped

      def empty?: () -> untyped

      def insert: (untyped index, untyped o) -> untyped

      def delete: (untyped o) -> untyped

      def clear: () -> untyped

      def initialize_copy: (untyped other) -> untyped

      def compile: () -> untyped

      def append: (*untyped callbacks) -> untyped

      def prepend: (*untyped callbacks) -> untyped

      attr_reader chain: untyped

      private

      def append_one: (untyped callback) -> untyped

      def prepend_one: (untyped callback) -> untyped

      def remove_duplicates: (untyped callback) -> untyped

      def default_terminator: () -> untyped
    end

    module ClassMethods
      def normalize_callback_params: (untyped filters, untyped block) -> ::Array[untyped]

      def __update_callbacks: (untyped name) { (untyped, untyped) -> untyped } -> untyped

      # Install a callback for the given event.
      #
      #   set_callback :save, :before, :before_method
      #   set_callback :save, :after,  :after_method, if: :condition
      #   set_callback :save, :around, ->(r, block) { stuff; result = block.call; stuff }
      #
      # The second argument indicates whether the callback is to be run +:before+,
      # +:after+, or +:around+ the event. If omitted, +:before+ is assumed. This
      # means the first example above can also be written as:
      #
      #   set_callback :save, :before_method
      #
      # The callback can be specified as a symbol naming an instance method; as a
      # proc, lambda, or block; or as an object that responds to a certain method
      # determined by the <tt>:scope</tt> argument to +define_callbacks+.
      #
      # If a proc, lambda, or block is given, its body is evaluated in the context
      # of the current object. It can also optionally accept the current object as
      # an argument.
      #
      # Before and around callbacks are called in the order that they are set;
      # after callbacks are called in the reverse order.
      #
      # Around callbacks can access the return value from the event, if it
      # wasn't halted, from the +yield+ call.
      #
      # ===== Options
      #
      # * <tt>:if</tt> - A symbol or an array of symbols, each naming an instance
      #   method or a proc; the callback will be called only when they all return
      #   a true value.
      #
      #   If a proc is given, its body is evaluated in the context of the
      #   current object. It can also optionally accept the current object as
      #   an argument.
      # * <tt>:unless</tt> - A symbol or an array of symbols, each naming an
      #   instance method or a proc; the callback will be called only when they
      #   all return a false value.
      #
      #   If a proc is given, its body is evaluated in the context of the
      #   current object. It can also optionally accept the current object as
      #   an argument.
      # * <tt>:prepend</tt> - If +true+, the callback will be prepended to the
      #   existing chain rather than appended.
      def set_callback: (untyped name, *untyped filter_list) { () -> untyped } -> untyped

      # Skip a previously set callback. Like +set_callback+, <tt>:if</tt> or
      # <tt>:unless</tt> options may be passed in order to control when the
      # callback is skipped.
      #
      #   class Writer < Person
      #      skip_callback :validate, :before, :check_membership, if: -> { age > 18 }
      #   end
      #
      # An <tt>ArgumentError</tt> will be raised if the callback has not
      # already been set (unless the <tt>:raise</tt> option is set to <tt>false</tt>).
      def skip_callback: (untyped name, *untyped filter_list) { () -> untyped } -> untyped

      # Remove all set callbacks for the given event.
      def reset_callbacks: (untyped name) -> untyped

      # Define sets of events in the object life cycle that support callbacks.
      #
      #   define_callbacks :validate
      #   define_callbacks :initialize, :save, :destroy
      #
      # ===== Options
      #
      # * <tt>:terminator</tt> - Determines when a before filter will halt the
      #   callback chain, preventing following before and around callbacks from
      #   being called and the event from being triggered.
      #   This should be a lambda to be executed.
      #   The current object and the result lambda of the callback will be provided
      #   to the terminator lambda.
      #
      #     define_callbacks :validate, terminator: ->(target, result_lambda) { result_lambda.call == false }
      #
      #   In this example, if any before validate callbacks returns +false+,
      #   any successive before and around callback is not executed.
      #
      #   The default terminator halts the chain when a callback throws +:abort+.
      #
      # * <tt>:skip_after_callbacks_if_terminated</tt> - Determines if after
      #   callbacks should be terminated by the <tt>:terminator</tt> option. By
      #   default after callbacks are executed no matter if callback chain was
      #   terminated or not. This option has no effect if <tt>:terminator</tt>
      #   option is set to +nil+.
      #
      # * <tt>:scope</tt> - Indicates which methods should be executed when an
      #   object is used as a callback.
      #
      #     class Audit
      #       def before(caller)
      #         puts 'Audit: before is called'
      #       end
      #
      #       def before_save(caller)
      #         puts 'Audit: before_save is called'
      #       end
      #     end
      #
      #     class Account
      #       include ActiveSupport::Callbacks
      #
      #       define_callbacks :save
      #       set_callback :save, :before, Audit.new
      #
      #       def save
      #         run_callbacks :save do
      #           puts 'save in main'
      #         end
      #       end
      #     end
      #
      #   In the above case whenever you save an account the method
      #   <tt>Audit#before</tt> will be called. On the other hand
      #
      #     define_callbacks :save, scope: [:kind, :name]
      #
      #   would trigger <tt>Audit#before_save</tt> instead. That's constructed
      #   by calling <tt>#{kind}_#{name}</tt> on the given instance. In this
      #   case "kind" is "before" and "name" is "save". In this context +:kind+
      #   and +:name+ have special meanings: +:kind+ refers to the kind of
      #   callback (before/after/around) and +:name+ refers to the method on
      #   which callbacks are being defined.
      #
      #   A declaration like
      #
      #     define_callbacks :save, scope: [:name]
      #
      #   would call <tt>Audit#save</tt>.
      #
      # ===== Notes
      #
      # +names+ passed to +define_callbacks+ must not end with
      # <tt>!</tt>, <tt>?</tt> or <tt>=</tt>.
      #
      # Calling +define_callbacks+ multiple times with the same +names+ will
      # overwrite previous callbacks registered with +set_callback+.
      def define_callbacks: (*untyped names) -> untyped

      def get_callbacks: (untyped name) -> untyped

      def set_callbacks: (untyped name, untyped callbacks) -> untyped
    end
  end
end

module ActiveSupport
  # A typical module looks like this:
  #
  #   module M
  #     def self.included(base)
  #       base.extend ClassMethods
  #       base.class_eval do
  #         scope :disabled, -> { where(disabled: true) }
  #       end
  #     end
  #
  #     module ClassMethods
  #       ...
  #     end
  #   end
  #
  # By using <tt>ActiveSupport::Concern</tt> the above module could instead be
  # written as:
  #
  #   require 'active_support/concern'
  #
  #   module M
  #     extend ActiveSupport::Concern
  #
  #     included do
  #       scope :disabled, -> { where(disabled: true) }
  #     end
  #
  #     class_methods do
  #       ...
  #     end
  #   end
  #
  # Moreover, it gracefully handles module dependencies. Given a +Foo+ module
  # and a +Bar+ module which depends on the former, we would typically write the
  # following:
  #
  #   module Foo
  #     def self.included(base)
  #       base.class_eval do
  #         def self.method_injected_by_foo
  #           ...
  #         end
  #       end
  #     end
  #   end
  #
  #   module Bar
  #     def self.included(base)
  #       base.method_injected_by_foo
  #     end
  #   end
  #
  #   class Host
  #     include Foo # We need to include this dependency for Bar
  #     include Bar # Bar is the module that Host really needs
  #   end
  #
  # But why should +Host+ care about +Bar+'s dependencies, namely +Foo+? We
  # could try to hide these from +Host+ directly including +Foo+ in +Bar+:
  #
  #   module Bar
  #     include Foo
  #     def self.included(base)
  #       base.method_injected_by_foo
  #     end
  #   end
  #
  #   class Host
  #     include Bar
  #   end
  #
  # Unfortunately this won't work, since when +Foo+ is included, its <tt>base</tt>
  # is the +Bar+ module, not the +Host+ class. With <tt>ActiveSupport::Concern</tt>,
  # module dependencies are properly resolved:
  #
  #   require 'active_support/concern'
  #
  #   module Foo
  #     extend ActiveSupport::Concern
  #     included do
  #       def self.method_injected_by_foo
  #         ...
  #       end
  #     end
  #   end
  #
  #   module Bar
  #     extend ActiveSupport::Concern
  #     include Foo
  #
  #     included do
  #       self.method_injected_by_foo
  #     end
  #   end
  #
  #   class Host
  #     include Bar # It works, now Bar takes care of its dependencies
  #   end
  module Concern
    class MultipleIncludedBlocks < StandardError
      # nodoc:
      def initialize: () -> untyped
    end

    def self.extended: (untyped base) -> untyped

    def append_features: (untyped base) -> untyped

    # Evaluate given block in context of base class,
    # so that you can write class macros here.
    # When you define more than one +included+ block, it raises an exception.
    def included: (?untyped? base) { () -> untyped } -> untyped

    # Define class methods from given block.
    # You can define private class methods as well.
    #
    #   module Example
    #     extend ActiveSupport::Concern
    #
    #     class_methods do
    #       def foo; puts 'foo'; end
    #
    #       private
    #         def bar; puts 'bar'; end
    #     end
    #   end
    #
    #   class Buzz
    #     include Example
    #   end
    #
    #   Buzz.foo # => "foo"
    #   Buzz.bar # => private method 'bar' called for Buzz:Class(NoMethodError)
    def class_methods: () { () -> untyped } -> untyped
  end
end

module ActiveSupport
  module Concurrency
    # A monitor that will permit dependency loading while blocked waiting for
    # the lock.
    class LoadInterlockAwareMonitor < Monitor
      EXCEPTION_NEVER: untyped

      EXCEPTION_IMMEDIATE: untyped

      # Enters an exclusive section, but allows dependency loading while blocked
      def mon_enter: () -> untyped

      def synchronize: () { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Concurrency
    # A share/exclusive lock, otherwise known as a read/write lock.
    #
    # https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock
    class ShareLock
      include MonitorMixin

      def raw_state: () { (untyped) -> untyped } -> untyped

      def initialize: () -> untyped

      # Returns false if +no_wait+ is set and the lock is not
      # immediately available. Otherwise, returns true after the lock
      # has been acquired.
      #
      # +purpose+ and +compatible+ work together; while this thread is
      # waiting for the exclusive lock, it will yield its share (if any)
      # to any other attempt whose +purpose+ appears in this attempt's
      # +compatible+ list. This allows a "loose" upgrade, which, being
      # less strict, prevents some classes of deadlocks.
      #
      # For many resources, loose upgrades are sufficient: if a thread
      # is awaiting a lock, it is not running any other code. With
      # +purpose+ matching, it is possible to yield only to other
      # threads whose activity will not interfere.
      def start_exclusive: (?no_wait: bool no_wait, ?compatible: untyped compatible, ?purpose: untyped? purpose) -> untyped

      # Relinquish the exclusive lock. Must only be called by the thread
      # that called start_exclusive (and currently holds the lock).
      def stop_exclusive: (?compatible: untyped compatible) -> untyped

      def start_sharing: () -> untyped

      def stop_sharing: () -> untyped

      # Execute the supplied block while holding the Exclusive lock. If
      # +no_wait+ is set and the lock is not immediately available,
      # returns +nil+ without yielding. Otherwise, returns the result of
      # the block.
      #
      # See +start_exclusive+ for other options.
      def exclusive: (?no_wait: bool no_wait, ?after_compatible: untyped after_compatible, ?compatible: untyped compatible, ?purpose: untyped? purpose) { () -> untyped } -> untyped

      # Execute the supplied block while holding the Share lock.
      def sharing: () { () -> untyped } -> untyped

      # Temporarily give up all held Share locks while executing the
      # supplied block, allowing any +compatible+ exclusive lock request
      # to proceed.
      def yield_shares: (?block_share: bool block_share, ?compatible: untyped compatible, ?purpose: untyped? purpose) { () -> untyped } -> untyped

      private

      # Must be called within synchronize
      def busy_for_exclusive?: (untyped purpose) -> untyped

      def busy_for_sharing?: (untyped purpose) -> untyped

      def eligible_waiters?: (untyped compatible) -> untyped

      def wait_for: (untyped method) { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  # Configurable provides a <tt>config</tt> method to store and retrieve
  # configuration options as an <tt>OrderedHash</tt>.
  module Configurable
    extend ActiveSupport::Concern

    class Configuration[T, U] < ActiveSupport::InheritableOptions[T, U]
      def compile_methods!: () -> untyped

      # Compiles reader methods so we don't have to go through method_missing.
      def self.compile_methods!: (untyped keys) -> untyped
    end

    module ClassMethods
      def config: () -> untyped

      def configure: () { (untyped) -> untyped } -> untyped

      private

      def config_accessor: (*untyped names, ?instance_accessor: bool instance_accessor, ?instance_writer: bool instance_writer, ?instance_reader: bool instance_reader) { () -> untyped } -> untyped
    end

    # Reads and writes attributes from a configuration <tt>OrderedHash</tt>.
    #
    #   require 'active_support/configurable'
    #
    #   class User
    #     include ActiveSupport::Configurable
    #   end
    #
    #   user = User.new
    #
    #   user.config.allowed_access = true
    #   user.config.level = 1
    #
    #   user.config.allowed_access # => true
    #   user.config.level          # => 1
    def config: () -> untyped
  end
end

class Array[unchecked out Elem]
  # Returns the tail of the array from +position+.
  #
  #   %w( a b c d ).from(0)  # => ["a", "b", "c", "d"]
  #   %w( a b c d ).from(2)  # => ["c", "d"]
  #   %w( a b c d ).from(10) # => []
  #   %w().from(0)           # => []
  #   %w( a b c d ).from(-2) # => ["c", "d"]
  #   %w( a b c ).from(-10)  # => []
  def from: (untyped position) -> untyped

  # Returns the beginning of the array up to +position+.
  #
  #   %w( a b c d ).to(0)  # => ["a"]
  #   %w( a b c d ).to(2)  # => ["a", "b", "c"]
  #   %w( a b c d ).to(10) # => ["a", "b", "c", "d"]
  #   %w().to(0)           # => []
  #   %w( a b c d ).to(-2) # => ["a", "b", "c"]
  #   %w( a b c ).to(-10)  # => []
  def to: (untyped position) -> untyped

  # Returns a new array that includes the passed elements.
  #
  #   [ 1, 2, 3 ].including(4, 5) # => [ 1, 2, 3, 4, 5 ]
  #   [ [ 0, 1 ] ].including([ [ 1, 0 ] ]) # => [ [ 0, 1 ], [ 1, 0 ] ]
  def including: (*untyped elements) -> untyped

  # Returns a copy of the Array excluding the specified elements.
  #
  #   ["David", "Rafael", "Aaron", "Todd"].excluding("Aaron", "Todd") # => ["David", "Rafael"]
  #   [ [ 0, 1 ], [ 1, 0 ] ].excluding([ [ 1, 0 ] ]) # => [ [ 0, 1 ] ]
  #
  # Note: This is an optimization of <tt>Enumerable#excluding</tt> that uses <tt>Array#-</tt>
  # instead of <tt>Array#reject</tt> for performance reasons.
  def excluding: (*untyped elements) -> untyped

  # Alias for #excluding.
  def without: (*untyped elements) -> untyped

  # Equal to <tt>self[1]</tt>.
  #
  #   %w( a b c d e ).second # => "b"
  def second: () -> untyped

  # Equal to <tt>self[2]</tt>.
  #
  #   %w( a b c d e ).third # => "c"
  def third: () -> untyped

  # Equal to <tt>self[3]</tt>.
  #
  #   %w( a b c d e ).fourth # => "d"
  def fourth: () -> untyped

  # Equal to <tt>self[4]</tt>.
  #
  #   %w( a b c d e ).fifth # => "e"
  def fifth: () -> untyped

  # Equal to <tt>self[41]</tt>. Also known as accessing "the reddit".
  #
  #   (1..42).to_a.forty_two # => 42
  def forty_two: () -> untyped

  # Equal to <tt>self[-3]</tt>.
  #
  #   %w( a b c d e ).third_to_last # => "c"
  def third_to_last: () -> untyped

  # Equal to <tt>self[-2]</tt>.
  #
  #   %w( a b c d e ).second_to_last # => "d"
  def second_to_last: () -> untyped
end

class Array[unchecked out Elem]
  # Converts the array to a comma-separated sentence where the last element is
  # joined by the connector word.
  #
  # You can pass the following options to change the default behavior. If you
  # pass an option key that doesn't exist in the list below, it will raise an
  # <tt>ArgumentError</tt>.
  #
  # ==== Options
  #
  # * <tt>:words_connector</tt> - The sign or word used to join the elements
  #   in arrays with two or more elements (default: ", ").
  # * <tt>:two_words_connector</tt> - The sign or word used to join the elements
  #   in arrays with two elements (default: " and ").
  # * <tt>:last_word_connector</tt> - The sign or word used to join the last element
  #   in arrays with three or more elements (default: ", and ").
  # * <tt>:locale</tt> - If +i18n+ is available, you can set a locale and use
  #   the connector options defined on the 'support.array' namespace in the
  #   corresponding dictionary file.
  #
  # ==== Examples
  #
  #   [].to_sentence                      # => ""
  #   ['one'].to_sentence                 # => "one"
  #   ['one', 'two'].to_sentence          # => "one and two"
  #   ['one', 'two', 'three'].to_sentence # => "one, two, and three"
  #
  #   ['one', 'two'].to_sentence(passing: 'invalid option')
  #   # => ArgumentError: Unknown key: :passing. Valid keys are: :words_connector, :two_words_connector, :last_word_connector, :locale
  #
  #   ['one', 'two'].to_sentence(two_words_connector: '-')
  #   # => "one-two"
  #
  #   ['one', 'two', 'three'].to_sentence(words_connector: ' or ', last_word_connector: ' or at least ')
  #   # => "one or two or at least three"
  #
  # Using <tt>:locale</tt> option:
  #
  #   # Given this locale dictionary:
  #   #
  #   #   es:
  #   #     support:
  #   #       array:
  #   #         words_connector: " o "
  #   #         two_words_connector: " y "
  #   #         last_word_connector: " o al menos "
  #
  #   ['uno', 'dos'].to_sentence(locale: :es)
  #   # => "uno y dos"
  #
  #   ['uno', 'dos', 'tres'].to_sentence(locale: :es)
  #   # => "uno o dos o al menos tres"
  def to_sentence: (?::Hash[untyped, untyped] options) -> untyped

  # Extends <tt>Array#to_s</tt> to convert a collection of elements into a
  # comma separated id list if <tt>:db</tt> argument is given as the format.
  #
  #   Blog.all.to_formatted_s(:db)  # => "1,2,3"
  #   Blog.none.to_formatted_s(:db) # => "null"
  #   [1,2].to_formatted_s          # => "[1, 2]"
  def to_formatted_s: (?::Symbol format) -> untyped

  alias to_default_s to_s

  # Returns a string that represents the array in XML by invoking +to_xml+
  # on each element. Active Record collections delegate their representation
  # in XML to this method.
  #
  # All elements are expected to respond to +to_xml+, if any of them does
  # not then an exception is raised.
  #
  # The root node reflects the class name of the first element in plural
  # if all elements belong to the same type and that's not Hash:
  #
  #   customer.projects.to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <projects type="array">
  #     <project>
  #       <amount type="decimal">20000.0</amount>
  #       <customer-id type="integer">1567</customer-id>
  #       <deal-date type="date">2008-04-09</deal-date>
  #       ...
  #     </project>
  #     <project>
  #       <amount type="decimal">57230.0</amount>
  #       <customer-id type="integer">1567</customer-id>
  #       <deal-date type="date">2008-04-15</deal-date>
  #       ...
  #     </project>
  #   </projects>
  #
  # Otherwise the root element is "objects":
  #
  #   [{ foo: 1, bar: 2}, { baz: 3}].to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <objects type="array">
  #     <object>
  #       <bar type="integer">2</bar>
  #       <foo type="integer">1</foo>
  #     </object>
  #     <object>
  #       <baz type="integer">3</baz>
  #     </object>
  #   </objects>
  #
  # If the collection is empty the root element is "nil-classes" by default:
  #
  #   [].to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <nil-classes type="array"/>
  #
  # To ensure a meaningful root element use the <tt>:root</tt> option:
  #
  #   customer_with_no_projects.projects.to_xml(root: 'projects')
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <projects type="array"/>
  #
  # By default name of the node for the children of root is <tt>root.singularize</tt>.
  # You can change it with the <tt>:children</tt> option.
  #
  # The +options+ hash is passed downwards:
  #
  #   Message.all.to_xml(skip_types: true)
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <messages>
  #     <message>
  #       <created-at>2008-03-07T09:58:18+01:00</created-at>
  #       <id>1</id>
  #       <name>1</name>
  #       <updated-at>2008-03-07T09:58:18+01:00</updated-at>
  #       <user-id>1</user-id>
  #     </message>
  #   </messages>
  #
  def to_xml: (?::Hash[untyped, untyped] options) { (untyped) -> untyped } -> untyped
end

class Array[unchecked out Elem]
  # Removes and returns the elements for which the block returns a true value.
  # If no block is given, an Enumerator is returned instead.
  #
  #   numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #   odd_numbers = numbers.extract! { |number| number.odd? } # => [1, 3, 5, 7, 9]
  #   numbers # => [0, 2, 4, 6, 8]
  def extract!: () { (untyped) -> untyped } -> untyped
end

class Hash[unchecked out K, unchecked out V]
  # By default, only instances of Hash itself are extractable.
  # Subclasses of Hash may implement this method and return
  # true to declare themselves as extractable. If a Hash
  # is extractable, Array#extract_options! pops it from
  # the Array when it is the last element of the Array.
  def extractable_options?: () -> untyped
end

class Array[unchecked out Elem]
  # Extracts options from a set of arguments. Removes and returns the last
  # element in the array if it's a hash, otherwise returns a blank hash.
  #
  #   def options(*args)
  #     args.extract_options!
  #   end
  #
  #   options(1, 2)        # => {}
  #   options(1, 2, a: :b) # => {:a=>:b}
  def extract_options!: () -> untyped
end

class Array[unchecked out Elem]
  # Splits or iterates over the array in groups of size +number+,
  # padding any remaining slots with +fill_with+ unless it is +false+.
  #
  #   %w(1 2 3 4 5 6 7 8 9 10).in_groups_of(3) {|group| p group}
  #   ["1", "2", "3"]
  #   ["4", "5", "6"]
  #   ["7", "8", "9"]
  #   ["10", nil, nil]
  #
  #   %w(1 2 3 4 5).in_groups_of(2, '&nbsp;') {|group| p group}
  #   ["1", "2"]
  #   ["3", "4"]
  #   ["5", "&nbsp;"]
  #
  #   %w(1 2 3 4 5).in_groups_of(2, false) {|group| p group}
  #   ["1", "2"]
  #   ["3", "4"]
  #   ["5"]
  def in_groups_of: (untyped number, ?untyped? fill_with) { (untyped) -> untyped } -> untyped

  # Divides the array into one or more subarrays based on a delimiting +value+
  # or the result of an optional block.
  #
  #   [1, 2, 3, 4, 5].split(3)              # => [[1, 2], [4, 5]]
  #   (1..10).to_a.split { |i| i % 3 == 0 } # => [[1, 2], [4, 5], [7, 8], [10]]
  def split: (?untyped? value) { (untyped) -> untyped } -> untyped
end

class Array[unchecked out Elem]
  # Wraps the array in an +ArrayInquirer+ object, which gives a friendlier way
  # to check its string-like contents.
  #
  #   pets = [:cat, :dog].inquiry
  #
  #   pets.cat?     # => true
  #   pets.ferret?  # => false
  #
  #   pets.any?(:cat, :ferret)  # => true
  #   pets.any?(:ferret, :alligator)  # => false
  def inquiry: () -> ActiveSupport::ArrayInquirer[Elem]
end

class Array[unchecked out Elem]
  # Wraps its argument in an array unless it is already an array (or array-like).
  #
  # Specifically:
  #
  # * If the argument is +nil+ an empty array is returned.
  # * Otherwise, if the argument responds to +to_ary+ it is invoked, and its result returned.
  # * Otherwise, returns an array with the argument as its single element.
  #
  #     Array.wrap(nil)       # => []
  #     Array.wrap([1, 2, 3]) # => [1, 2, 3]
  #     Array.wrap(0)         # => [0]
  #
  # This method is similar in purpose to <tt>Kernel#Array</tt>, but there are some differences:
  #
  # * If the argument responds to +to_ary+ the method is invoked. <tt>Kernel#Array</tt>
  #   moves on to try +to_a+ if the returned value is +nil+, but <tt>Array.wrap</tt> returns
  #   an array with the argument as its single element right away.
  # * If the returned value from +to_ary+ is neither +nil+ nor an +Array+ object, <tt>Kernel#Array</tt>
  #   raises an exception, while <tt>Array.wrap</tt> does not, it just returns the value.
  # * It does not call +to_a+ on the argument, if the argument does not respond to +to_ary+
  #   it returns an array with the argument as its single element.
  #
  # The last point is easily explained with some enumerables:
  #
  #   Array(foo: :bar)      # => [[:foo, :bar]]
  #   Array.wrap(foo: :bar) # => [{:foo=>:bar}]
  #
  # There's also a related idiom that uses the splat operator:
  #
  #   [*object]
  #
  # which returns <tt>[]</tt> for +nil+, but calls to <tt>Array(object)</tt> otherwise.
  #
  # The differences with <tt>Kernel#Array</tt> explained above
  # apply to the rest of <tt>object</tt>s.
  def self.wrap: (untyped object) -> untyped
end

module ActiveSupport
  module BigDecimalWithDefaultFormat
    # nodoc:
    def to_s: (?::String format) -> untyped
  end
end

class Class
  # Declare a class-level attribute whose value is inheritable by subclasses.
  # Subclasses can change their own value and it will not impact parent class.
  #
  # ==== Options
  #
  # * <tt>:instance_reader</tt> - Sets the instance reader method (defaults to true).
  # * <tt>:instance_writer</tt> - Sets the instance writer method (defaults to true).
  # * <tt>:instance_accessor</tt> - Sets both instance methods (defaults to true).
  # * <tt>:instance_predicate</tt> - Sets a predicate method (defaults to true).
  # * <tt>:default</tt> - Sets a default value for the attribute (defaults to nil).
  #
  # ==== Examples
  #
  #   class Base
  #     class_attribute :setting
  #   end
  #
  #   class Subclass < Base
  #   end
  #
  #   Base.setting = true
  #   Subclass.setting            # => true
  #   Subclass.setting = false
  #   Subclass.setting            # => false
  #   Base.setting                # => true
  #
  # In the above case as long as Subclass does not assign a value to setting
  # by performing <tt>Subclass.setting = _something_</tt>, <tt>Subclass.setting</tt>
  # would read value assigned to parent class. Once Subclass assigns a value then
  # the value assigned by Subclass would be returned.
  #
  # This matches normal Ruby method inheritance: think of writing an attribute
  # on a subclass as overriding the reader method. However, you need to be aware
  # when using +class_attribute+ with mutable structures as +Array+ or +Hash+.
  # In such cases, you don't want to do changes in place. Instead use setters:
  #
  #   Base.setting = []
  #   Base.setting                # => []
  #   Subclass.setting            # => []
  #
  #   # Appending in child changes both parent and child because it is the same object:
  #   Subclass.setting << :foo
  #   Base.setting               # => [:foo]
  #   Subclass.setting           # => [:foo]
  #
  #   # Use setters to not propagate changes:
  #   Base.setting = []
  #   Subclass.setting += [:foo]
  #   Base.setting               # => []
  #   Subclass.setting           # => [:foo]
  #
  # For convenience, an instance predicate method is defined as well.
  # To skip it, pass <tt>instance_predicate: false</tt>.
  #
  #   Subclass.setting?       # => false
  #
  # Instances may overwrite the class value in the same way:
  #
  #   Base.setting = true
  #   object = Base.new
  #   object.setting          # => true
  #   object.setting = false
  #   object.setting          # => false
  #   Base.setting            # => true
  #
  # To opt out of the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   object.setting          # => NoMethodError
  #   object.setting?         # => NoMethodError
  #
  # To opt out of the instance writer method, pass <tt>instance_writer: false</tt>.
  #
  #   object.setting = false  # => NoMethodError
  #
  # To opt out of both instance methods, pass <tt>instance_accessor: false</tt>.
  #
  # To set a default value for the attribute, pass <tt>default:</tt>, like so:
  #
  #   class_attribute :settings, default: {}
  def class_attribute: (*untyped attrs, ?default: untyped? default, ?instance_predicate: bool instance_predicate, ?instance_writer: untyped instance_writer, ?instance_reader: untyped instance_reader, ?instance_accessor: bool instance_accessor) -> untyped
end

class Class
  # Returns an array with all classes that are < than its receiver.
  #
  #   class C; end
  #   C.descendants # => []
  #
  #   class B < C; end
  #   C.descendants # => [B]
  #
  #   class A < B; end
  #   C.descendants # => [B, A]
  #
  #   class D < C; end
  #   C.descendants # => [B, A, D]
  def descendants: () -> untyped
end

class Date
  # Duck-types as a Date-like class. See Object#acts_like?.
  def acts_like_date?: () -> ::TrueClass
end

class Date
  # nodoc:
  # No Date is blank:
  #
  #   Date.today.blank? # => false
  #
  # @return [false]
  def blank?: () -> ::FalseClass
end

class Date
  include DateAndTime::Calculations

  attr_accessor self.beginning_of_week_default: untyped

  # Returns the week start (e.g. :monday) for the current request, if this has been set (via Date.beginning_of_week=).
  # If <tt>Date.beginning_of_week</tt> has not been set for the current request, returns the week start specified in <tt>config.beginning_of_week</tt>.
  # If no config.beginning_of_week was specified, returns :monday.
  def self.beginning_of_week: () -> untyped

  # Sets <tt>Date.beginning_of_week</tt> to a week start (e.g. :monday) for current request/thread.
  #
  # This method accepts any of the following day symbols:
  # :monday, :tuesday, :wednesday, :thursday, :friday, :saturday, :sunday
  def self.beginning_of_week=: (untyped week_start) -> untyped

  # Returns week start day symbol (e.g. :monday), or raises an +ArgumentError+ for invalid day symbol.
  def self.find_beginning_of_week!: (untyped week_start) -> untyped

  # Returns a new Date representing the date 1 day ago (i.e. yesterday's date).
  def self.yesterday: () -> untyped

  # Returns a new Date representing the date 1 day after today (i.e. tomorrow's date).
  def self.tomorrow: () -> untyped

  # Returns Time.zone.today when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns Date.today.
  def self.current: () -> untyped

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  # and then subtracts the specified number of seconds.
  def ago: (untyped seconds) -> untyped

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  # and then adds the specified number of seconds
  def since: (untyped seconds) -> untyped

  alias in since

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  def beginning_of_day: () -> untyped

  alias midnight beginning_of_day

  alias at_midnight beginning_of_day

  alias at_beginning_of_day beginning_of_day

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)
  def middle_of_day: () -> untyped

  alias midday middle_of_day

  alias noon middle_of_day

  alias at_midday middle_of_day

  alias at_noon middle_of_day

  alias at_middle_of_day middle_of_day

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the end of the day (23:59:59)
  def end_of_day: () -> untyped

  alias at_end_of_day end_of_day

  def plus_with_duration: (untyped other) -> untyped

  alias plus_without_duration +

  def +: (ActiveSupport::Duration other) -> self
       | ...

  def minus_with_duration: (untyped other) -> untyped

  alias minus_without_duration -

  def -: (ActiveSupport::Duration other) -> self
       | ...

  # Provides precise Date calculations for years, months, and days. The +options+ parameter takes a hash with
  # any of these keys: <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>.
  def advance: (untyped options) -> untyped

  # Returns a new Date where one or more of the elements have been changed according to the +options+ parameter.
  # The +options+ parameter is a hash with a combination of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>.
  #
  #   Date.new(2007, 5, 12).change(day: 1)               # => Date.new(2007, 5, 1)
  #   Date.new(2007, 5, 12).change(year: 2005, month: 1) # => Date.new(2005, 1, 12)
  def change: (untyped options) -> untyped

  # Allow Date to be compared with Time by converting to DateTime and relying on the <=> from there.
  def compare_with_coercion: (untyped other) -> untyped

  alias compare_without_coercion <=>
end

class Date
  DATE_FORMATS: ::Hash[untyped, untyped]

  # Convert to a formatted string. See DATE_FORMATS for predefined formats.
  #
  # This method is aliased to <tt>to_s</tt>.
  #
  #   date = Date.new(2007, 11, 10)       # => Sat, 10 Nov 2007
  #
  #   date.to_formatted_s(:db)            # => "2007-11-10"
  #   date.to_s(:db)                      # => "2007-11-10"
  #
  #   date.to_formatted_s(:short)         # => "10 Nov"
  #   date.to_formatted_s(:number)        # => "20071110"
  #   date.to_formatted_s(:long)          # => "November 10, 2007"
  #   date.to_formatted_s(:long_ordinal)  # => "November 10th, 2007"
  #   date.to_formatted_s(:rfc822)        # => "10 Nov 2007"
  #   date.to_formatted_s(:iso8601)       # => "2007-11-10"
  #
  # == Adding your own date formats to to_formatted_s
  # You can add your own formats to the Date::DATE_FORMATS hash.
  # Use the format name as the hash key and either a strftime string
  # or Proc instance that takes a date argument as the value.
  #
  #   # config/initializers/date_formats.rb
  #   Date::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Date::DATE_FORMATS[:short_ordinal] = ->(date) { date.strftime("%B #{date.day.ordinalize}") }
  def to_formatted_s: (?::Symbol format) -> untyped

  alias to_default_s to_s

  # Overrides the default inspect method with a human readable one, e.g., "Mon, 21 Feb 2005"
  def readable_inspect: () -> untyped
end

class Date
  include DateAndTime::Zones
end

module DateAndTime
  module Calculations
    DAYS_INTO_WEEK: ::Hash[untyped, untyped]

    WEEKEND_DAYS: ::Array[untyped]

    # Returns a new date/time representing yesterday.
    def yesterday: () -> untyped

    # Returns a new date/time representing tomorrow.
    def tomorrow: () -> untyped

    # Returns true if the date/time is today.
    def today?: () -> untyped

    # Returns true if the date/time is in the past.
    def past?: () -> untyped

    # Returns true if the date/time is in the future.
    def future?: () -> untyped

    # Returns true if the date/time falls on a Saturday or Sunday.
    def on_weekend?: () -> untyped

    # Returns true if the date/time does not fall on a Saturday or Sunday.
    def on_weekday?: () -> untyped

    # Returns true if the date/time falls before <tt>date_or_time</tt>.
    def before?: (untyped date_or_time) -> untyped

    # Returns true if the date/time falls after <tt>date_or_time</tt>.
    def after?: (untyped date_or_time) -> untyped

    # Returns a new date/time the specified number of days ago.
    def days_ago: (untyped days) -> untyped

    # Returns a new date/time the specified number of days in the future.
    def days_since: (untyped days) -> untyped

    # Returns a new date/time the specified number of weeks ago.
    def weeks_ago: (untyped weeks) -> untyped

    # Returns a new date/time the specified number of weeks in the future.
    def weeks_since: (untyped weeks) -> untyped

    # Returns a new date/time the specified number of months ago.
    def months_ago: (untyped months) -> untyped

    # Returns a new date/time the specified number of months in the future.
    def months_since: (untyped months) -> untyped

    # Returns a new date/time the specified number of years ago.
    def years_ago: (untyped years) -> untyped

    # Returns a new date/time the specified number of years in the future.
    def years_since: (untyped years) -> untyped

    # Returns a new date/time at the start of the month.
    #
    #   today = Date.today # => Thu, 18 Jun 2015
    #   today.beginning_of_month # => Mon, 01 Jun 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Thu, 18 Jun 2015 15:23:13 +0000
    #   now.beginning_of_month # => Mon, 01 Jun 2015 00:00:00 +0000
    def beginning_of_month: () -> untyped

    alias at_beginning_of_month beginning_of_month

    # Returns a new date/time at the start of the quarter.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.beginning_of_quarter # => Wed, 01 Jul 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.beginning_of_quarter # => Wed, 01 Jul 2015 00:00:00 +0000
    def beginning_of_quarter: () -> untyped

    alias at_beginning_of_quarter beginning_of_quarter

    # Returns a new date/time at the end of the quarter.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.end_of_quarter # => Wed, 30 Sep 2015
    #
    # +DateTime+ objects will have a time set to 23:59:59.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.end_of_quarter # => Wed, 30 Sep 2015 23:59:59 +0000
    def end_of_quarter: () -> untyped

    alias at_end_of_quarter end_of_quarter

    # Returns a new date/time at the beginning of the year.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.beginning_of_year # => Thu, 01 Jan 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.beginning_of_year # => Thu, 01 Jan 2015 00:00:00 +0000
    def beginning_of_year: () -> untyped

    alias at_beginning_of_year beginning_of_year

    # Returns a new date/time representing the given day in the next week.
    #
    #   today = Date.today # => Thu, 07 May 2015
    #   today.next_week    # => Mon, 11 May 2015
    #
    # The +given_day_in_next_week+ defaults to the beginning of the week
    # which is determined by +Date.beginning_of_week+ or +config.beginning_of_week+
    # when set.
    #
    #   today = Date.today       # => Thu, 07 May 2015
    #   today.next_week(:friday) # => Fri, 15 May 2015
    #
    # +DateTime+ objects have their time set to 0:00 unless +same_time+ is true.
    #
    #   now = DateTime.current # => Thu, 07 May 2015 13:31:16 +0000
    #   now.next_week      # => Mon, 11 May 2015 00:00:00 +0000
    def next_week: (?untyped given_day_in_next_week, ?same_time: bool same_time) -> untyped

    # Returns a new date/time representing the next weekday.
    def next_weekday: () -> untyped

    # Short-hand for months_since(3)
    def next_quarter: () -> untyped

    # Returns a new date/time representing the given day in the previous week.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # DateTime objects have their time set to 0:00 unless +same_time+ is true.
    def prev_week: (?untyped start_day, ?same_time: bool same_time) -> untyped

    alias last_week prev_week

    # Returns a new date/time representing the previous weekday.
    def prev_weekday: () -> untyped

    alias last_weekday prev_weekday

    # Short-hand for months_ago(1).
    def last_month: () -> untyped

    # Short-hand for months_ago(3).
    def prev_quarter: () -> untyped

    alias last_quarter prev_quarter

    # Short-hand for years_ago(1).
    def last_year: () -> untyped

    # Returns the number of days to the start of the week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    def days_to_week_start: (?untyped start_day) -> untyped

    # Returns a new date/time representing the start of this week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # +DateTime+ objects have their time set to 0:00.
    def beginning_of_week: (?untyped start_day) -> untyped

    alias at_beginning_of_week beginning_of_week

    # Returns Monday of this week assuming that week starts on Monday.
    # +DateTime+ objects have their time set to 0:00.
    def monday: () -> untyped

    # Returns a new date/time representing the end of this week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # DateTime objects have their time set to 23:59:59.
    def end_of_week: (?untyped start_day) -> untyped

    alias at_end_of_week end_of_week

    # Returns Sunday of this week assuming that week starts on Monday.
    # +DateTime+ objects have their time set to 23:59:59.
    def sunday: () -> untyped

    # Returns a new date/time representing the end of the month.
    # DateTime objects will have a time set to 23:59:59.
    def end_of_month: () -> untyped

    alias at_end_of_month end_of_month

    # Returns a new date/time representing the end of the year.
    # DateTime objects will have a time set to 23:59:59.
    def end_of_year: () -> untyped

    alias at_end_of_year end_of_year

    # Returns a Range representing the whole day of the current date/time.
    def all_day: () -> ::Range[untyped]

    # Returns a Range representing the whole week of the current date/time.
    # Week starts on start_day, default is <tt>Date.beginning_of_week</tt> or <tt>config.beginning_of_week</tt> when set.
    def all_week: (?untyped start_day) -> ::Range[untyped]

    # Returns a Range representing the whole month of the current date/time.
    def all_month: () -> ::Range[untyped]

    # Returns a Range representing the whole quarter of the current date/time.
    def all_quarter: () -> ::Range[untyped]

    # Returns a Range representing the whole year of the current date/time.
    def all_year: () -> ::Range[untyped]

    # Returns a new date/time representing the next occurrence of the specified day of week.
    #
    #   today = Date.today               # => Thu, 14 Dec 2017
    #   today.next_occurring(:monday)    # => Mon, 18 Dec 2017
    #   today.next_occurring(:thursday)  # => Thu, 21 Dec 2017
    def next_occurring: (untyped day_of_week) -> untyped

    # Returns a new date/time representing the previous occurrence of the specified day of week.
    #
    #   today = Date.today               # => Thu, 14 Dec 2017
    #   today.prev_occurring(:monday)    # => Mon, 11 Dec 2017
    #   today.prev_occurring(:thursday)  # => Thu, 07 Dec 2017
    def prev_occurring: (untyped day_of_week) -> untyped

    private

    def first_hour: (untyped date_or_time) -> untyped

    def last_hour: (untyped date_or_time) -> untyped

    def days_span: (untyped day) -> untyped

    def copy_time_to: (untyped other) -> untyped
  end
end

module DateAndTime
  module Compatibility
  end
end

module DateAndTime
  module Zones
    # Returns the simultaneous time in <tt>Time.zone</tt> if a zone is given or
    # if Time.zone_default is set. Otherwise, it returns the current time.
    #
    #   Time.zone = 'Hawaii'        # => 'Hawaii'
    #   Time.utc(2000).in_time_zone # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #   Date.new(2000).in_time_zone # => Sat, 01 Jan 2000 00:00:00 HST -10:00
    #
    # This method is similar to Time#localtime, except that it uses <tt>Time.zone</tt> as the local zone
    # instead of the operating system's time zone.
    #
    # You can also pass in a TimeZone instance or string that identifies a TimeZone as an argument,
    # and the conversion will be based on that zone instead of <tt>Time.zone</tt>.
    #
    #   Time.utc(2000).in_time_zone('Alaska') # => Fri, 31 Dec 1999 15:00:00 AKST -09:00
    #   Date.new(2000).in_time_zone('Alaska') # => Sat, 01 Jan 2000 00:00:00 AKST -09:00
    def in_time_zone: (?(ActiveSupport::TimeZone | String) zone) -> ::ActiveSupport::TimeWithZone
                    | (false? zone) -> ::Time

    private

    def time_with_zone: (untyped time, untyped zone) -> untyped
  end
end

class DateTime
  # Duck-types as a Date-like class. See Object#acts_like?.
  def acts_like_date?: () -> ::TrueClass

  # Duck-types as a Time-like class. See Object#acts_like?.
  def acts_like_time?: () -> ::TrueClass
end

class DateTime
  # nodoc:
  # No DateTime is ever blank:
  #
  #   DateTime.now.blank? # => false
  #
  # @return [false]
  def blank?: () -> ::FalseClass
end

class DateTime
  # Returns <tt>Time.zone.now.to_datetime</tt> when <tt>Time.zone</tt> or
  # <tt>config.time_zone</tt> are set, otherwise returns
  # <tt>Time.now.to_datetime</tt>.
  def self.current: () -> untyped

  # Returns the number of seconds since 00:00:00.
  #
  #   DateTime.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0
  #   DateTime.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296
  #   DateTime.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399
  def seconds_since_midnight: () -> untyped

  # Returns the number of seconds until 23:59:59.
  #
  #   DateTime.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399
  #   DateTime.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103
  #   DateTime.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0
  def seconds_until_end_of_day: () -> untyped

  # Returns the fraction of a second as a +Rational+
  #
  #   DateTime.new(2012, 8, 29, 0, 0, 0.5).subsec # => (1/2)
  def subsec: () -> untyped

  # Returns a new DateTime where one or more of the elements have been changed
  # according to the +options+ parameter. The time options (<tt>:hour</tt>,
  # <tt>:min</tt>, <tt>:sec</tt>) reset cascadingly, so if only the hour is
  # passed, then minute and sec is set to 0. If the hour and minute is passed,
  # then sec is set to 0. The +options+ parameter takes a hash with any of these
  # keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>,
  # <tt>:min</tt>, <tt>:sec</tt>, <tt>:offset</tt>, <tt>:start</tt>.
  #
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => DateTime.new(2012, 8, 1, 22, 35, 0)
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => DateTime.new(1981, 8, 1, 22, 35, 0)
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => DateTime.new(1981, 8, 29, 0, 0, 0)
  def change: (untyped options) -> untyped

  # Uses Date to provide precise Time calculations for years, months, and days.
  # The +options+ parameter takes a hash with any of these keys: <tt>:years</tt>,
  # <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>,
  # <tt>:minutes</tt>, <tt>:seconds</tt>.
  def advance: (untyped options) -> untyped

  # Returns a new DateTime representing the time a number of seconds ago.
  # Do not use this method in combination with x.months, use months_ago instead!
  def ago: (untyped seconds) -> untyped

  # Returns a new DateTime representing the time a number of seconds since the
  # instance time. Do not use this method in combination with x.months, use
  # months_since instead!
  def since: (untyped seconds) -> untyped

  alias in since

  # Returns a new DateTime representing the start of the day (0:00).
  def beginning_of_day: () -> untyped

  alias midnight beginning_of_day

  alias at_midnight beginning_of_day

  alias at_beginning_of_day beginning_of_day

  # Returns a new DateTime representing the middle of the day (12:00)
  def middle_of_day: () -> untyped

  alias midday middle_of_day

  alias noon middle_of_day

  alias at_midday middle_of_day

  alias at_noon middle_of_day

  alias at_middle_of_day middle_of_day

  # Returns a new DateTime representing the end of the day (23:59:59).
  def end_of_day: () -> untyped

  alias at_end_of_day end_of_day

  # Returns a new DateTime representing the start of the hour (hh:00:00).
  def beginning_of_hour: () -> untyped

  alias at_beginning_of_hour beginning_of_hour

  # Returns a new DateTime representing the end of the hour (hh:59:59).
  def end_of_hour: () -> untyped

  alias at_end_of_hour end_of_hour

  # Returns a new DateTime representing the start of the minute (hh:mm:00).
  def beginning_of_minute: () -> untyped

  alias at_beginning_of_minute beginning_of_minute

  # Returns a new DateTime representing the end of the minute (hh:mm:59).
  def end_of_minute: () -> untyped

  alias at_end_of_minute end_of_minute

  # Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.
  def localtime: (?untyped? utc_offset) -> untyped

  alias getlocal localtime

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))     # => Mon, 21 Feb 2005 10:11:12 -0600
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc # => Mon, 21 Feb 2005 16:11:12 UTC
  def utc: () -> untyped

  alias getgm utc

  alias getutc utc

  alias gmtime utc

  # Returns +true+ if <tt>offset == 0</tt>.
  def utc?: () -> untyped

  # Returns the offset value in seconds.
  def utc_offset: () -> untyped

  # Layers additional behavior on DateTime#<=> so that Time and
  # ActiveSupport::TimeWithZone instances can be compared with a DateTime.
  def <=>: (untyped other) -> untyped
end

class DateTime
  include DateAndTime::Compatibility
end

class DateTime
  # Convert to a formatted string. See Time::DATE_FORMATS for predefined formats.
  #
  # This method is aliased to <tt>to_s</tt>.
  #
  # === Examples
  #   datetime = DateTime.civil(2007, 12, 4, 0, 0, 0, 0)   # => Tue, 04 Dec 2007 00:00:00 +0000
  #
  #   datetime.to_formatted_s(:db)            # => "2007-12-04 00:00:00"
  #   datetime.to_s(:db)                      # => "2007-12-04 00:00:00"
  #   datetime.to_s(:number)                  # => "20071204000000"
  #   datetime.to_formatted_s(:short)         # => "04 Dec 00:00"
  #   datetime.to_formatted_s(:long)          # => "December 04, 2007 00:00"
  #   datetime.to_formatted_s(:long_ordinal)  # => "December 4th, 2007 00:00"
  #   datetime.to_formatted_s(:rfc822)        # => "Tue, 04 Dec 2007 00:00:00 +0000"
  #   datetime.to_formatted_s(:iso8601)       # => "2007-12-04T00:00:00+00:00"
  #
  # == Adding your own datetime formats to to_formatted_s
  # DateTime formats are shared with Time. You can add your own to the
  # Time::DATE_FORMATS hash. Use the format name as the hash key and
  # either a strftime string or Proc instance that takes a time or
  # datetime argument as the value.
  #
  #   # config/initializers/time_formats.rb
  #   Time::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Time::DATE_FORMATS[:short_ordinal] = lambda { |time| time.strftime("%B #{time.day.ordinalize}") }
  def to_formatted_s: (?::Symbol format) -> untyped

  alias to_default_s to_s

  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   datetime = DateTime.civil(2000, 1, 1, 0, 0, 0, Rational(-6, 24))
  #   datetime.formatted_offset         # => "-06:00"
  #   datetime.formatted_offset(false)  # => "-0600"
  def formatted_offset: (?bool colon, ?untyped? alternate_utc_string) -> untyped

  # Overrides the default inspect method with a human readable one, e.g., "Mon, 21 Feb 2005 14:30:00 +0000".
  def readable_inspect: () -> untyped

  # Returns DateTime with local offset for given year if format is local else
  # offset is zero.
  #
  #   DateTime.civil_from_format :local, 2012
  #   # => Sun, 01 Jan 2012 00:00:00 +0300
  #   DateTime.civil_from_format :local, 2012, 12, 17
  #   # => Mon, 17 Dec 2012 00:00:00 +0000
  def self.civil_from_format: (untyped utc_or_local, untyped year, ?::Integer month, ?::Integer day, ?::Integer hour, ?::Integer min, ?::Integer sec) -> untyped

  # Converts +self+ to a floating-point number of seconds, including fractional microseconds, since the Unix epoch.
  def to_f: () -> untyped

  # Converts +self+ to an integer number of seconds since the Unix epoch.
  def to_i: () -> untyped

  # Returns the fraction of a second as microseconds
  def usec: () -> untyped

  # Returns the fraction of a second as nanoseconds
  def nsec: () -> untyped

  private

  def offset_in_seconds: () -> untyped

  def seconds_since_unix_epoch: () -> untyped
end

module Digest
  module UUID
    DNS_NAMESPACE: ::String

    URL_NAMESPACE: ::String

    OID_NAMESPACE: ::String

    X500_NAMESPACE: ::String

    # Generates a v5 non-random UUID (Universally Unique IDentifier).
    #
    # Using Digest::MD5 generates version 3 UUIDs; Digest::SHA1 generates version 5 UUIDs.
    # uuid_from_hash always generates the same UUID for a given name and namespace combination.
    #
    # See RFC 4122 for details of UUID at: https://www.ietf.org/rfc/rfc4122.txt
    def self.uuid_from_hash: (untyped hash_class, untyped uuid_namespace, untyped name) -> untyped

    # Convenience method for uuid_from_hash using Digest::MD5.
    def self.uuid_v3: (untyped uuid_namespace, untyped name) -> untyped

    # Convenience method for uuid_from_hash using Digest::SHA1.
    def self.uuid_v5: (untyped uuid_namespace, untyped name) -> untyped

    # Convenience method for SecureRandom.uuid.
    def self.uuid_v4: () -> untyped
  end
end

module Enumerable[unchecked out Elem]
  INDEX_WITH_DEFAULT: untyped

  # We can't use Refinements here because Refinements with Module which will be prepended
  # doesn't work well https://bugs.ruby-lang.org/issues/13446
  alias _original_sum_with_required_identity sum

  # Convert an enumerable to a hash keying it by the block return value.
  #
  #   people.index_by(&:login)
  #   # => { "nextangle" => <Person ...>, "chade-" => <Person ...>, ...}
  #
  #   people.index_by { |person| "#{person.first_name} #{person.last_name}" }
  #   # => { "Chade- Fowlersburg-e" => <Person ...>, "David Heinemeier Hansson" => <Person ...>, ...}
  def index_by: () { (untyped) -> untyped } -> untyped

  # Convert an enumerable to a hash keying it with the enumerable items and with the values returned in the block.
  #
  #   post = Post.new(title: "hey there", body: "what's up?")
  #
  #   %i( title body ).index_with { |attr_name| post.public_send(attr_name) }
  #   # => { title: "hey there", body: "what's up?" }
  def index_with: (?untyped default) { (untyped) -> untyped } -> untyped

  # Returns +true+ if the enumerable has more than 1 element. Functionally
  # equivalent to <tt>enum.to_a.size > 1</tt>. Can be called with a block too,
  # much like any?, so <tt>people.many? { |p| p.age > 26 }</tt> returns +true+
  # if more than one person is over 26.
  def many?: () { (untyped) -> untyped } -> untyped

  # Returns a new array that includes the passed elements.
  #
  #   [ 1, 2, 3 ].including(4, 5)
  #   # => [ 1, 2, 3, 4, 5 ]
  #
  #   ["David", "Rafael"].including %w[ Aaron Todd ]
  #   # => ["David", "Rafael", "Aaron", "Todd"]
  def including: (*untyped elements) -> untyped

  # The negative of the <tt>Enumerable#include?</tt>. Returns +true+ if the
  # collection does not include the object.
  def exclude?: (untyped object) -> untyped

  # Returns a copy of the enumerable excluding the specified elements.
  #
  #   ["David", "Rafael", "Aaron", "Todd"].excluding "Aaron", "Todd"
  #   # => ["David", "Rafael"]
  #
  #   ["David", "Rafael", "Aaron", "Todd"].excluding %w[ Aaron Todd ]
  #   # => ["David", "Rafael"]
  #
  #   {foo: 1, bar: 2, baz: 3}.excluding :bar
  #   # => {foo: 1, baz: 3}
  def excluding: (*untyped elements) -> untyped

  # Alias for #excluding.
  def without: (*untyped elements) -> untyped

  # Convert an enumerable to an array based on the given key.
  #
  #   [{ name: "David" }, { name: "Rafael" }, { name: "Aaron" }].pluck(:name)
  #   # => ["David", "Rafael", "Aaron"]
  #
  #   [{ id: 1, name: "David" }, { id: 2, name: "Rafael" }].pluck(:id, :name)
  #   # => [[1, "David"], [2, "Rafael"]]
  def pluck: (*untyped keys) -> untyped
end

class Range[out Elem]
  # nodoc:
  # Optimize range sum to use arithmetic progression if a block is not given and
  # we have a range of numeric values.
  def sum: (?untyped? identity) -> untyped
end

class Array[unchecked out Elem]
end

class File
  # Write to a file atomically. Useful for situations where you don't
  # want other processes or threads to see half-written files.
  #
  #   File.atomic_write('important.file') do |file|
  #     file.write('hello')
  #   end
  #
  # This method needs to create a temporary file. By default it will create it
  # in the same directory as the destination file. If you don't like this
  # behavior you can provide a different directory but it must be on the
  # same physical filesystem as the file you're trying to write.
  #
  #   File.atomic_write('/data/something.important', '/data/tmp') do |file|
  #     file.write('hello')
  #   end
  def self.atomic_write: (untyped file_name, ?untyped temp_dir) { (untyped) -> untyped } -> untyped

  def self.probe_stat_in: (untyped dir) -> untyped
end

class Hash[unchecked out K, unchecked out V]
  # Returns a string containing an XML representation of its receiver:
  #
  #   { foo: 1, bar: 2 }.to_xml
  #   # =>
  #   # <?xml version="1.0" encoding="UTF-8"?>
  #   # <hash>
  #   #   <foo type="integer">1</foo>
  #   #   <bar type="integer">2</bar>
  #   # </hash>
  #
  # To do so, the method loops over the pairs and builds nodes that depend on
  # the _values_. Given a pair +key+, +value+:
  #
  # * If +value+ is a hash there's a recursive call with +key+ as <tt>:root</tt>.
  #
  # * If +value+ is an array there's a recursive call with +key+ as <tt>:root</tt>,
  #   and +key+ singularized as <tt>:children</tt>.
  #
  # * If +value+ is a callable object it must expect one or two arguments. Depending
  #   on the arity, the callable is invoked with the +options+ hash as first argument
  #   with +key+ as <tt>:root</tt>, and +key+ singularized as second argument. The
  #   callable can add nodes by using <tt>options[:builder]</tt>.
  #
  #     {foo: lambda { |options, key| options[:builder].b(key) }}.to_xml
  #     # => "<b>foo</b>"
  #
  # * If +value+ responds to +to_xml+ the method is invoked with +key+ as <tt>:root</tt>.
  #
  #     class Foo
  #       def to_xml(options)
  #         options[:builder].bar 'fooing!'
  #       end
  #     end
  #
  #     { foo: Foo.new }.to_xml(skip_instruct: true)
  #     # =>
  #     # <hash>
  #     #   <bar>fooing!</bar>
  #     # </hash>
  #
  # * Otherwise, a node with +key+ as tag is created with a string representation of
  #   +value+ as text node. If +value+ is +nil+ an attribute "nil" set to "true" is added.
  #   Unless the option <tt>:skip_types</tt> exists and is true, an attribute "type" is
  #   added as well according to the following mapping:
  #
  #     XML_TYPE_NAMES = {
  #       "Symbol"     => "symbol",
  #       "Integer"    => "integer",
  #       "BigDecimal" => "decimal",
  #       "Float"      => "float",
  #       "TrueClass"  => "boolean",
  #       "FalseClass" => "boolean",
  #       "Date"       => "date",
  #       "DateTime"   => "dateTime",
  #       "Time"       => "dateTime"
  #     }
  #
  # By default the root node is "hash", but that's configurable via the <tt>:root</tt> option.
  #
  # The default XML builder is a fresh instance of <tt>Builder::XmlMarkup</tt>. You can
  # configure your own builder with the <tt>:builder</tt> option. The method also accepts
  # options like <tt>:dasherize</tt> and friends, they are forwarded to the builder.
  def to_xml: (?::Hash[untyped, untyped] options) { (untyped) -> untyped } -> untyped

  # Returns a Hash containing a collection of pairs when the key is the node name and the value is
  # its content
  #
  #   xml = <<-XML
  #     <?xml version="1.0" encoding="UTF-8"?>
  #       <hash>
  #         <foo type="integer">1</foo>
  #         <bar type="integer">2</bar>
  #       </hash>
  #   XML
  #
  #   hash = Hash.from_xml(xml)
  #   # => {"hash"=>{"foo"=>1, "bar"=>2}}
  #
  # +DisallowedType+ is raised if the XML contains attributes with <tt>type="yaml"</tt> or
  # <tt>type="symbol"</tt>. Use <tt>Hash.from_trusted_xml</tt> to
  # parse this XML.
  #
  # Custom +disallowed_types+ can also be passed in the form of an
  # array.
  #
  #   xml = <<-XML
  #     <?xml version="1.0" encoding="UTF-8"?>
  #       <hash>
  #         <foo type="integer">1</foo>
  #         <bar type="string">"David"</bar>
  #       </hash>
  #   XML
  #
  #   hash = Hash.from_xml(xml, ['integer'])
  #   # => ActiveSupport::XMLConverter::DisallowedType: Disallowed type attribute: "integer"
  #
  # Note that passing custom disallowed types will override the default types,
  # which are Symbol and YAML.
  def self.from_xml: (untyped xml, ?untyped? disallowed_types) -> untyped

  # Builds a Hash from XML just like <tt>Hash.from_xml</tt>, but also allows Symbol and YAML.
  def self.from_trusted_xml: (untyped xml) -> untyped
end

module ActiveSupport
  class XMLConverter
    # :nodoc:
    # Raised if the XML contains attributes with type="yaml" or
    # type="symbol". Read Hash#from_xml for more details.
    class DisallowedType < StandardError
      def initialize: (untyped `type`) -> untyped
    end

    DISALLOWED_TYPES: ::Array[untyped]

    def initialize: (untyped xml, ?untyped? disallowed_types) -> untyped

    def to_h: () -> untyped

    private

    def normalize_keys: (untyped params) -> untyped

    def deep_to_h: (untyped value) -> untyped

    def process_hash: (untyped value) -> untyped

    def become_content?: (untyped value) -> untyped

    def become_array?: (untyped value) -> untyped

    def become_empty_string?: (untyped value) -> untyped

    def become_hash?: (untyped value) -> untyped

    def nothing?: (untyped value) -> untyped

    def garbage?: (untyped value) -> untyped

    def process_content: (untyped value) -> untyped

    def process_array: (untyped value) -> untyped
  end
end

class Hash[unchecked out K, unchecked out V]
  # Returns a new hash with +self+ and +other_hash+ merged recursively.
  #
  #   h1 = { a: true, b: { c: [1, 2, 3] } }
  #   h2 = { a: false, b: { x: [3, 4, 5] } }
  #
  #   h1.deep_merge(h2) # => { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }
  #
  # Like with Hash#merge in the standard library, a block can be provided
  # to merge values:
  #
  #   h1 = { a: 100, b: 200, c: { c1: 100 } }
  #   h2 = { b: 250, c: { c1: 200 } }
  #   h1.deep_merge(h2) { |key, this_val, other_val| this_val + other_val }
  #   # => { a: 100, b: 450, c: { c1: 300 } }
  def deep_merge: (untyped other_hash) { () -> untyped } -> untyped

  # Same as +deep_merge+, but modifies +self+.
  def deep_merge!: (untyped other_hash) { () -> untyped } -> untyped
end

class Hash[unchecked out K, unchecked out V]
  # Returns a new hash with all values converted by the block operation.
  # This includes the values from the root hash and from all
  # nested hashes and arrays.
  #
  #  hash = { person: { name: 'Rob', age: '28' } }
  #
  #  hash.deep_transform_values{ |value| value.to_s.upcase }
  #  # => {person: {name: "ROB", age: "28"}}
  def deep_transform_values: () { () -> untyped } -> untyped

  # Destructively converts all values by using the block operation.
  # This includes the values from the root hash and from all
  # nested hashes and arrays.
  def deep_transform_values!: () { () -> untyped } -> untyped

  private

  # support methods for deep transforming nested hashes and arrays
  def _deep_transform_values_in_object: (untyped object) { (untyped) -> untyped } -> untyped

  def _deep_transform_values_in_object!: (untyped object) { (untyped) -> untyped } -> untyped
end

class Hash[unchecked out K, unchecked out V]
  # NOTE: Hash#except has been added since Ruby 3.0
  #
  # Returns a hash that includes everything except given keys.
  #   hash = { a: true, b: false, c: nil }
  #   hash.except(:c)     # => { a: true, b: false }
  #   hash.except(:a, :b) # => { c: nil }
  #   hash                # => { a: true, b: false, c: nil }
  #
  # This is useful for limiting a set of parameters to everything but a few known toggles:
  #   @person.update(params[:person].except(:admin))
  # def except: (*untyped keys) -> untyped

  # Removes the given keys from hash and returns it.
  #   hash = { a: true, b: false, c: nil }
  #   hash.except!(:c) # => { a: true, b: false }
  #   hash             # => { a: true, b: false }
  def except!: (*untyped keys) -> untyped
end

class Hash[unchecked out K, unchecked out V]
  # Returns an <tt>ActiveSupport::HashWithIndifferentAccess</tt> out of its receiver:
  #
  #   { a: 1 }.with_indifferent_access['a'] # => 1
  def with_indifferent_access: () -> ActiveSupport::HashWithIndifferentAccess[K, V]

  # Called when object is nested under an object that receives
  # #with_indifferent_access. This method will be called on the current object
  # by the enclosing object and is aliased to #with_indifferent_access by
  # default. Subclasses of Hash may overwrite this method to return +self+ if
  # converting to an <tt>ActiveSupport::HashWithIndifferentAccess</tt> would not be
  # desirable.
  #
  #   b = { b: 1 }
  #   { a: b }.with_indifferent_access['a'] # calls b.nested_under_indifferent_access
  #   # => {"b"=>1}
  alias nested_under_indifferent_access with_indifferent_access
end

class Hash[unchecked out K, unchecked out V]
  # Validates all keys in a hash match <tt>*valid_keys</tt>, raising
  # +ArgumentError+ on a mismatch.
  #
  # Note that keys are treated differently than HashWithIndifferentAccess,
  # meaning that string and symbol keys will not match.
  #
  #   { name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # => raises "ArgumentError: Unknown key: :years. Valid keys are: :name, :age"
  #   { name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # => raises "ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'"
  #   { name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # => passes, raises nothing
  def assert_valid_keys: (*untyped valid_keys) -> untyped

  # Returns a new hash with all keys converted by the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #  hash = { person: { name: 'Rob', age: '28' } }
  #
  #  hash.deep_transform_keys{ |key| key.to_s.upcase }
  #  # => {"PERSON"=>{"NAME"=>"Rob", "AGE"=>"28"}}
  def deep_transform_keys: () { () -> untyped } -> untyped

  # Destructively converts all keys by using the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  def deep_transform_keys!: () { () -> untyped } -> untyped

  private

  # support methods for deep transforming nested hashes and arrays
  def _deep_transform_keys_in_object: (untyped object) { (untyped) -> untyped } -> untyped

  def _deep_transform_keys_in_object!: (untyped object) { (untyped) -> untyped } -> untyped
end

class Hash[unchecked out K, unchecked out V]
  # Merges the caller into +other_hash+. For example,
  #
  #   options = options.reverse_merge(size: 25, velocity: 10)
  #
  # is equivalent to
  #
  #   options = { size: 25, velocity: 10 }.merge(options)
  #
  # This is particularly useful for initializing an options hash
  # with default values.
  def reverse_merge: (untyped other_hash) -> untyped

  alias with_defaults reverse_merge

  # Destructive +reverse_merge+.
  def reverse_merge!: (untyped other_hash) -> untyped

  alias reverse_update reverse_merge!

  alias with_defaults! reverse_merge!
end

class Hash[unchecked out K, unchecked out V]
  # Replaces the hash with only the given keys.
  # Returns a hash containing the removed key/value pairs.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.slice!(:a, :b)  # => {:c=>3, :d=>4}
  #   hash                 # => {:a=>1, :b=>2}
  def slice!: (*untyped keys) -> untyped

  # Removes and returns the key/value pairs matching the given keys.
  #
  #   { a: 1, b: 2, c: 3, d: 4 }.extract!(:a, :b) # => {:a=>1, :b=>2}
  #   { a: 1, b: 2 }.extract!(:a, :x)             # => {:a=>1}
  def extract!: (*untyped keys) -> untyped
end

class Integer
  # Ordinalize turns a number into an ordinal string used to denote the
  # position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
  #
  #  1.ordinalize     # => "1st"
  #  2.ordinalize     # => "2nd"
  #  1002.ordinalize  # => "1002nd"
  #  1003.ordinalize  # => "1003rd"
  #  -11.ordinalize   # => "-11th"
  #  -1001.ordinalize # => "-1001st"
  def ordinalize: () -> untyped

  # Ordinal returns the suffix used to denote the position
  # in an ordered sequence such as 1st, 2nd, 3rd, 4th.
  #
  #  1.ordinal     # => "st"
  #  2.ordinal     # => "nd"
  #  1002.ordinal  # => "nd"
  #  1003.ordinal  # => "rd"
  #  -11.ordinal   # => "th"
  #  -1001.ordinal # => "st"
  def ordinal: () -> untyped
end

class Integer
  # Check whether the integer is evenly divisible by the argument.
  #
  #   0.multiple_of?(0)  # => true
  #   6.multiple_of?(5)  # => false
  #   10.multiple_of?(2) # => true
  def multiple_of?: (untyped number) -> untyped
end

class Integer
  # Returns a Duration instance matching the number of months provided.
  #
  #   2.months # => 2 months
  def months: () -> ::ActiveSupport::Duration

  alias month months

  # Returns a Duration instance matching the number of years provided.
  #
  #   2.years # => 2 years
  def years: () -> ::ActiveSupport::Duration

  alias year years
end

module Kernel
  # A shortcut to define a toplevel concern, not within a module.
  #
  # See Module::Concerning for more.
  def self?.concern: (untyped topic) { () -> untyped } -> untyped
end

module Kernel
  # Sets $VERBOSE to +nil+ for the duration of the block and back to its original
  # value afterwards.
  #
  #   silence_warnings do
  #     value = noisy_call # no warning voiced
  #   end
  #
  #   noisy_call # warning voiced
  def self?.silence_warnings: () { () -> untyped } -> untyped

  # Sets $VERBOSE to +true+ for the duration of the block and back to its
  # original value afterwards.
  def self?.enable_warnings: () { () -> untyped } -> untyped

  # Sets $VERBOSE for the duration of the block and back to its original
  # value afterwards.
  def self?.with_warnings: (untyped flag) { () -> untyped } -> untyped

  # Blocks and ignores any exception passed as argument if raised within the block.
  #
  #   suppress(ZeroDivisionError) do
  #     1/0
  #     puts 'This code is NOT reached'
  #   end
  #
  #   puts 'This code gets executed and nothing related to ZeroDivisionError was seen'
  def self?.suppress: (*untyped exception_classes) { () -> untyped } -> untyped
end

module Kernel
  # class_eval on an object acts like singleton_class.class_eval.
  def class_eval: (*untyped args) { () -> untyped } -> untyped
end

class LoadError
  # Returns true if the given path name (except perhaps for the ".rb"
  # extension) is the missing file which caused the exception to be raised.
  def is_missing?: (untyped location) -> untyped
end

module ActiveSupport
  module MarshalWithAutoloading
    # :nodoc:
    def load: (untyped source, ?untyped? proc) -> untyped
  end
end

class Module
  # Allows you to make aliases for attributes, which includes
  # getter, setter, and a predicate.
  #
  #   class Content < ActiveRecord::Base
  #     # has a title attribute
  #   end
  #
  #   class Email < Content
  #     alias_attribute :subject, :title
  #   end
  #
  #   e = Email.find(1)
  #   e.title    # => "Superstars"
  #   e.subject  # => "Superstars"
  #   e.subject? # => true
  #   e.subject = "Megastars"
  #   e.title    # => "Megastars"
  def alias_attribute: (untyped new_name, untyped old_name) -> untyped
end

class Module
  # A module may or may not have a name.
  #
  #   module M; end
  #   M.name # => "M"
  #
  #   m = Module.new
  #   m.name # => nil
  #
  # +anonymous?+ method returns true if module does not have a name, false otherwise:
  #
  #   Module.new.anonymous? # => true
  #
  #   module M; end
  #   M.anonymous?          # => false
  #
  # A module gets a name when it is first assigned to a constant. Either
  # via the +module+ or +class+ keyword or by an explicit assignment:
  #
  #   m = Module.new # creates an anonymous module
  #   m.anonymous?   # => true
  #   M = m          # m gets a name here as a side-effect
  #   m.name         # => "M"
  #   m.anonymous?   # => false
  def anonymous?: () -> untyped
end

class Module
  # Declares an attribute reader backed by an internally-named instance variable.
  def attr_internal_reader: (*untyped attrs) -> untyped

  # Declares an attribute writer backed by an internally-named instance variable.
  def attr_internal_writer: (*untyped attrs) -> untyped

  # Declares an attribute reader and writer backed by an internally-named instance
  # variable.
  def attr_internal_accessor: (*untyped attrs) -> untyped

  alias attr_internal attr_internal_accessor

  attr_accessor self.attr_internal_naming_format: untyped

  private

  def attr_internal_ivar_name: (untyped attr) -> untyped

  def attr_internal_define: (untyped attr_name, untyped `type`) -> untyped
end

# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes.
class Module
  # Defines a class attribute and creates a class and instance reader methods.
  # The underlying class variable is set to +nil+, if it is not previously
  # defined. All class and instance methods created will be public, even if
  # this method is called with a private or protected access modifier.
  #
  #   module HairColors
  #     mattr_reader :hair_colors
  #   end
  #
  #   HairColors.hair_colors # => nil
  #   HairColors.class_variable_set("@@hair_colors", [:brown, :black])
  #   HairColors.hair_colors # => [:brown, :black]
  #
  # The attribute name must be a valid method name in Ruby.
  #
  #   module Foo
  #     mattr_reader :"1_Badname"
  #   end
  #   # => NameError: invalid attribute name: 1_Badname
  #
  # To omit the instance reader method, pass
  # <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   module HairColors
  #     mattr_reader :hair_colors, instance_reader: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_reader :hair_colors, default: [:brown, :black, :blonde, :red]
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red]
  def mattr_reader: (*untyped syms, ?default: untyped? default, ?instance_accessor: bool instance_accessor, ?instance_reader: bool instance_reader) { () -> untyped } -> untyped

  alias cattr_reader mattr_reader

  # Defines a class attribute and creates a class and instance writer methods to
  # allow assignment to the attribute. All class and instance methods created
  # will be public, even if this method is called with a private or protected
  # access modifier.
  #
  #   module HairColors
  #     mattr_writer :hair_colors
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   HairColors.hair_colors = [:brown, :black]
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black]
  #   Person.new.hair_colors = [:blonde, :red]
  #   HairColors.class_variable_get("@@hair_colors") # => [:blonde, :red]
  #
  # To omit the instance writer method, pass
  # <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   module HairColors
  #     mattr_writer :hair_colors, instance_writer: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:blonde, :red] # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_writer :hair_colors, default: [:brown, :black, :blonde, :red]
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black, :blonde, :red]
  def mattr_writer: (*untyped syms, ?default: untyped? default, ?instance_accessor: bool instance_accessor, ?instance_writer: bool instance_writer) { () -> untyped } -> untyped

  alias cattr_writer mattr_writer

  # Defines both class and instance accessors for class attributes.
  # All class and instance methods created will be public, even if
  # this method is called with a private or protected access modifier.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   HairColors.hair_colors = [:brown, :black, :blonde, :red]
  #   HairColors.hair_colors # => [:brown, :black, :blonde, :red]
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red]
  #
  # If a subclass changes the value then that would also change the value for
  # parent class. Similarly if parent class changes the value then that would
  # change the value of subclasses too.
  #
  #   class Citizen < Person
  #   end
  #
  #   Citizen.new.hair_colors << :blue
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red, :blue]
  #
  # To omit the instance writer method, pass <tt>instance_writer: false</tt>.
  # To omit the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, instance_writer: false, instance_reader: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:brown]  # => NoMethodError
  #   Person.new.hair_colors             # => NoMethodError
  #
  # Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, instance_accessor: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:brown]  # => NoMethodError
  #   Person.new.hair_colors             # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, default: [:brown, :black, :blonde, :red]
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black, :blonde, :red]
  def mattr_accessor: (*untyped syms, ?default: untyped? default, ?instance_accessor: bool instance_accessor, ?instance_writer: bool instance_writer, ?instance_reader: bool instance_reader) { () -> untyped } -> untyped

  alias cattr_accessor mattr_accessor
end

# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes, but does so on a per-thread basis.
#
# So the values are scoped within the Thread.current space under the class name
# of the module.
class Module
  def thread_mattr_reader: (*untyped syms, ?instance_accessor: bool instance_accessor, ?instance_reader: bool instance_reader) -> untyped

  alias thread_cattr_reader thread_mattr_reader

  def thread_mattr_writer: (*untyped syms, ?instance_accessor: bool instance_accessor, ?instance_writer: bool instance_writer) -> untyped

  alias thread_cattr_writer thread_mattr_writer

  # Defines both class and instance accessors for class attributes.
  #
  #   class Account
  #     thread_mattr_accessor :user
  #   end
  #
  #   Account.user = "DHH"
  #   Account.user     # => "DHH"
  #   Account.new.user # => "DHH"
  #
  # If a subclass changes the value, the parent class' value is not changed.
  # Similarly, if the parent class changes the value, the value of subclasses
  # is not changed.
  #
  #   class Customer < Account
  #   end
  #
  #   Customer.user = "Rafael"
  #   Customer.user # => "Rafael"
  #   Account.user  # => "DHH"
  #
  # To omit the instance writer method, pass <tt>instance_writer: false</tt>.
  # To omit the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   class Current
  #     thread_mattr_accessor :user, instance_writer: false, instance_reader: false
  #   end
  #
  #   Current.new.user = "DHH"  # => NoMethodError
  #   Current.new.user          # => NoMethodError
  #
  # Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.
  #
  #   class Current
  #     thread_mattr_accessor :user, instance_accessor: false
  #   end
  #
  #   Current.new.user = "DHH"  # => NoMethodError
  #   Current.new.user          # => NoMethodError
  def thread_mattr_accessor: (*untyped syms, ?instance_accessor: bool instance_accessor, ?instance_writer: bool instance_writer, ?instance_reader: bool instance_reader) -> untyped

  alias thread_cattr_accessor thread_mattr_accessor
end

class Module
  # = Bite-sized separation of concerns
  #
  # We often find ourselves with a medium-sized chunk of behavior that we'd
  # like to extract, but only mix in to a single class.
  #
  # Extracting a plain old Ruby object to encapsulate it and collaborate or
  # delegate to the original object is often a good choice, but when there's
  # no additional state to encapsulate or we're making DSL-style declarations
  # about the parent class, introducing new collaborators can obfuscate rather
  # than simplify.
  #
  # The typical route is to just dump everything in a monolithic class, perhaps
  # with a comment, as a least-bad alternative. Using modules in separate files
  # means tedious sifting to get a big-picture view.
  #
  # = Dissatisfying ways to separate small concerns
  #
  # == Using comments:
  #
  #   class Todo < ApplicationRecord
  #     # Other todo implementation
  #     # ...
  #
  #     ## Event tracking
  #     has_many :events
  #
  #     before_create :track_creation
  #
  #     private
  #       def track_creation
  #         # ...
  #       end
  #   end
  #
  # == With an inline module:
  #
  # Noisy syntax.
  #
  #   class Todo < ApplicationRecord
  #     # Other todo implementation
  #     # ...
  #
  #     module EventTracking
  #       extend ActiveSupport::Concern
  #
  #       included do
  #         has_many :events
  #         before_create :track_creation
  #       end
  #
  #       private
  #         def track_creation
  #           # ...
  #         end
  #     end
  #     include EventTracking
  #   end
  #
  # == Mix-in noise exiled to its own file:
  #
  # Once our chunk of behavior starts pushing the scroll-to-understand-it
  # boundary, we give in and move it to a separate file. At this size, the
  # increased overhead can be a reasonable tradeoff even if it reduces our
  # at-a-glance perception of how things work.
  #
  #   class Todo < ApplicationRecord
  #     # Other todo implementation
  #     # ...
  #
  #     include TodoEventTracking
  #   end
  #
  # = Introducing Module#concerning
  #
  # By quieting the mix-in noise, we arrive at a natural, low-ceremony way to
  # separate bite-sized concerns.
  #
  #   class Todo < ApplicationRecord
  #     # Other todo implementation
  #     # ...
  #
  #     concerning :EventTracking do
  #       included do
  #         has_many :events
  #         before_create :track_creation
  #       end
  #
  #       private
  #         def track_creation
  #           # ...
  #         end
  #     end
  #   end
  #
  #   Todo.ancestors
  #   # => [Todo, Todo::EventTracking, ApplicationRecord, Object]
  #
  # This small step has some wonderful ripple effects. We can
  # * grok the behavior of our class in one glance,
  # * clean up monolithic junk-drawer classes by separating their concerns, and
  # * stop leaning on protected/private for crude "this is internal stuff" modularity.
  module Concerning
    # Define a new concern and mix it in.
    def concerning: (untyped topic) { () -> untyped } -> untyped

    # A low-cruft shortcut to define a concern.
    #
    #   concern :EventTracking do
    #     ...
    #   end
    #
    # is equivalent to
    #
    #   module EventTracking
    #     extend ActiveSupport::Concern
    #
    #     ...
    #   end
    def concern: (untyped topic) { () -> untyped } -> untyped
  end

  include Concerning
end

class Module
  # Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+
  # option is not used.
  class DelegationError[T] < NoMethodError[T]
  end

  RUBY_RESERVED_KEYWORDS: ::Array[untyped]

  DELEGATION_RESERVED_KEYWORDS: ::Array[untyped]

  DELEGATION_RESERVED_METHOD_NAMES: untyped

  # Provides a +delegate+ class method to easily expose contained objects'
  # public methods as your own.
  #
  # ==== Options
  # * <tt>:to</tt> - Specifies the target object name as a symbol or string
  # * <tt>:prefix</tt> - Prefixes the new method with the target name or a custom prefix
  # * <tt>:allow_nil</tt> - If set to true, prevents a +Module::DelegationError+
  #   from being raised
  # * <tt>:private</tt> - If set to true, changes method visibility to private
  #
  # The macro receives one or more method names (specified as symbols or
  # strings) and the name of the target object via the <tt>:to</tt> option
  # (also a symbol or string).
  #
  # Delegation is particularly useful with Active Record associations:
  #
  #   class Greeter < ActiveRecord::Base
  #     def hello
  #       'hello'
  #     end
  #
  #     def goodbye
  #       'goodbye'
  #     end
  #   end
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, to: :greeter
  #   end
  #
  #   Foo.new.hello   # => "hello"
  #   Foo.new.goodbye # => NoMethodError: undefined method `goodbye' for #<Foo:0x1af30c>
  #
  # Multiple delegates to the same target are allowed:
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, :goodbye, to: :greeter
  #   end
  #
  #   Foo.new.goodbye # => "goodbye"
  #
  # Methods can be delegated to instance variables, class variables, or constants
  # by providing them as a symbols:
  #
  #   class Foo
  #     CONSTANT_ARRAY = [0,1,2,3]
  #     @@class_array  = [4,5,6,7]
  #
  #     def initialize
  #       @instance_array = [8,9,10,11]
  #     end
  #     delegate :sum, to: :CONSTANT_ARRAY
  #     delegate :min, to: :@@class_array
  #     delegate :max, to: :@instance_array
  #   end
  #
  #   Foo.new.sum # => 6
  #   Foo.new.min # => 4
  #   Foo.new.max # => 11
  #
  # It's also possible to delegate a method to the class by using +:class+:
  #
  #   class Foo
  #     def self.hello
  #       "world"
  #     end
  #
  #     delegate :hello, to: :class
  #   end
  #
  #   Foo.new.hello # => "world"
  #
  # Delegates can optionally be prefixed using the <tt>:prefix</tt> option. If the value
  # is <tt>true</tt>, the delegate methods are prefixed with the name of the object being
  # delegated to.
  #
  #   Person = Struct.new(:name, :address)
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: true
  #   end
  #
  #   john_doe = Person.new('John Doe', 'Vimmersvej 13')
  #   invoice = Invoice.new(john_doe)
  #   invoice.client_name    # => "John Doe"
  #   invoice.client_address # => "Vimmersvej 13"
  #
  # It is also possible to supply a custom prefix.
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: :customer
  #   end
  #
  #   invoice = Invoice.new(john_doe)
  #   invoice.customer_name    # => 'John Doe'
  #   invoice.customer_address # => 'Vimmersvej 13'
  #
  # The delegated methods are public by default.
  # Pass <tt>private: true</tt> to change that.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :first_name, to: :profile
  #     delegate :date_of_birth, to: :profile, private: true
  #
  #     def age
  #       Date.today.year - date_of_birth.year
  #     end
  #   end
  #
  #   User.new.first_name # => "Tomas"
  #   User.new.date_of_birth # => NoMethodError: private method `date_of_birth' called for #<User:0x00000008221340>
  #   User.new.age # => 2
  #
  # If the target is +nil+ and does not respond to the delegated method a
  # +Module::DelegationError+ is raised. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile
  #   end
  #
  #   User.new.age
  #   # => Module::DelegationError: User#age delegated to profile.age, but profile is nil
  #
  # But if not having a profile yet is fine and should not be an error
  # condition:
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile, allow_nil: true
  #   end
  #
  #   User.new.age # nil
  #
  # Note that if the target is not +nil+ then the call is attempted regardless of the
  # <tt>:allow_nil</tt> option, and thus an exception is still raised if said object
  # does not respond to the method:
  #
  #   class Foo
  #     def initialize(bar)
  #       @bar = bar
  #     end
  #
  #     delegate :name, to: :@bar, allow_nil: true
  #   end
  #
  #   Foo.new("Bar").name # raises NoMethodError: undefined method `name'
  #
  # The target method must be public, otherwise it will raise +NoMethodError+.
  def delegate: (*untyped methods, ?private: untyped? `private`, ?allow_nil: untyped? allow_nil, ?prefix: untyped? prefix, ?to: untyped? to) -> untyped

  # When building decorators, a common pattern may emerge:
  #
  #   class Partition
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #
  #     private
  #       def respond_to_missing?(name, include_private = false)
  #         @event.respond_to?(name, include_private)
  #       end
  #
  #       def method_missing(method, *args, &block)
  #         @event.send(method, *args, &block)
  #       end
  #   end
  #
  # With <tt>Module#delegate_missing_to</tt>, the above is condensed to:
  #
  #   class Partition
  #     delegate_missing_to :@event
  #
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #   end
  #
  # The target can be anything callable within the object, e.g. instance
  # variables, methods, constants, etc.
  #
  # The delegated method must be public on the target, otherwise it will
  # raise +NoMethodError+.
  #
  # The <tt>marshal_dump</tt> and <tt>_dump</tt> methods are exempt from
  # delegation due to possible interference when calling
  # <tt>Marshal.dump(object)</tt>, should the delegation target method
  # of <tt>object</tt> add or remove instance variables.
  def delegate_missing_to: (untyped target) -> untyped
end

class Module
  #   deprecate :foo
  #   deprecate bar: 'message'
  #   deprecate :foo, :bar, baz: 'warning!', qux: 'gone!'
  #
  # You can also use custom deprecator instance:
  #
  #   deprecate :foo, deprecator: MyLib::Deprecator.new
  #   deprecate :foo, bar: "warning!", deprecator: MyLib::Deprecator.new
  #
  # \Custom deprecators must respond to <tt>deprecation_warning(deprecated_method_name, message, caller_backtrace)</tt>
  # method where you can implement your custom warning behavior.
  #
  #   class MyLib::Deprecator
  #     def deprecation_warning(deprecated_method_name, message, caller_backtrace = nil)
  #       message = "#{deprecated_method_name} is deprecated and will be removed from MyLibrary | #{message}"
  #       Kernel.warn message
  #     end
  #   end
  def deprecate: (*untyped method_names) -> untyped
end

class Module
  # Returns the name of the module containing this one.
  #
  #   M::N.module_parent_name # => "M"
  def module_parent_name: () -> untyped

  def parent_name: () -> untyped

  # Returns the module which contains this one according to its name.
  #
  #   module M
  #     module N
  #     end
  #   end
  #   X = M::N
  #
  #   M::N.module_parent # => M
  #   X.module_parent    # => M
  #
  # The parent of top-level and anonymous modules is Object.
  #
  #   M.module_parent          # => Object
  #   Module.new.module_parent # => Object
  def module_parent: () -> untyped

  def parent: () -> untyped

  # Returns all the parents of this module according to its name, ordered from
  # nested outwards. The receiver is not contained within the result.
  #
  #   module M
  #     module N
  #     end
  #   end
  #   X = M::N
  #
  #   M.module_parents    # => [Object]
  #   M::N.module_parents # => [M, Object]
  #   X.module_parents    # => [M, Object]
  def module_parents: () -> untyped

  def parents: () -> untyped
end

class Module
  # Marks the named method as intended to be redefined, if it exists.
  # Suppresses the Ruby method redefinition warning. Prefer
  # #redefine_method where possible.
  def silence_redefinition_of_method: (untyped method) -> untyped

  # Replaces the existing method definition, if there is one, with the passed
  # block as its body.
  def redefine_method: (untyped method) { () -> untyped } -> untyped

  # Replaces the existing singleton method definition, if there is one, with
  # the passed block as its body.
  def redefine_singleton_method: (untyped method) { () -> untyped } -> untyped

  def method_visibility: (untyped method) -> untyped
end

class Module
  # Removes the named method, if it exists.
  def remove_possible_method: (untyped method) -> untyped

  # Removes the named singleton method, if it exists.
  def remove_possible_singleton_method: (untyped method) -> untyped
end

class NameError[T]
  # Extract the name of the missing constant from the exception message.
  #
  #   begin
  #     HelloWorld
  #   rescue NameError => e
  #     e.missing_name
  #   end
  #   # => "HelloWorld"
  def missing_name: () -> untyped

  # Was this exception raised because the given name was missing?
  #
  #   begin
  #     HelloWorld
  #   rescue NameError => e
  #     e.missing_name?("HelloWorld")
  #   end
  #   # => true
  def missing_name?: (untyped name) -> untyped
end

class Numeric
  KILOBYTE: ::Integer

  MEGABYTE: untyped

  GIGABYTE: untyped

  TERABYTE: untyped

  PETABYTE: untyped

  EXABYTE: untyped

  # Enables the use of byte calculations and declarations, like 45.bytes + 2.6.megabytes
  #
  #   2.bytes # => 2
  def bytes: () -> untyped

  alias byte bytes

  # Returns the number of bytes equivalent to the kilobytes provided.
  #
  #   2.kilobytes # => 2048
  def kilobytes: () -> untyped

  alias kilobyte kilobytes

  # Returns the number of bytes equivalent to the megabytes provided.
  #
  #   2.megabytes # => 2_097_152
  def megabytes: () -> untyped

  alias megabyte megabytes

  # Returns the number of bytes equivalent to the gigabytes provided.
  #
  #   2.gigabytes # => 2_147_483_648
  def gigabytes: () -> untyped

  alias gigabyte gigabytes

  # Returns the number of bytes equivalent to the terabytes provided.
  #
  #   2.terabytes # => 2_199_023_255_552
  def terabytes: () -> untyped

  alias terabyte terabytes

  # Returns the number of bytes equivalent to the petabytes provided.
  #
  #   2.petabytes # => 2_251_799_813_685_248
  def petabytes: () -> untyped

  alias petabyte petabytes

  # Returns the number of bytes equivalent to the exabytes provided.
  #
  #   2.exabytes # => 2_305_843_009_213_693_952
  def exabytes: () -> untyped

  alias exabyte exabytes
end

module ActiveSupport
  module NumericWithFormat
    # Provides options for converting numbers into formatted strings.
    # Options are provided for phone numbers, currency, percentage,
    # precision, positional notation, file size and pretty printing.
    #
    # ==== Options
    #
    # For details on which formats use which options, see ActiveSupport::NumberHelper
    #
    # ==== Examples
    #
    #  Phone Numbers:
    #  5551234.to_s(:phone)                                     # => "555-1234"
    #  1235551234.to_s(:phone)                                  # => "123-555-1234"
    #  1235551234.to_s(:phone, area_code: true)                 # => "(123) 555-1234"
    #  1235551234.to_s(:phone, delimiter: ' ')                  # => "123 555 1234"
    #  1235551234.to_s(:phone, area_code: true, extension: 555) # => "(123) 555-1234 x 555"
    #  1235551234.to_s(:phone, country_code: 1)                 # => "+1-123-555-1234"
    #  1235551234.to_s(:phone, country_code: 1, extension: 1343, delimiter: '.')
    #  # => "+1.123.555.1234 x 1343"
    #
    #  Currency:
    #  1234567890.50.to_s(:currency)                 # => "$1,234,567,890.50"
    #  1234567890.506.to_s(:currency)                # => "$1,234,567,890.51"
    #  1234567890.506.to_s(:currency, precision: 3)  # => "$1,234,567,890.506"
    #  1234567890.506.to_s(:currency, locale: :fr)   # => "1 234 567 890,51 (trim non-ascii characters)"
    #  -1234567890.50.to_s(:currency, negative_format: '(%u%n)')
    #  # => "($1,234,567,890.50)"
    #  1234567890.50.to_s(:currency, unit: '&pound;', separator: ',', delimiter: '')
    #  # => "&pound;1234567890,50"
    #  1234567890.50.to_s(:currency, unit: '&pound;', separator: ',', delimiter: '', format: '%n %u')
    #  # => "1234567890,50 &pound;"
    #
    #  Percentage:
    #  100.to_s(:percentage)                                  # => "100.000%"
    #  100.to_s(:percentage, precision: 0)                    # => "100%"
    #  1000.to_s(:percentage, delimiter: '.', separator: ',') # => "1.000,000%"
    #  302.24398923423.to_s(:percentage, precision: 5)        # => "302.24399%"
    #  1000.to_s(:percentage, locale: :fr)                    # => "1 000,000%"
    #  100.to_s(:percentage, format: '%n  %')                 # => "100.000  %"
    #
    #  Delimited:
    #  12345678.to_s(:delimited)                     # => "12,345,678"
    #  12345678.05.to_s(:delimited)                  # => "12,345,678.05"
    #  12345678.to_s(:delimited, delimiter: '.')     # => "12.345.678"
    #  12345678.to_s(:delimited, delimiter: ',')     # => "12,345,678"
    #  12345678.05.to_s(:delimited, separator: ' ')  # => "12,345,678 05"
    #  12345678.05.to_s(:delimited, locale: :fr)     # => "12 345 678,05"
    #  98765432.98.to_s(:delimited, delimiter: ' ', separator: ',')
    #  # => "98 765 432,98"
    #
    #  Rounded:
    #  111.2345.to_s(:rounded)                                      # => "111.235"
    #  111.2345.to_s(:rounded, precision: 2)                        # => "111.23"
    #  13.to_s(:rounded, precision: 5)                              # => "13.00000"
    #  389.32314.to_s(:rounded, precision: 0)                       # => "389"
    #  111.2345.to_s(:rounded, significant: true)                   # => "111"
    #  111.2345.to_s(:rounded, precision: 1, significant: true)     # => "100"
    #  13.to_s(:rounded, precision: 5, significant: true)           # => "13.000"
    #  111.234.to_s(:rounded, locale: :fr)                          # => "111,234"
    #  13.to_s(:rounded, precision: 5, significant: true, strip_insignificant_zeros: true)
    #  # => "13"
    #  389.32314.to_s(:rounded, precision: 4, significant: true)    # => "389.3"
    #  1111.2345.to_s(:rounded, precision: 2, separator: ',', delimiter: '.')
    #  # => "1.111,23"
    #
    #  Human-friendly size in Bytes:
    #  123.to_s(:human_size)                                   # => "123 Bytes"
    #  1234.to_s(:human_size)                                  # => "1.21 KB"
    #  12345.to_s(:human_size)                                 # => "12.1 KB"
    #  1234567.to_s(:human_size)                               # => "1.18 MB"
    #  1234567890.to_s(:human_size)                            # => "1.15 GB"
    #  1234567890123.to_s(:human_size)                         # => "1.12 TB"
    #  1234567890123456.to_s(:human_size)                      # => "1.1 PB"
    #  1234567890123456789.to_s(:human_size)                   # => "1.07 EB"
    #  1234567.to_s(:human_size, precision: 2)                 # => "1.2 MB"
    #  483989.to_s(:human_size, precision: 2)                  # => "470 KB"
    #  1234567.to_s(:human_size, precision: 2, separator: ',') # => "1,2 MB"
    #  1234567890123.to_s(:human_size, precision: 5)           # => "1.1228 TB"
    #  524288000.to_s(:human_size, precision: 5)               # => "500 MB"
    #
    #  Human-friendly format:
    #  123.to_s(:human)                                       # => "123"
    #  1234.to_s(:human)                                      # => "1.23 Thousand"
    #  12345.to_s(:human)                                     # => "12.3 Thousand"
    #  1234567.to_s(:human)                                   # => "1.23 Million"
    #  1234567890.to_s(:human)                                # => "1.23 Billion"
    #  1234567890123.to_s(:human)                             # => "1.23 Trillion"
    #  1234567890123456.to_s(:human)                          # => "1.23 Quadrillion"
    #  1234567890123456789.to_s(:human)                       # => "1230 Quadrillion"
    #  489939.to_s(:human, precision: 2)                      # => "490 Thousand"
    #  489939.to_s(:human, precision: 4)                      # => "489.9 Thousand"
    #  1234567.to_s(:human, precision: 4,
    #                   significant: false)                   # => "1.2346 Million"
    #  1234567.to_s(:human, precision: 1,
    #                   separator: ',',
    #                   significant: false)                   # => "1,2 Million"
    def to_s: (?untyped? format, ?untyped? options) -> untyped
  end
end

class Numeric
  # Returns a Duration instance matching the number of seconds provided.
  #
  #   2.seconds # => 2 seconds
  def seconds: () -> ::ActiveSupport::Duration

  alias second seconds

  # Returns a Duration instance matching the number of minutes provided.
  #
  #   2.minutes # => 2 minutes
  def minutes: () -> ::ActiveSupport::Duration

  alias minute minutes

  # Returns a Duration instance matching the number of hours provided.
  #
  #   2.hours # => 2 hours
  def hours: () -> ::ActiveSupport::Duration

  alias hour hours

  # Returns a Duration instance matching the number of days provided.
  #
  #   2.days # => 2 days
  def days: () -> ::ActiveSupport::Duration

  alias day days

  # Returns a Duration instance matching the number of weeks provided.
  #
  #   2.weeks # => 2 weeks
  def weeks: () -> ::ActiveSupport::Duration

  alias week weeks

  # Returns a Duration instance matching the number of fortnights provided.
  #
  #   2.fortnights # => 4 weeks
  def fortnights: () -> ::ActiveSupport::Duration

  alias fortnight fortnights

  # Returns the number of milliseconds equivalent to the seconds provided.
  # Used with the standard time durations.
  #
  #   2.in_milliseconds # => 2000
  #   1.hour.in_milliseconds # => 3600000
  def in_milliseconds: () -> untyped
end

class Object
  # A duck-type assistant method. For example, Active Support extends Date
  # to define an <tt>acts_like_date?</tt> method, and extends Time to define
  # <tt>acts_like_time?</tt>. As a result, we can do <tt>x.acts_like?(:time)</tt> and
  # <tt>x.acts_like?(:date)</tt> to do duck-type-safe comparisons, since classes that
  # we want to act like Time simply need to define an <tt>acts_like_time?</tt> method.
  def acts_like?: (untyped duck) -> untyped
end

class Object
  # An object is blank if it's false, empty, or a whitespace string.
  # For example, +nil+, '', '   ', [], {}, and +false+ are all blank.
  #
  # This simplifies
  #
  #   !address || address.empty?
  #
  # to
  #
  #   address.blank?
  #
  # @return [true, false]
  def blank?: () -> untyped

  # An object is present if it's not blank.
  #
  # @return [true, false]
  def present?: () -> untyped

  # Returns the receiver if it's present otherwise returns +nil+.
  # <tt>object.presence</tt> is equivalent to
  #
  #    object.present? ? object : nil
  #
  # For example, something like
  #
  #   state   = params[:state]   if params[:state].present?
  #   country = params[:country] if params[:country].present?
  #   region  = state || country || 'US'
  #
  # becomes
  #
  #   region = params[:state].presence || params[:country].presence || 'US'
  #
  # @return [Object]
  def presence: () -> untyped
end

class NilClass
  # +nil+ is blank:
  #
  #   nil.blank? # => true
  #
  # @return [true]
  def blank?: () -> ::TrueClass
end

class FalseClass
  # +false+ is blank:
  #
  #   false.blank? # => true
  #
  # @return [true]
  def blank?: () -> ::TrueClass
end

class TrueClass
  # +true+ is not blank:
  #
  #   true.blank? # => false
  #
  # @return [false]
  def blank?: () -> ::FalseClass
end

class Array[unchecked out Elem]
  # An array is blank if it's empty:
  #
  #   [].blank?      # => true
  #   [1,2,3].blank? # => false
  #
  # @return [true, false]
  alias blank? empty?
end

class Hash[unchecked out K, unchecked out V]
  # A hash is blank if it's empty:
  #
  #   {}.blank?                # => true
  #   { key: 'value' }.blank?  # => false
  #
  # @return [true, false]
  alias blank? empty?
end

class String
  BLANK_RE: untyped

  ENCODED_BLANKS: untyped

  # A string is blank if it's empty or contains whitespaces only:
  #
  #   ''.blank?       # => true
  #   '   '.blank?    # => true
  #   "\t\n\r".blank? # => true
  #   ' blah '.blank? # => false
  #
  # Unicode whitespace is supported:
  #
  #   "\u00a0".blank? # => true
  #
  # @return [true, false]
  def blank?: () -> untyped
end

class Numeric
  # nodoc:
  # No number is blank:
  #
  #   1.blank? # => false
  #   0.blank? # => false
  #
  # @return [false]
  def blank?: () -> ::FalseClass
end

class Time
  # nodoc:
  # No Time is blank:
  #
  #   Time.now.blank? # => false
  #
  # @return [false]
  def blank?: () -> ::FalseClass
end

class Object
  # Returns a deep copy of object if it's duplicable. If it's
  # not duplicable, returns +self+.
  #
  #   object = Object.new
  #   dup    = object.deep_dup
  #   dup.instance_variable_set(:@a, 1)
  #
  #   object.instance_variable_defined?(:@a) # => false
  #   dup.instance_variable_defined?(:@a)    # => true
  def deep_dup: () -> untyped
end

class Array[unchecked out Elem]
  # Returns a deep copy of array.
  #
  #   array = [1, [2, 3]]
  #   dup   = array.deep_dup
  #   dup[1][2] = 4
  #
  #   array[1][2] # => nil
  #   dup[1][2]   # => 4
  def deep_dup: () -> untyped
end

class Hash[unchecked out K, unchecked out V]
  # Returns a deep copy of hash.
  #
  #   hash = { a: { b: 'b' } }
  #   dup  = hash.deep_dup
  #   dup[:a][:c] = 'c'
  #
  #   hash[:a][:c] # => nil
  #   dup[:a][:c]  # => "c"
  def deep_dup: () -> untyped
end

# -
# Most objects are cloneable, but not all. For example you can't dup methods:
#
#   method(:puts).dup # => TypeError: allocator undefined for Method
#
# Classes may signal their instances are not duplicable removing +dup+/+clone+
# or raising exceptions from them. So, to dup an arbitrary object you normally
# use an optimistic approach and are ready to catch an exception, say:
#
#   arbitrary_object.dup rescue object
#
# Rails dups objects in a few critical spots where they are not that arbitrary.
# That rescue is very expensive (like 40 times slower than a predicate), and it
# is often triggered.
#
# That's why we hardcode the following cases and check duplicable? instead of
# using that rescue idiom.
# +
class Object
  # Can you safely dup this object?
  #
  # False for method objects;
  # true otherwise.
  def duplicable?: () -> ::TrueClass
end

class Method
  # Methods are not duplicable:
  #
  #  method(:puts).duplicable? # => false
  #  method(:puts).dup         # => TypeError: allocator undefined for Method
  def duplicable?: () -> ::FalseClass
end

class UnboundMethod
  # Unbound methods are not duplicable:
  #
  #  method(:puts).unbind.duplicable? # => false
  #  method(:puts).unbind.dup         # => TypeError: allocator undefined for UnboundMethod
  def duplicable?: () -> ::FalseClass
end

class Object
  # Returns true if this object is included in the argument. Argument must be
  # any object which responds to +#include?+. Usage:
  #
  #   characters = ["Konata", "Kagami", "Tsukasa"]
  #   "Konata".in?(characters) # => true
  #
  # This will throw an +ArgumentError+ if the argument doesn't respond
  # to +#include?+.
  def in?: (untyped another_object) -> untyped

  # Returns the receiver if it's included in the argument otherwise returns +nil+.
  # Argument must be any object which responds to +#include?+. Usage:
  #
  #   params[:bucket_type].presence_in %w( project calendar )
  #
  # This will throw an +ArgumentError+ if the argument doesn't respond to +#include?+.
  #
  # @return [Object]
  def presence_in: (untyped another_object) -> untyped
end

class Object
  # Returns a hash with string keys that maps instance variable names without "@" to their
  # corresponding values.
  #
  #   class C
  #     def initialize(x, y)
  #       @x, @y = x, y
  #     end
  #   end
  #
  #   C.new(0, 1).instance_values # => {"x" => 0, "y" => 1}
  def instance_values: () -> untyped

  # Returns an array of instance variable names as strings including "@".
  #
  #   class C
  #     def initialize(x, y)
  #       @x, @y = x, y
  #     end
  #   end
  #
  #   C.new(0, 1).instance_variable_names # => ["@y", "@x"]
  def instance_variable_names: () -> untyped
end

module ActiveSupport
  module ToJsonWithActiveSupportEncoder
    # :nodoc:
    def to_json: (?untyped? options) -> untyped
  end
end

class Object
  def as_json: (?untyped? options) -> untyped
end

class TrueClass
  def as_json: (?untyped? options) -> untyped
end

class FalseClass
  def as_json: (?untyped? options) -> untyped
end

class NilClass
  def as_json: (?untyped? options) -> untyped
end

class String
  def as_json: (?untyped? options) -> untyped
end

class Numeric
  def as_json: (?untyped? options) -> untyped
end

class Float
  def as_json: (?untyped? options) -> untyped
end

module Enumerable[unchecked out Elem]
  def as_json: (?untyped? options) -> untyped
end

class IO
  def as_json: (?untyped? options) -> untyped
end

class Array[unchecked out Elem]
  def as_json: (?untyped? options) -> untyped
end

class Hash[unchecked out K, unchecked out V]
  def as_json: (?untyped? options) -> untyped
end

class URI::Generic
  # nodoc:
  def as_json: (?untyped? options) -> untyped
end

class Pathname
  # nodoc:
  def as_json: (?untyped? options) -> untyped
end

class Process::Status
  # nodoc:
  def as_json: (?untyped? options) -> { exitstatus: untyped, pid: untyped }
end

class Object
  # Alias of <tt>to_s</tt>.
  def to_param: () -> untyped

  # Converts an object into a string suitable for use as a URL query string,
  # using the given <tt>key</tt> as the param name.
  def to_query: (untyped key) -> ::String
end

class NilClass
  # Returns +self+.
  def to_param: () -> untyped
end

class TrueClass
  # Returns +self+.
  def to_param: () -> untyped
end

class FalseClass
  # Returns +self+.
  def to_param: () -> untyped
end

class Array[unchecked out Elem]
  # Calls <tt>to_param</tt> on all its elements and joins the result with
  # slashes. This is used by <tt>url_for</tt> in Action Pack.
  def to_param: () -> untyped

  # Converts an array into a string suitable for use as a URL query string,
  # using the given +key+ as the param name.
  #
  #   ['Rails', 'coding'].to_query('hobbies') # => "hobbies%5B%5D=Rails&hobbies%5B%5D=coding"
  def to_query: (untyped key) -> untyped
end

class Hash[unchecked out K, unchecked out V]
  # Returns a string representation of the receiver suitable for use as a URL
  # query string:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query
  #   # => "name=David&nationality=Danish"
  #
  # An optional namespace can be passed to enclose key names:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query('user')
  #   # => "user%5Bname%5D=David&user%5Bnationality%5D=Danish"
  #
  # The string pairs "key=value" that conform the query string
  # are sorted lexicographically in ascending order.
  #
  # This method is also aliased as +to_param+.
  def to_query: (?untyped? namespace) -> untyped

  alias to_param to_query
end

class Object
  include ActiveSupport::Tryable
end

class Delegator
  include ActiveSupport::Tryable
end

class Object
  # An elegant way to factor duplication out of options passed to a series of
  # method calls. Each method called in the block, with the block variable as
  # the receiver, will have its options merged with the default +options+ hash
  # provided. Each method called on the block variable must take an options
  # hash as its final argument.
  #
  # Without <tt>with_options</tt>, this code contains duplication:
  #
  #   class Account < ActiveRecord::Base
  #     has_many :customers, dependent: :destroy
  #     has_many :products,  dependent: :destroy
  #     has_many :invoices,  dependent: :destroy
  #     has_many :expenses,  dependent: :destroy
  #   end
  #
  # Using <tt>with_options</tt>, we can remove the duplication:
  #
  #   class Account < ActiveRecord::Base
  #     with_options dependent: :destroy do |assoc|
  #       assoc.has_many :customers
  #       assoc.has_many :products
  #       assoc.has_many :invoices
  #       assoc.has_many :expenses
  #     end
  #   end
  #
  # It can also be used with an explicit receiver:
  #
  #   I18n.with_options locale: user.locale, scope: 'newsletter' do |i18n|
  #     subject i18n.t :subject
  #     body    i18n.t :body, user_name: user.name
  #   end
  #
  # When you don't pass an explicit receiver, it executes the whole block
  # in merging options context:
  #
  #   class Account < ActiveRecord::Base
  #     with_options dependent: :destroy do
  #       has_many :customers
  #       has_many :products
  #       has_many :invoices
  #       has_many :expenses
  #     end
  #   end
  #
  # <tt>with_options</tt> can also be nested since the call is forwarded to its receiver.
  #
  # NOTE: Each nesting level will merge inherited defaults in addition to their own.
  #
  #   class Post < ActiveRecord::Base
  #     with_options if: :persisted?, length: { minimum: 50 } do
  #       validates :content, if: -> { content.present? }
  #     end
  #   end
  #
  # The code is equivalent to:
  #
  #   validates :content, length: { minimum: 50 }, if: -> { content.present? }
  #
  # Hence the inherited default for +if+ key is ignored.
  #
  # NOTE: You cannot call class methods implicitly inside of with_options.
  # You can access these methods using the class name instead:
  #
  #   class Phone < ActiveRecord::Base
  #     enum phone_number_type: { home: 0, office: 1, mobile: 2 }
  #
  #     with_options presence: true do
  #       validates :phone_number_type, inclusion: { in: Phone.phone_number_types.keys }
  #     end
  #   end
  #
  def with_options: (untyped options) { () -> untyped } -> untyped
end

module ActiveSupport
  module CompareWithRange
    # Extends the default Range#=== to support range comparisons.
    #  (1..5) === (1..5)  # => true
    #  (1..5) === (2..3)  # => true
    #  (1..5) === (1...6) # => true
    #  (1..5) === (2..6)  # => false
    #
    # The native Range#=== behavior is untouched.
    #  ('a'..'f') === ('c') # => true
    #  (5..9) === (11) # => false
    #
    # The given range must be fully bounded, with both start and end.
    def ===: (untyped value) -> untyped

    # Extends the default Range#include? to support range comparisons.
    #  (1..5).include?(1..5)  # => true
    #  (1..5).include?(2..3)  # => true
    #  (1..5).include?(1...6) # => true
    #  (1..5).include?(2..6)  # => false
    #
    # The native Range#include? behavior is untouched.
    #  ('a'..'f').include?('c') # => true
    #  (5..9).include?(11) # => false
    #
    # The given range must be fully bounded, with both start and end.
    def include?: (untyped value) -> untyped

    # Extends the default Range#cover? to support range comparisons.
    #  (1..5).cover?(1..5)  # => true
    #  (1..5).cover?(2..3)  # => true
    #  (1..5).cover?(1...6) # => true
    #  (1..5).cover?(2..6)  # => false
    #
    # The native Range#cover? behavior is untouched.
    #  ('a'..'f').cover?('c') # => true
    #  (5..9).cover?(11) # => false
    #
    # The given range must be fully bounded, with both start and end.
    def cover?: (untyped value) -> untyped
  end
end

module ActiveSupport
  module RangeWithFormat
    RANGE_FORMATS: ::Hash[untyped, untyped]

    # Convert range to a formatted string. See RANGE_FORMATS for predefined formats.
    #
    #   range = (1..100)           # => 1..100
    #
    #   range.to_s                 # => "1..100"
    #   range.to_s(:db)            # => "BETWEEN '1' AND '100'"
    #
    # == Adding your own range formats to to_s
    # You can add your own formats to the Range::RANGE_FORMATS hash.
    # Use the format name as the hash key and a Proc instance.
    #
    #   # config/initializers/range_formats.rb
    #   Range::RANGE_FORMATS[:short] = ->(start, stop) { "Between #{start.to_s(:db)} and #{stop.to_s(:db)}" }
    def to_s: (?::Symbol format) -> untyped

    alias to_default_s to_s

    alias to_formatted_s to_s
  end
end

module ActiveSupport
  module EachTimeWithZone
    # nodoc:
    def each: () { () -> untyped } -> untyped

    def step: (?::Integer n) { () -> untyped } -> untyped

    private

    def ensure_iteration_allowed: () -> untyped
  end
end

module ActiveSupport
  module IncludeTimeWithZone
    # nodoc:
    # Extends the default Range#include? to support ActiveSupport::TimeWithZone.
    #
    #   (1.hour.ago..1.hour.from_now).include?(Time.current) # => true
    #
    def include?: (untyped value) -> untyped
  end
end

class Range[out Elem]
  # Compare two ranges and see if they overlap each other
  #  (1..5).overlaps?(4..6) # => true
  #  (1..5).overlaps?(7..9) # => false
  def overlaps?: (untyped other) -> untyped
end

class Regexp
  # nodoc:
  def multiline?: () -> untyped
end

module SecureRandom
  BASE58_ALPHABET: untyped

  BASE36_ALPHABET: untyped

  # SecureRandom.base58 generates a random base58 string.
  #
  # The argument _n_ specifies the length of the random string to be generated.
  #
  # If _n_ is not specified or is +nil+, 16 is assumed. It may be larger in the future.
  #
  # The result may contain alphanumeric characters except 0, O, I and l.
  #
  #   p SecureRandom.base58 # => "4kUgL2pdQMSCQtjE"
  #   p SecureRandom.base58(24) # => "77TMHrHJFvFDwodq8w7Ev2m7"
  def self.base58: (?::Integer n) -> untyped

  # SecureRandom.base36 generates a random base36 string in lowercase.
  #
  # The argument _n_ specifies the length of the random string to be generated.
  #
  # If _n_ is not specified or is +nil+, 16 is assumed. It may be larger in the future.
  # This method can be used over +base58+ if a deterministic case key is necessary.
  #
  # The result will contain alphanumeric characters in lowercase.
  #
  #   p SecureRandom.base36 # => "4kugl2pdqmscqtje"
  #   p SecureRandom.base36(24) # => "77tmhrhjfvfdwodq8w7ev2m7"
  def self.base36: (?::Integer n) -> untyped
end

class String
  # If you pass a single integer, returns a substring of one character at that
  # position. The first character of the string is at position 0, the next at
  # position 1, and so on. If a range is supplied, a substring containing
  # characters at offsets given by the range is returned. In both cases, if an
  # offset is negative, it is counted from the end of the string. Returns +nil+
  # if the initial offset falls outside the string. Returns an empty string if
  # the beginning of the range is greater than the end of the string.
  #
  #   str = "hello"
  #   str.at(0)      # => "h"
  #   str.at(1..3)   # => "ell"
  #   str.at(-2)     # => "l"
  #   str.at(-2..-1) # => "lo"
  #   str.at(5)      # => nil
  #   str.at(5..-1)  # => ""
  #
  # If a Regexp is given, the matching portion of the string is returned.
  # If a String is given, that given string is returned if it occurs in
  # the string. In both cases, +nil+ is returned if there is no match.
  #
  #   str = "hello"
  #   str.at(/lo/) # => "lo"
  #   str.at(/ol/) # => nil
  #   str.at("lo") # => "lo"
  #   str.at("ol") # => nil
  def at: (untyped position) -> untyped

  # Returns a substring from the given position to the end of the string.
  # If the position is negative, it is counted from the end of the string.
  #
  #   str = "hello"
  #   str.from(0)  # => "hello"
  #   str.from(3)  # => "lo"
  #   str.from(-2) # => "lo"
  #
  # You can mix it with +to+ method and do fun things like:
  #
  #   str = "hello"
  #   str.from(0).to(-1) # => "hello"
  #   str.from(1).to(-2) # => "ell"
  def from: (untyped position) -> untyped

  # Returns a substring from the beginning of the string to the given position.
  # If the position is negative, it is counted from the end of the string.
  #
  #   str = "hello"
  #   str.to(0)  # => "h"
  #   str.to(3)  # => "hell"
  #   str.to(-2) # => "hell"
  #
  # You can mix it with +from+ method and do fun things like:
  #
  #   str = "hello"
  #   str.from(0).to(-1) # => "hello"
  #   str.from(1).to(-2) # => "ell"
  def to: (untyped position) -> untyped

  # Returns the first character. If a limit is supplied, returns a substring
  # from the beginning of the string until it reaches the limit value. If the
  # given limit is greater than or equal to the string length, returns a copy of self.
  #
  #   str = "hello"
  #   str.first    # => "h"
  #   str.first(1) # => "h"
  #   str.first(2) # => "he"
  #   str.first(0) # => ""
  #   str.first(6) # => "hello"
  def first: (?::Integer limit) -> untyped

  # Returns the last character of the string. If a limit is supplied, returns a substring
  # from the end of the string until it reaches the limit value (counting backwards). If
  # the given limit is greater than or equal to the string length, returns a copy of self.
  #
  #   str = "hello"
  #   str.last    # => "o"
  #   str.last(1) # => "o"
  #   str.last(2) # => "lo"
  #   str.last(0) # => ""
  #   str.last(6) # => "hello"
  def last: (?::Integer limit) -> untyped
end

class String
  # Enables more predictable duck-typing on String-like classes. See <tt>Object#acts_like?</tt>.
  def acts_like_string?: () -> ::TrueClass
end

class String
  # Converts a string to a Time value.
  # The +form+ can be either :utc or :local (default :local).
  #
  # The time is parsed using Time.parse method.
  # If +form+ is :local, then the time is in the system timezone.
  # If the date part is missing then the current date is used and if
  # the time part is missing then it is assumed to be 00:00:00.
  #
  #   "13-12-2012".to_time               # => 2012-12-13 00:00:00 +0100
  #   "06:12".to_time                    # => 2012-12-13 06:12:00 +0100
  #   "2012-12-13 06:12".to_time         # => 2012-12-13 06:12:00 +0100
  #   "2012-12-13T06:12".to_time         # => 2012-12-13 06:12:00 +0100
  #   "2012-12-13T06:12".to_time(:utc)   # => 2012-12-13 06:12:00 UTC
  #   "12/13/2012".to_time               # => ArgumentError: argument out of range
  def to_time: (?::Symbol form) -> (nil | untyped)

  # Converts a string to a Date value.
  #
  #   "1-1-2012".to_date   # => Sun, 01 Jan 2012
  #   "01/01/2012".to_date # => Sun, 01 Jan 2012
  #   "2012-12-13".to_date # => Thu, 13 Dec 2012
  #   "12/13/2012".to_date # => ArgumentError: invalid date
  def to_date: () -> untyped

  # Converts a string to a DateTime value.
  #
  #   "1-1-2012".to_datetime            # => Sun, 01 Jan 2012 00:00:00 +0000
  #   "01/01/2012 23:59:59".to_datetime # => Sun, 01 Jan 2012 23:59:59 +0000
  #   "2012-12-13 12:50".to_datetime    # => Thu, 13 Dec 2012 12:50:00 +0000
  #   "12/13/2012".to_datetime          # => ArgumentError: invalid date
  def to_datetime: () -> untyped
end

class String
  # The inverse of <tt>String#include?</tt>. Returns true if the string
  # does not include the other string.
  #
  #   "hello".exclude? "lo" # => false
  #   "hello".exclude? "ol" # => true
  #   "hello".exclude? ?h   # => false
  def exclude?: (untyped string) -> untyped
end

class String
  # Returns the string, first removing all whitespace on both ends of
  # the string, and then changing remaining consecutive whitespace
  # groups into one space each.
  #
  # Note that it handles both ASCII and Unicode whitespace.
  #
  #   %{ Multi-line
  #      string }.squish                   # => "Multi-line string"
  #   " foo   bar    \n   \t   boo".squish # => "foo bar boo"
  def squish: () -> untyped

  # Performs a destructive squish. See String#squish.
  #   str = " foo   bar    \n   \t   boo"
  #   str.squish!                         # => "foo bar boo"
  #   str                                 # => "foo bar boo"
  def squish!: () -> untyped

  # Returns a new string with all occurrences of the patterns removed.
  #   str = "foo bar test"
  #   str.remove(" test")                 # => "foo bar"
  #   str.remove(" test", /bar/)          # => "foo "
  #   str                                 # => "foo bar test"
  def remove: (*untyped patterns) -> untyped

  # Alters the string by removing all occurrences of the patterns.
  #   str = "foo bar test"
  #   str.remove!(" test", /bar/)         # => "foo "
  #   str                                 # => "foo "
  def remove!: (*untyped patterns) -> untyped

  # Truncates a given +text+ after a given <tt>length</tt> if +text+ is longer than <tt>length</tt>:
  #
  #   'Once upon a time in a world far far away'.truncate(27)
  #   # => "Once upon a time in a wo..."
  #
  # Pass a string or regexp <tt>:separator</tt> to truncate +text+ at a natural break:
  #
  #   'Once upon a time in a world far far away'.truncate(27, separator: ' ')
  #   # => "Once upon a time in a..."
  #
  #   'Once upon a time in a world far far away'.truncate(27, separator: /\s/)
  #   # => "Once upon a time in a..."
  #
  # The last characters will be replaced with the <tt>:omission</tt> string (defaults to "...")
  # for a total length not exceeding <tt>length</tt>:
  #
  #   'And they found that many people were sleeping better.'.truncate(25, omission: '... (continued)')
  #   # => "And they f... (continued)"
  def truncate: (untyped truncate_at, ?::Hash[untyped, untyped] options) -> untyped

  # Truncates +text+ to at most <tt>bytesize</tt> bytes in length without
  # breaking string encoding by splitting multibyte characters or breaking
  # grapheme clusters ("perceptual characters") by truncating at combining
  # characters.
  #
  #   >> "(trim non-ascii characters)".size
  #   => 20
  #   >> "(trim non-ascii characters)".bytesize
  #   => 80
  #   >> "(trim non-ascii characters)".truncate_bytes(20)
  #   => "(trim non-ascii characters)"
  #
  # The truncated text ends with the <tt>:omission</tt> string, defaulting
  # to "(trim non-ascii characters)", for a total length not exceeding <tt>bytesize</tt>.
  def truncate_bytes: (untyped truncate_at, ?omission: ::String omission) -> untyped

  # Truncates a given +text+ after a given number of words (<tt>words_count</tt>):
  #
  #   'Once upon a time in a world far far away'.truncate_words(4)
  #   # => "Once upon a time..."
  #
  # Pass a string or regexp <tt>:separator</tt> to specify a different separator of words:
  #
  #   'Once<br>upon<br>a<br>time<br>in<br>a<br>world'.truncate_words(5, separator: '<br>')
  #   # => "Once<br>upon<br>a<br>time<br>in..."
  #
  # The last characters will be replaced with the <tt>:omission</tt> string (defaults to "..."):
  #
  #   'And they found that many people were sleeping better.'.truncate_words(5, omission: '... (continued)')
  #   # => "And they found that many... (continued)"
  def truncate_words: (untyped words_count, ?::Hash[untyped, untyped] options) -> untyped
end

class String
  # Same as +indent+, except it indents the receiver in-place.
  #
  # Returns the indented string, or +nil+ if there was nothing to indent.
  def indent!: (untyped amount, ?untyped? indent_string, ?bool indent_empty_lines) -> untyped

  # Indents the lines in the receiver:
  #
  #   <<EOS.indent(2)
  #   def some_method
  #     some_code
  #   end
  #   EOS
  #   # =>
  #     def some_method
  #       some_code
  #     end
  #
  # The second argument, +indent_string+, specifies which indent string to
  # use. The default is +nil+, which tells the method to make a guess by
  # peeking at the first indented line, and fallback to a space if there is
  # none.
  #
  #   "  foo".indent(2)        # => "    foo"
  #   "foo\n\t\tbar".indent(2) # => "\t\tfoo\n\t\t\t\tbar"
  #   "foo".indent(2, "\t")    # => "\t\tfoo"
  #
  # While +indent_string+ is typically one space or tab, it may be any string.
  #
  # The third argument, +indent_empty_lines+, is a flag that says whether
  # empty lines should be indented. Default is false.
  #
  #   "foo\n\nbar".indent(2)            # => "  foo\n\n  bar"
  #   "foo\n\nbar".indent(2, nil, true) # => "  foo\n  \n  bar"
  #
  def indent: (untyped amount, ?untyped? indent_string, ?bool indent_empty_lines) -> untyped
end

# String inflections define new methods on the String class to transform names for different purposes.
# For instance, you can figure out the name of a table from the name of a class.
#
#   'ScaleScore'.tableize # => "scale_scores"
#
class String
  # Returns the plural form of the word in the string.
  #
  # If the optional parameter +count+ is specified,
  # the singular form will be returned if <tt>count == 1</tt>.
  # For any other value of +count+ the plural will be returned.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be pluralized as a word of that language.
  # By default, this parameter is set to <tt>:en</tt>.
  # You must define your own inflection rules for languages other than English.
  #
  #   'post'.pluralize             # => "posts"
  #   'octopus'.pluralize          # => "octopi"
  #   'sheep'.pluralize            # => "sheep"
  #   'words'.pluralize            # => "words"
  #   'the blue mailman'.pluralize # => "the blue mailmen"
  #   'CamelOctopus'.pluralize     # => "CamelOctopi"
  #   'apple'.pluralize(1)         # => "apple"
  #   'apple'.pluralize(2)         # => "apples"
  #   'ley'.pluralize(:es)         # => "leyes"
  #   'ley'.pluralize(1, :es)      # => "ley"
  def pluralize: (?untyped? count, ?::Symbol locale) -> untyped

  # The reverse of +pluralize+, returns the singular form of a word in a string.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be singularized as a word of that language.
  # By default, this parameter is set to <tt>:en</tt>.
  # You must define your own inflection rules for languages other than English.
  #
  #   'posts'.singularize            # => "post"
  #   'octopi'.singularize           # => "octopus"
  #   'sheep'.singularize            # => "sheep"
  #   'word'.singularize             # => "word"
  #   'the blue mailmen'.singularize # => "the blue mailman"
  #   'CamelOctopi'.singularize      # => "CamelOctopus"
  #   'leyes'.singularize(:es)       # => "ley"
  def singularize: (?::Symbol locale) -> untyped

  # +constantize+ tries to find a declared constant with the name specified
  # in the string. It raises a NameError when the name is not in CamelCase
  # or is not initialized.  See ActiveSupport::Inflector.constantize
  #
  #   'Module'.constantize  # => Module
  #   'Class'.constantize   # => Class
  #   'blargle'.constantize # => NameError: wrong constant name blargle
  def constantize: () -> untyped

  # +safe_constantize+ tries to find a declared constant with the name specified
  # in the string. It returns +nil+ when the name is not in CamelCase
  # or is not initialized.  See ActiveSupport::Inflector.safe_constantize
  #
  #   'Module'.safe_constantize  # => Module
  #   'Class'.safe_constantize   # => Class
  #   'blargle'.safe_constantize # => nil
  def safe_constantize: () -> untyped

  # By default, +camelize+ converts strings to UpperCamelCase. If the argument to camelize
  # is set to <tt>:lower</tt> then camelize produces lowerCamelCase.
  #
  # +camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.
  #
  #   'active_record'.camelize                # => "ActiveRecord"
  #   'active_record'.camelize(:lower)        # => "activeRecord"
  #   'active_record/errors'.camelize         # => "ActiveRecord::Errors"
  #   'active_record/errors'.camelize(:lower) # => "activeRecord::Errors"
  def camelize: (?::Symbol first_letter) -> untyped

  alias camelcase camelize

  # Capitalizes all the words and replaces some characters in the string to create
  # a nicer looking title. +titleize+ is meant for creating pretty output. It is not
  # used in the Rails internals.
  #
  # The trailing '_id','Id'.. can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true.
  # By default, this parameter is false.
  #
  # +titleize+ is also aliased as +titlecase+.
  #
  #   'man from the boondocks'.titleize                       # => "Man From The Boondocks"
  #   'x-men: the last stand'.titleize                        # => "X Men: The Last Stand"
  #   'string_ending_with_id'.titleize(keep_id_suffix: true)  # => "String Ending With Id"
  def titleize: (?keep_id_suffix: bool keep_id_suffix) -> untyped

  alias titlecase titleize

  # The reverse of +camelize+. Makes an underscored, lowercase form from the expression in the string.
  #
  # +underscore+ will also change '::' to '/' to convert namespaces to paths.
  #
  #   'ActiveModel'.underscore         # => "active_model"
  #   'ActiveModel::Errors'.underscore # => "active_model/errors"
  def underscore: () -> untyped

  # Replaces underscores with dashes in the string.
  #
  #   'puni_puni'.dasherize # => "puni-puni"
  def dasherize: () -> untyped

  # Removes the module part from the constant expression in the string.
  #
  #   'ActiveSupport::Inflector::Inflections'.demodulize # => "Inflections"
  #   'Inflections'.demodulize                           # => "Inflections"
  #   '::Inflections'.demodulize                         # => "Inflections"
  #   ''.demodulize                                      # => ''
  #
  # See also +deconstantize+.
  def demodulize: () -> untyped

  # Removes the rightmost segment from the constant expression in the string.
  #
  #   'Net::HTTP'.deconstantize   # => "Net"
  #   '::Net::HTTP'.deconstantize # => "::Net"
  #   'String'.deconstantize      # => ""
  #   '::String'.deconstantize    # => ""
  #   ''.deconstantize            # => ""
  #
  # See also +demodulize+.
  def deconstantize: () -> untyped

  # Replaces special characters in a string so that it may be used as part of a 'pretty' URL.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be parameterized as a word of that language.
  # By default, this parameter is set to <tt>nil</tt> and it will use
  # the configured <tt>I18n.locale</tt>.
  #
  #   class Person
  #     def to_param
  #       "#{id}-#{name.parameterize}"
  #     end
  #   end
  #
  #   @person = Person.find(1)
  #   # => #<Person id: 1, name: "Donald E. Knuth">
  #
  #   <%= link_to(@person.name, person_path) %>
  #   # => <a href="/person/1-donald-e-knuth">Donald E. Knuth</a>
  #
  # To preserve the case of the characters in a string, use the +preserve_case+ argument.
  #
  #   class Person
  #     def to_param
  #       "#{id}-#{name.parameterize(preserve_case: true)}"
  #     end
  #   end
  #
  #   @person = Person.find(1)
  #   # => #<Person id: 1, name: "Donald E. Knuth">
  #
  #   <%= link_to(@person.name, person_path) %>
  #   # => <a href="/person/1-Donald-E-Knuth">Donald E. Knuth</a>
  def parameterize: (?locale: untyped? locale, ?preserve_case: bool preserve_case, ?separator: ::String separator) -> untyped

  # Creates the name of a table like Rails does for models to table names. This method
  # uses the +pluralize+ method on the last word in the string.
  #
  #   'RawScaledScorer'.tableize # => "raw_scaled_scorers"
  #   'ham_and_egg'.tableize     # => "ham_and_eggs"
  #   'fancyCategory'.tableize   # => "fancy_categories"
  def tableize: () -> untyped

  # Creates a class name from a plural table name like Rails does for table names to models.
  # Note that this returns a string and not a class. (To convert to an actual class
  # follow +classify+ with +constantize+.)
  #
  #   'ham_and_eggs'.classify # => "HamAndEgg"
  #   'posts'.classify        # => "Post"
  def classify: () -> untyped

  # Capitalizes the first word, turns underscores into spaces, and (by default)strips a
  # trailing '_id' if present.
  # Like +titleize+, this is meant for creating pretty output.
  #
  # The capitalization of the first word can be turned off by setting the
  # optional parameter +capitalize+ to false.
  # By default, this parameter is true.
  #
  # The trailing '_id' can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true.
  # By default, this parameter is false.
  #
  #   'employee_salary'.humanize                    # => "Employee salary"
  #   'author_id'.humanize                          # => "Author"
  #   'author_id'.humanize(capitalize: false)       # => "author"
  #   '_id'.humanize                                # => "Id"
  #   'author_id'.humanize(keep_id_suffix: true)    # => "Author Id"
  def humanize: (?keep_id_suffix: bool keep_id_suffix, ?capitalize: bool capitalize) -> untyped

  # Converts just the first character to uppercase.
  #
  #   'what a Lovely Day'.upcase_first # => "What a Lovely Day"
  #   'w'.upcase_first                 # => "W"
  #   ''.upcase_first                  # => ""
  def upcase_first: () -> untyped

  # Creates a foreign key name from a class name.
  # +separate_class_name_and_id_with_underscore+ sets whether
  # the method should put '_' between the name and 'id'.
  #
  #   'Message'.foreign_key        # => "message_id"
  #   'Message'.foreign_key(false) # => "messageid"
  #   'Admin::Post'.foreign_key    # => "post_id"
  def foreign_key: (?bool separate_class_name_and_id_with_underscore) -> untyped
end

class String
  # Wraps the current string in the <tt>ActiveSupport::StringInquirer</tt> class,
  # which gives you a prettier way to test for equality.
  #
  #   env = 'production'.inquiry
  #   env.production?  # => true
  #   env.development? # => false
  def inquiry: () -> ActiveSupport::StringInquirer
end

class String
  # == Multibyte proxy
  #
  # +mb_chars+ is a multibyte safe proxy for string methods.
  #
  # It creates and returns an instance of the ActiveSupport::Multibyte::Chars class which
  # encapsulates the original string. A Unicode safe version of all the String methods are defined on this proxy
  # class. If the proxy class doesn't respond to a certain method, it's forwarded to the encapsulated string.
  #
  #   >> "(trim non-ascii characters)".mb_chars.upcase.to_s
  #   => "(trim non-ascii characters)"
  #
  # NOTE: Ruby 2.4 and later support native Unicode case mappings:
  #
  #   >> "(trim non-ascii characters)".upcase
  #   => "(trim non-ascii characters)"
  #
  # == Method chaining
  #
  # All the methods on the Chars proxy which normally return a string will return a Chars object. This allows
  # method chaining on the result of any of these methods.
  #
  #   name.mb_chars.reverse.length # => 12
  #
  # == Interoperability and configuration
  #
  # The Chars object tries to be as interchangeable with String objects as possible: sorting and comparing between
  # String and Char work like expected. The bang! methods change the internal string representation in the Chars
  # object. Interoperability problems can be resolved easily with a +to_s+ call.
  #
  # For more information about the methods defined on the Chars proxy see ActiveSupport::Multibyte::Chars. For
  # information about how to change the default Multibyte behavior see ActiveSupport::Multibyte.
  def mb_chars: () -> untyped

  # Returns +true+ if string has utf_8 encoding.
  #
  #   utf_8_str = "some string".encode "UTF-8"
  #   iso_str = "some string".encode "ISO-8859-1"
  #
  #   utf_8_str.is_utf8? # => true
  #   iso_str.is_utf8?   # => false
  def is_utf8?: () -> untyped
end

class ERB
  module Util
    HTML_ESCAPE: ::Hash[untyped, untyped]

    JSON_ESCAPE: ::Hash[untyped, untyped]

    HTML_ESCAPE_ONCE_REGEXP: untyped

    JSON_ESCAPE_REGEXP: untyped

    # A utility method for escaping HTML tag characters.
    # This method is also aliased as <tt>h</tt>.
    #
    #   puts html_escape('is a > 0 & a < 10?')
    #   # => is a &gt; 0 &amp; a &lt; 10?
    def self?.html_escape: (untyped s) -> untyped

    alias h html_escape

    def self?.unwrapped_html_escape: (untyped s) -> untyped

    # A utility method for escaping HTML without affecting existing escaped entities.
    #
    #   html_escape_once('1 < 2 &amp; 3')
    #   # => "1 &lt; 2 &amp; 3"
    #
    #   html_escape_once('&lt;&lt; Accept & Checkout')
    #   # => "&lt;&lt; Accept &amp; Checkout"
    def self?.html_escape_once: (untyped s) -> untyped

    # A utility method for escaping HTML entities in JSON strings. Specifically, the
    # &, > and < characters are replaced with their equivalent unicode escaped form -
    # \u0026, \u003e, and \u003c. The Unicode sequences \u2028 and \u2029 are also
    # escaped as they are treated as newline characters in some JavaScript engines.
    # These sequences have identical meaning as the original characters inside the
    # context of a JSON string, so assuming the input is a valid and well-formed
    # JSON value, the output will have equivalent meaning when parsed:
    #
    #   json = JSON.generate({ name: "</script><script>alert('PWNED!!!')</script>"})
    #   # => "{\"name\":\"</script><script>alert('PWNED!!!')</script>\"}"
    #
    #   json_escape(json)
    #   # => "{\"name\":\"\\u003C/script\\u003E\\u003Cscript\\u003Ealert('PWNED!!!')\\u003C/script\\u003E\"}"
    #
    #   JSON.parse(json) == JSON.parse(json_escape(json))
    #   # => true
    #
    # The intended use case for this method is to escape JSON strings before including
    # them inside a script tag to avoid XSS vulnerability:
    #
    #   <script>
    #     var currentUser = <%= raw json_escape(current_user.to_json) %>;
    #   </script>
    #
    # It is necessary to +raw+ the result of +json_escape+, so that quotation marks
    # don't get converted to <tt>&quot;</tt> entities. +json_escape+ doesn't
    # automatically flag the result as HTML safe, since the raw value is unsafe to
    # use inside HTML attributes.
    #
    # If your JSON is being used downstream for insertion into the DOM, be aware of
    # whether or not it is being inserted via +html()+. Most jQuery plugins do this.
    # If that is the case, be sure to +html_escape+ or +sanitize+ any user-generated
    # content returned by your JSON.
    #
    # If you need to output JSON elsewhere in your HTML, you can just do something
    # like this, as any unsafe characters (including quotation marks) will be
    # automatically escaped for you:
    #
    #   <div data-user-info="<%= current_user.to_json %>">...</div>
    #
    # WARNING: this helper only works with valid JSON. Using this on non-JSON values
    # will open up serious XSS vulnerabilities. For example, if you replace the
    # +current_user.to_json+ in the example above with user input instead, the browser
    # will happily eval() that string as JavaScript.
    #
    # The escaping performed in this method is identical to those performed in the
    # Active Support JSON encoder when +ActiveSupport.escape_html_entities_in_json+ is
    # set to true. Because this transformation is idempotent, this helper can be
    # applied even if +ActiveSupport.escape_html_entities_in_json+ is already true.
    #
    # Therefore, when you are unsure if +ActiveSupport.escape_html_entities_in_json+
    # is enabled, or if you are unsure where your JSON string originated from, it
    # is recommended that you always apply this helper (other libraries, such as the
    # JSON gem, do not provide this kind of protection by default; also some gems
    # might override +to_json+ to bypass Active Support's encoder).
    def self?.json_escape: (untyped s) -> untyped
  end
end

class Object
  def html_safe?: () -> ::FalseClass
end

class Numeric
  def html_safe?: () -> ::TrueClass
end

module ActiveSupport
  # nodoc:
  class SafeBuffer < String
    UNSAFE_STRING_METHODS: ::Array[untyped]

    UNSAFE_STRING_METHODS_WITH_BACKREF: ::Array[untyped]

    alias original_concat concat

    # Raised when <tt>ActiveSupport::SafeBuffer#safe_concat</tt> is called on unsafe buffers.
    class SafeConcatError < StandardError
      def initialize: () -> untyped
    end

    def []: (*untyped args) -> untyped

    def safe_concat: (untyped value) -> untyped

    def initialize: (?::String str) -> untyped

    def initialize_copy: (untyped other) -> untyped

    def clone_empty: () -> untyped

    def concat: (untyped value) -> untyped

    alias << concat

    def insert: (untyped index, untyped value) -> untyped

    def prepend: (untyped value) -> untyped

    def replace: (untyped value) -> untyped

    def []=: (*untyped args) -> untyped

    def +: (untyped other) -> untyped

    def *: () -> untyped

    def %: (untyped args) -> untyped

    def html_safe?: () -> untyped

    def to_s: () -> untyped

    def to_param: () -> untyped

    def encode_with: (untyped coder) -> untyped

    private

    def html_escape_interpolated_argument: (untyped arg) -> untyped

    def set_block_back_references: (untyped block, untyped match_data) -> untyped
  end
end

class String
  # Marks a string as trusted safe. It will be inserted into HTML with no
  # additional escaping performed. It is your responsibility to ensure that the
  # string contains no malicious content. This method is equivalent to the
  # +raw+ helper in views. It is recommended that you use +sanitize+ instead of
  # this method. It should never be called on user input.
  def html_safe: () -> ActiveSupport::SafeBuffer
end

class String
  alias starts_with? start_with?

  alias ends_with? end_with?
end

class String
  # Strips indentation in heredocs.
  #
  # For example in
  #
  #   if options[:usage]
  #     puts <<-USAGE.strip_heredoc
  #       This command does such and such.
  #
  #       Supported options are:
  #         -h         This message
  #         ...
  #     USAGE
  #   end
  #
  # the user would see the usage message aligned against the left margin.
  #
  # Technically, it looks for the least indented non-empty line
  # in the whole string, and removes that amount of leading whitespace.
  def strip_heredoc: () -> untyped
end

class String
  # Converts String to a TimeWithZone in the current zone if Time.zone or Time.zone_default
  # is set, otherwise converts String to a Time via String#to_time
  def in_time_zone: (?(ActiveSupport::TimeZone | String) zone) -> ::ActiveSupport::TimeWithZone
                  | (false? zone) -> ::Time
end

class Time
  # Duck-types as a Time-like class. See Object#acts_like?.
  def acts_like_time?: () -> ::TrueClass
end

class Time
  include DateAndTime::Calculations

  COMMON_YEAR_DAYS_IN_MONTH: ::Array[untyped]

  # Overriding case equality method so that it returns true for ActiveSupport::TimeWithZone instances
  def self.===: (untyped other) -> untyped

  # Returns the number of days in the given month.
  # If no year is specified, it will use the current year.
  def self.days_in_month: (untyped month, ?untyped year) -> untyped

  # Returns the number of days in the given year.
  # If no year is specified, it will use the current year.
  def self.days_in_year: (?untyped year) -> untyped

  # Returns <tt>Time.zone.now</tt> when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns <tt>Time.now</tt>.
  def self.current: () -> ActiveSupport::TimeWithZone # strictly `(ActiveSupport::TimeWithZone | Time)` but it's inconvenient

  # Layers additional behavior on Time.at so that ActiveSupport::TimeWithZone and DateTime
  # instances can be used when called with a single argument
  def self.at_with_coercion: (*untyped args) -> untyped

  alias self.at_without_coercion self.at

  # Creates a +Time+ instance from an RFC 3339 string.
  #
  #   Time.rfc3339('1999-12-31T14:00:00-10:00') # => 2000-01-01 00:00:00 -1000
  #
  # If the time or offset components are missing then an +ArgumentError+ will be raised.
  #
  #   Time.rfc3339('1999-12-31') # => ArgumentError: invalid date
  def self.rfc3339: (untyped str) -> Time

  # Returns the number of seconds since 00:00:00.
  #
  #   Time.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0.0
  #   Time.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296.0
  #   Time.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399.0
  def seconds_since_midnight: () -> untyped

  # Returns the number of seconds until 23:59:59.
  #
  #   Time.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399
  #   Time.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103
  #   Time.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0
  def seconds_until_end_of_day: () -> untyped

  # Returns the fraction of a second as a +Rational+
  #
  #   Time.new(2012, 8, 29, 0, 0, 0.5).sec_fraction # => (1/2)
  def sec_fraction: () -> untyped

  # Returns a new Time where one or more of the elements have been changed according
  # to the +options+ parameter. The time options (<tt>:hour</tt>, <tt>:min</tt>,
  # <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>) reset cascadingly, so if only
  # the hour is passed, then minute, sec, usec and nsec is set to 0. If the hour
  # and minute is passed, then sec, usec and nsec is set to 0. The +options+ parameter
  # takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>,
  # <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>,
  # <tt>:offset</tt>. Pass either <tt>:usec</tt> or <tt>:nsec</tt>, not both.
  #
  #   Time.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => Time.new(2012, 8, 1, 22, 35, 0)
  #   Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => Time.new(1981, 8, 1, 22, 35, 0)
  #   Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => Time.new(1981, 8, 29, 0, 0, 0)
  def change: (untyped options) -> untyped

  # Uses Date to provide precise Time calculations for years, months, and days
  # according to the proleptic Gregorian calendar. The +options+ parameter
  # takes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>,
  # <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>, <tt>:minutes</tt>,
  # <tt>:seconds</tt>.
  #
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(seconds: 1) # => 2015-08-01 14:35:01 -0700
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(minutes: 1) # => 2015-08-01 14:36:00 -0700
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(hours: 1)   # => 2015-08-01 15:35:00 -0700
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(days: 1)    # => 2015-08-02 14:35:00 -0700
  #   Time.new(2015, 8, 1, 14, 35, 0).advance(weeks: 1)   # => 2015-08-08 14:35:00 -0700
  def advance: (untyped options) -> untyped

  # Returns a new Time representing the time a number of seconds ago, this is basically a wrapper around the Numeric extension
  def ago: (untyped seconds) -> untyped

  # Returns a new Time representing the time a number of seconds since the instance time
  def since: (untyped seconds) -> untyped

  alias in since

  # Returns a new Time representing the start of the day (0:00)
  def beginning_of_day: () -> untyped

  alias midnight beginning_of_day

  alias at_midnight beginning_of_day

  alias at_beginning_of_day beginning_of_day

  # Returns a new Time representing the middle of the day (12:00)
  def middle_of_day: () -> untyped

  alias midday middle_of_day

  alias noon middle_of_day

  alias at_midday middle_of_day

  alias at_noon middle_of_day

  alias at_middle_of_day middle_of_day

  # Returns a new Time representing the end of the day, 23:59:59.999999
  def end_of_day: () -> untyped

  alias at_end_of_day end_of_day

  # Returns a new Time representing the start of the hour (x:00)
  def beginning_of_hour: () -> untyped

  alias at_beginning_of_hour beginning_of_hour

  # Returns a new Time representing the end of the hour, x:59:59.999999
  def end_of_hour: () -> untyped

  alias at_end_of_hour end_of_hour

  # Returns a new Time representing the start of the minute (x:xx:00)
  def beginning_of_minute: () -> untyped

  alias at_beginning_of_minute beginning_of_minute

  # Returns a new Time representing the end of the minute, x:xx:59.999999
  def end_of_minute: () -> untyped

  alias at_end_of_minute end_of_minute

  def plus_with_duration: (untyped other) -> untyped

  alias plus_without_duration +

  def +: (ActiveSupport::Duration other) -> self
       | ...

  def minus_with_duration: (untyped other) -> untyped

  alias minus_without_duration -

  def -: (ActiveSupport::Duration other) -> self
       | ...

  # Time#- can also be used to determine the number of seconds between two Time instances.
  # We're layering on additional behavior so that ActiveSupport::TimeWithZone instances
  # are coerced into values that Time#- will recognize
  def minus_with_coercion: (untyped other) -> untyped

  alias minus_without_coercion -

  # Layers additional behavior on Time#<=> so that DateTime and ActiveSupport::TimeWithZone instances
  # can be chronologically compared with a Time
  def compare_with_coercion: (untyped other) -> untyped

  alias compare_without_coercion <=>

  # Layers additional behavior on Time#eql? so that ActiveSupport::TimeWithZone instances
  # can be eql? to an equivalent Time
  def eql_with_coercion: (untyped other) -> untyped

  alias eql_without_coercion eql?

  # Returns a new time the specified number of days ago.
  def prev_day: (?::Integer days) -> untyped

  # Returns a new time the specified number of days in the future.
  def next_day: (?::Integer days) -> untyped

  # Returns a new time the specified number of months ago.
  def prev_month: (?::Integer months) -> untyped

  # Returns a new time the specified number of months in the future.
  def next_month: (?::Integer months) -> untyped

  # Returns a new time the specified number of years ago.
  def prev_year: (?::Integer years) -> untyped

  # Returns a new time the specified number of years in the future.
  def next_year: (?::Integer years) -> untyped
end

class Time
  include DateAndTime::Compatibility
end

class Time
  DATE_FORMATS: ::Hash[untyped, untyped]

  # Converts to a formatted string. See DATE_FORMATS for built-in formats.
  #
  # This method is aliased to <tt>to_s</tt>.
  #
  #   time = Time.now                    # => 2007-01-18 06:10:17 -06:00
  #
  #   time.to_formatted_s(:time)         # => "06:10"
  #   time.to_s(:time)                   # => "06:10"
  #
  #   time.to_formatted_s(:db)           # => "2007-01-18 06:10:17"
  #   time.to_formatted_s(:number)       # => "20070118061017"
  #   time.to_formatted_s(:short)        # => "18 Jan 06:10"
  #   time.to_formatted_s(:long)         # => "January 18, 2007 06:10"
  #   time.to_formatted_s(:long_ordinal) # => "January 18th, 2007 06:10"
  #   time.to_formatted_s(:rfc822)       # => "Thu, 18 Jan 2007 06:10:17 -0600"
  #   time.to_formatted_s(:iso8601)      # => "2007-01-18T06:10:17-06:00"
  #
  # == Adding your own time formats to +to_formatted_s+
  # You can add your own formats to the Time::DATE_FORMATS hash.
  # Use the format name as the hash key and either a strftime string
  # or Proc instance that takes a time argument as the value.
  #
  #   # config/initializers/time_formats.rb
  #   Time::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime("%B #{time.day.ordinalize}") }
  def to_formatted_s: (?::Symbol format) -> untyped

  alias to_default_s to_s

  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   Time.local(2000).formatted_offset        # => "-06:00"
  #   Time.local(2000).formatted_offset(false) # => "-0600"
  def formatted_offset: (?bool colon, ?untyped? alternate_utc_string) -> untyped

  # Aliased to +xmlschema+ for compatibility with +DateTime+
  alias rfc3339 xmlschema
end

class Time
  include DateAndTime::Zones

  attr_accessor self.zone_default: untyped

  # Returns the TimeZone for the current request, if this has been set (via Time.zone=).
  # If <tt>Time.zone</tt> has not been set for the current request, returns the TimeZone specified in <tt>config.time_zone</tt>.
  def self.zone: () -> ActiveSupport::TimeZone # strictly `ActiveSupport::TimeWithZone?` but it's inconvenient

  # Sets <tt>Time.zone</tt> to a TimeZone object for the current request/thread.
  #
  # This method accepts any of the following:
  #
  # * A Rails TimeZone object.
  # * An identifier for a Rails TimeZone object (e.g., "Eastern Time (US & Canada)", <tt>-5.hours</tt>).
  # * A TZInfo::Timezone object.
  # * An identifier for a TZInfo::Timezone object (e.g., "America/New_York").
  #
  # Here's an example of how you might set <tt>Time.zone</tt> on a per request basis and reset it when the request is done.
  # <tt>current_user.time_zone</tt> just needs to return a string identifying the user's preferred time zone:
  #
  #   class ApplicationController < ActionController::Base
  #     around_action :set_time_zone
  #
  #     def set_time_zone
  #       if logged_in?
  #         Time.use_zone(current_user.time_zone) { yield }
  #       else
  #         yield
  #       end
  #     end
  #   end
  def self.zone=: (untyped time_zone) -> untyped

  # Allows override of <tt>Time.zone</tt> locally inside supplied block;
  # resets <tt>Time.zone</tt> to existing value when done.
  #
  #   class ApplicationController < ActionController::Base
  #     around_action :set_time_zone
  #
  #     private
  #
  #     def set_time_zone
  #       Time.use_zone(current_user.timezone) { yield }
  #     end
  #   end
  #
  # NOTE: This won't affect any <tt>ActiveSupport::TimeWithZone</tt>
  # objects that have already been created, e.g. any model timestamp
  # attributes that have been read before the block will remain in
  # the application's default timezone.
  def self.use_zone: (untyped time_zone) { () -> untyped } -> untyped

  # Returns a TimeZone instance matching the time zone provided.
  # Accepts the time zone in any format supported by <tt>Time.zone=</tt>.
  # Raises an +ArgumentError+ for invalid time zones.
  #
  #   Time.find_zone! "America/New_York" # => #<ActiveSupport::TimeZone @name="America/New_York" ...>
  #   Time.find_zone! "EST"              # => #<ActiveSupport::TimeZone @name="EST" ...>
  #   Time.find_zone! -5.hours           # => #<ActiveSupport::TimeZone @name="Bogota" ...>
  #   Time.find_zone! nil                # => nil
  #   Time.find_zone! false              # => false
  #   Time.find_zone! "NOT-A-TIMEZONE"   # => ArgumentError: Invalid Timezone: NOT-A-TIMEZONE
  def self.find_zone!: (untyped time_zone) -> untyped

  # Returns a TimeZone instance matching the time zone provided.
  # Accepts the time zone in any format supported by <tt>Time.zone=</tt>.
  # Returns +nil+ for invalid time zones.
  #
  #   Time.find_zone "America/New_York" # => #<ActiveSupport::TimeZone @name="America/New_York" ...>
  #   Time.find_zone "NOT-A-TIMEZONE"   # => nil
  def self.find_zone: (untyped time_zone) -> untyped
end

module URI
  def self.parser: () -> untyped
end

module ActiveSupport
  # Abstract super class that provides a thread-isolated attributes singleton, which resets automatically
  # before and after each request. This allows you to keep all the per-request attributes easily
  # available to the whole system.
  #
  # The following full app-like example demonstrates how to use a Current class to
  # facilitate easy access to the global, per-request attributes without passing them deeply
  # around everywhere:
  #
  #   # app/models/current.rb
  #   class Current < ActiveSupport::CurrentAttributes
  #     attribute :account, :user
  #     attribute :request_id, :user_agent, :ip_address
  #
  #     resets { Time.zone = nil }
  #
  #     def user=(user)
  #       super
  #       self.account = user.account
  #       Time.zone    = user.time_zone
  #     end
  #   end
  #
  #   # app/controllers/concerns/authentication.rb
  #   module Authentication
  #     extend ActiveSupport::Concern
  #
  #     included do
  #       before_action :authenticate
  #     end
  #
  #     private
  #       def authenticate
  #         if authenticated_user = User.find_by(id: cookies.encrypted[:user_id])
  #           Current.user = authenticated_user
  #         else
  #           redirect_to new_session_url
  #         end
  #       end
  #   end
  #
  #   # app/controllers/concerns/set_current_request_details.rb
  #   module SetCurrentRequestDetails
  #     extend ActiveSupport::Concern
  #
  #     included do
  #       before_action do
  #         Current.request_id = request.uuid
  #         Current.user_agent = request.user_agent
  #         Current.ip_address = request.ip
  #       end
  #     end
  #   end
  #
  #   class ApplicationController < ActionController::Base
  #     include Authentication
  #     include SetCurrentRequestDetails
  #   end
  #
  #   class MessagesController < ApplicationController
  #     def create
  #       Current.account.messages.create(message_params)
  #     end
  #   end
  #
  #   class Message < ApplicationRecord
  #     belongs_to :creator, default: -> { Current.user }
  #     after_create { |message| Event.create(record: message) }
  #   end
  #
  #   class Event < ApplicationRecord
  #     before_create do
  #       self.request_id = Current.request_id
  #       self.user_agent = Current.user_agent
  #       self.ip_address = Current.ip_address
  #     end
  #   end
  #
  # A word of caution: It's easy to overdo a global singleton like Current and tangle your model as a result.
  # Current should only be used for a few, top-level globals, like account, user, and request details.
  # The attributes stuck in Current should be used by more or less all actions on all requests. If you start
  # sticking controller-specific attributes in there, you're going to create a mess.
  class CurrentAttributes
    include ActiveSupport::Callbacks

    # Returns singleton instance for this class in this thread. If none exists, one is created.
    def self.instance: () -> untyped

    # Declares one or more attributes that will be given both class and instance accessor methods.
    def self.attribute: (*untyped names) -> untyped

    # Calls this block before #reset is called on the instance. Used for resetting external collaborators that depend on current values.
    def self.before_reset: () { () -> untyped } -> untyped

    # Calls this block after #reset is called on the instance. Used for resetting external collaborators, like Time.zone.
    def self.resets: () { () -> untyped } -> untyped

    alias self.after_reset self.resets

    def self.reset_all: () -> untyped

    def self.clear_all: () -> untyped

    private

    def self.generated_attribute_methods: () -> untyped

    def self.current_instances: () -> untyped

    def self.method_missing: (untyped name, *untyped args) { () -> untyped } -> untyped

    public

    attr_accessor attributes: untyped

    def initialize: () -> untyped

    # Expose one or more attributes within a block. Old values are returned after the block concludes.
    # Example demonstrating the common use of needing to set Current attributes outside the request-cycle:
    #
    #   class Chat::PublicationJob < ApplicationJob
    #     def perform(attributes, room_number, creator)
    #       Current.set(person: creator) do
    #         Chat::Publisher.publish(attributes: attributes, room_number: room_number)
    #       end
    #     end
    #   end
    def set: (untyped set_attributes) { () -> untyped } -> untyped

    # Reset all attributes. Should be called before and after actions, when used as a per-request singleton.
    def reset: () -> untyped

    private

    def assign_attributes: (untyped new_attributes) -> untyped

    def compute_attributes: (untyped keys) -> untyped
  end
end

module ActiveSupport
  # Autoload and eager load conveniences for your library.
  #
  # This module allows you to define autoloads based on
  # Rails conventions (i.e. no need to define the path
  # it is automatically guessed based on the filename)
  # and also define a set of constants that needs to be
  # eager loaded:
  #
  #   module MyLib
  #     extend ActiveSupport::Autoload
  #
  #     autoload :Model
  #
  #     eager_autoload do
  #       autoload :Cache
  #     end
  #   end
  #
  # Then your library can be eager loaded by simply calling:
  #
  #   MyLib.eager_load!
  module Autoload
    def self.extended: (untyped base) -> untyped

    def autoload: (untyped const_name, ?untyped path) -> untyped

    def autoload_under: (untyped path) { () -> untyped } -> untyped

    def autoload_at: (untyped path) { () -> untyped } -> untyped

    def eager_autoload: () { () -> untyped } -> untyped

    def eager_load!: () -> untyped

    def autoloads: () -> untyped
  end
end

module ActiveSupport
  module Dependencies
    # nodoc:
    # nodoc:
    class Interlock
      def initialize: () -> untyped

      def loading: () { () -> untyped } -> untyped

      def unloading: () { () -> untyped } -> untyped

      def start_unloading: () -> untyped

      def done_unloading: () -> untyped

      def start_running: () -> untyped

      def done_running: () -> untyped

      def running: () { () -> untyped } -> untyped

      def permit_concurrent_loads: () { () -> untyped } -> untyped

      def raw_state: () { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Dependencies
    module ZeitwerkIntegration
      # :nodoc: all
      module Decorations
        def clear: () -> untyped

        def constantize: (untyped cpath) -> untyped

        def safe_constantize: (untyped cpath) -> untyped

        def autoloaded_constants: () -> untyped

        def autoloaded?: (untyped object) -> untyped

        def verbose=: (untyped verbose) -> untyped

        def unhook!: () -> :no_op
      end

      module RequireDependency
        def require_dependency: (untyped filename) -> untyped
      end

      module Inflector
        def self.camelize: (untyped basename, untyped _abspath) -> untyped

        def self.inflect: (untyped overrides) -> untyped
      end

      def self.take_over: (enable_reloading: untyped enable_reloading) -> untyped

      private

      def self.setup_autoloaders: (untyped enable_reloading) -> untyped

      def self.autoload_once?: (untyped autoload_path) -> untyped

      def self.eager_load?: (untyped autoload_path) -> untyped

      def self.freeze_paths: () -> untyped

      def self.decorate_dependencies: () -> untyped
    end
  end
end

module ActiveSupport
  module Dependencies
    # nodoc:
    # nodoc:
    extend ::ActiveSupport::Dependencies

    UNBOUND_METHOD_MODULE_NAME: untyped

    # Execute the supplied block without interference from any
    # concurrent loads.
    def self.run_interlock: () { () -> untyped } -> untyped

    # Execute the supplied block while holding an exclusive lock,
    # preventing any other thread from being inside a #run_interlock
    # block at the same time.
    def self.load_interlock: () { () -> untyped } -> untyped

    # Execute the supplied block while holding an exclusive lock,
    # preventing any other thread from being inside a #run_interlock
    # block at the same time.
    def self.unload_interlock: () { () -> untyped } -> untyped

    # The WatchStack keeps a stack of the modules being watched as files are
    # loaded. If a file in the process of being loaded (parent.rb) triggers the
    # load of another file (child.rb) the stack will ensure that child.rb
    # handles the new constants.
    #
    # If child.rb is being autoloaded, its constants will be added to
    # autoloaded_constants. If it was being required, they will be discarded.
    #
    # This is handled by walking back up the watch stack and adding the constants
    # found by child.rb to the list of original constants in parent.rb.
    class WatchStack
      include Enumerable[untyped]

      attr_reader watching: untyped

      def initialize: () -> untyped

      def each: () { (untyped) -> untyped } -> untyped

      def watching?: () -> untyped

      # Returns a list of new constants found since the last call to
      # <tt>watch_namespaces</tt>.
      def new_constants: () -> untyped

      # Add a set of modules to the watch stack, remembering the initial
      # constants.
      def watch_namespaces: (untyped namespaces) -> untyped

      private

      def pop_modules: (untyped modules) -> untyped
    end

    module ModuleConstMissing
      # Module includes this module.
      # nodoc:
      def self.append_features: (untyped base) -> (nil | untyped)

      def self.exclude_from: (untyped base) -> untyped

      def self.include_into: (untyped base) -> untyped

      def const_missing: (untyped const_name) -> untyped

      # We assume that the name of the module reflects the nesting
      # (unless it can be proven that is not the case) and the path to the file
      # that defines the constant. Anonymous modules cannot follow these
      # conventions and therefore we assume that the user wants to refer to a
      # top-level constant.
      def guess_for_anonymous: (untyped const_name) -> untyped

      def unloadable: (?untyped const_desc) -> untyped
    end

    module Loadable
      # Object includes this module.
      # nodoc:
      def self.exclude_from: (untyped base) -> untyped

      def self.include_into: (untyped base) -> untyped

      def require_or_load: (untyped file_name) -> untyped

      # Interprets a file using <tt>mechanism</tt> and marks its defined
      # constants as autoloaded. <tt>file_name</tt> can be either a string or
      # respond to <tt>to_path</tt>.
      #
      # Use this method in code that absolutely needs a certain constant to be
      # defined at that point. A typical use case is to make constant name
      # resolution deterministic for constants with the same relative name in
      # different namespaces whose evaluation would depend on load order
      # otherwise.
      def require_dependency: (untyped file_name, ?::String message) -> untyped

      def load_dependency: (untyped file) { () -> untyped } -> untyped

      # Mark the given constant as unloadable. Unloadable constants are removed
      # each time dependencies are cleared.
      #
      # Note that marking a constant for unloading need only be done once. Setup
      # or init scripts may list each unloadable constant that may need unloading;
      # each constant will be removed for every subsequent clear, as opposed to
      # for the first clear.
      #
      # The provided constant descriptor may be a (non-anonymous) module or class,
      # or a qualified constant name as a string or symbol.
      #
      # Returns +true+ if the constant was not previously marked for unloading,
      # +false+ otherwise.
      def unloadable: (untyped const_desc) -> untyped

      private

      def load: (untyped file, ?bool wrap) -> untyped

      def require: (untyped file) -> untyped
    end

    module Blamable
      # Exception file-blaming.
      # nodoc:
      def blame_file!: (untyped file) -> untyped

      def blamed_files: () -> untyped

      def describe_blame: () -> (nil | ::String)

      def copy_blame!: (untyped exc) -> untyped
    end

    def hook!: () -> untyped

    def unhook!: () -> untyped

    def load?: () -> untyped

    def depend_on: (untyped file_name, ?::String message) -> untyped

    def clear: () -> untyped

    def require_or_load: (untyped file_name, ?untyped? const_path) -> (nil | untyped)

    # Is the provided constant path defined?
    def qualified_const_defined?: (untyped path) -> untyped

    # Given +path+, a filesystem path to a ruby file, return an array of
    # constant paths which would cause Dependencies to attempt to load this
    # file.
    def loadable_constants_for_path: (untyped path, ?untyped bases) -> untyped

    # Search for a file in autoload_paths matching the provided suffix.
    def search_for_file: (untyped path_suffix) -> (untyped | nil)

    # Does the provided path_suffix correspond to an autoloadable module?
    # Instead of returning a boolean, the autoload base for this module is
    # returned.
    def autoloadable_module?: (untyped path_suffix) -> (untyped | nil)

    def load_once_path?: (untyped path) -> untyped

    # Attempt to autoload the provided module name by searching for a directory
    # matching the expected path suffix. If found, the module is created and
    # assigned to +into+'s constants with the name +const_name+. Provided that
    # the directory was loaded from a reloadable base path, it is added to the
    # set of constants that are to be unloaded.
    def autoload_module!: (untyped into, untyped const_name, untyped qualified_name, untyped path_suffix) -> (nil | untyped)

    # Load the file at the provided path. +const_paths+ is a set of qualified
    # constant names. When loading the file, Dependencies will watch for the
    # addition of these constants. Each that is defined will be marked as
    # autoloaded, and will be removed when Dependencies.clear is next called.
    #
    # If the second parameter is left off, then Dependencies will construct a
    # set of names that the file at +path+ may define. See
    # +loadable_constants_for_path+ for more details.
    def load_file: (untyped path, ?untyped const_paths) -> untyped

    # Returns the constant path for the provided parent and constant name.
    def qualified_name_for: (untyped mod, untyped name) -> untyped

    # Load the constant named +const_name+ which is missing from +from_mod+. If
    # it is not possible to load the constant into from_mod, try its parent
    # module using +const_missing+.
    def load_missing_constant: (untyped from_mod, untyped const_name) -> untyped

    # Remove the constants that have been autoloaded, and those that have been
    # marked for unloading. Before each constant is removed a callback is sent
    # to its class/module if it implements +before_remove_const+.
    #
    # The callback implementation should be restricted to cleaning up caches, etc.
    # as the environment will be in an inconsistent state, e.g. other constants
    # may have already been unloaded and not accessible.
    def remove_unloadable_constants!: () -> untyped

    class ClassCache
      def initialize: () -> untyped

      def empty?: () -> untyped

      def key?: (untyped key) -> untyped

      def get: (untyped key) -> untyped

      alias [] get

      def safe_get: (untyped key) -> untyped

      def store: (untyped klass) -> untyped

      def clear!: () -> untyped
    end

    Reference: untyped

    # Store a reference to a class +klass+.
    def reference: (untyped klass) -> untyped

    # Get the reference for class named +name+.
    # Raises an exception if referenced class does not exist.
    def constantize: (untyped name) -> untyped

    # Get the reference for class named +name+ if one exists.
    # Otherwise returns +nil+.
    def safe_constantize: (untyped name) -> untyped

    # Determine if the given constant has been automatically loaded.
    def autoloaded?: (untyped desc) -> (::FalseClass | untyped)

    # Will the provided constant descriptor be unloaded?
    def will_unload?: (untyped const_desc) -> untyped

    # Mark the provided constant name for unloading. This constant will be
    # unloaded on each request, not just the next one.
    def mark_for_unload: (untyped const_desc) -> untyped

    # Run the provided block and detect the new constants that were loaded during
    # its execution. Constants may only be regarded as 'new' once -- so if the
    # block calls +new_constants_in+ again, then the constants defined within the
    # inner call will not be reported in this one.
    #
    # If the provided block does not run to completion, and instead raises an
    # exception, any new constants are regarded as being only partially defined
    # and will be removed immediately.
    def new_constants_in: (*untyped descs) { () -> untyped } -> untyped

    def to_constant_name: (untyped desc) -> untyped

    def remove_constant: (untyped const) -> (nil | untyped)

    def log: (untyped message) -> untyped

    private

    # Returns the original name of a class or module even if `name` has been
    # overridden.
    def real_mod_name: (untyped mod) -> untyped
  end
end

module ActiveSupport
  # Raised when <tt>ActiveSupport::Deprecation::Behavior#behavior</tt> is set with <tt>:raise</tt>.
  # You would set <tt>:raise</tt>, as a behavior to raise errors and proactively report exceptions from deprecations.
  class DeprecationException < StandardError
  end

  class Deprecation
    # Default warning behaviors per Rails.env.
    DEFAULT_BEHAVIORS: ::Hash[untyped, untyped]

    # Behavior module allows to determine how to display deprecation messages.
    # You can create a custom behavior or set any from the +DEFAULT_BEHAVIORS+
    # constant. Available behaviors are:
    #
    # [+raise+]   Raise <tt>ActiveSupport::DeprecationException</tt>.
    # [+stderr+]  Log all deprecation warnings to +$stderr+.
    # [+log+]     Log all deprecation warnings to +Rails.logger+.
    # [+notify+]  Use +ActiveSupport::Notifications+ to notify +deprecation.rails+.
    # [+silence+] Do nothing.
    #
    # Setting behaviors only affects deprecations that happen after boot time.
    # For more information you can read the documentation of the +behavior=+ method.
    module Behavior
      # Whether to print a backtrace along with the warning.
      attr_accessor debug: untyped

      # Returns the current behavior or if one isn't set, defaults to +:stderr+.
      def behavior: () -> untyped

      # Sets the behavior to the specified value. Can be a single value, array,
      # or an object that responds to +call+.
      #
      # Available behaviors:
      #
      # [+raise+]   Raise <tt>ActiveSupport::DeprecationException</tt>.
      # [+stderr+]  Log all deprecation warnings to +$stderr+.
      # [+log+]     Log all deprecation warnings to +Rails.logger+.
      # [+notify+]  Use +ActiveSupport::Notifications+ to notify +deprecation.rails+.
      # [+silence+] Do nothing.
      #
      # Setting behaviors only affects deprecations that happen after boot time.
      # Deprecation warnings raised by gems are not affected by this setting
      # because they happen before Rails boots up.
      #
      #   ActiveSupport::Deprecation.behavior = :stderr
      #   ActiveSupport::Deprecation.behavior = [:stderr, :log]
      #   ActiveSupport::Deprecation.behavior = MyCustomHandler
      #   ActiveSupport::Deprecation.behavior = ->(message, callstack, deprecation_horizon, gem_name) {
      #     # custom stuff
      #   }
      def behavior=: (untyped behavior) -> untyped

      private

      def arity_coerce: (untyped behavior) -> untyped
    end
  end
end

module ActiveSupport
  class Deprecation
    # DeprecatedConstantAccessor transforms a constant into a deprecated one by
    # hooking +const_missing+.
    #
    # It takes the names of an old (deprecated) constant and of a new constant
    # (both in string form) and optionally a deprecator. The deprecator defaults
    # to +ActiveSupport::Deprecator+ if none is specified.
    #
    # The deprecated constant now returns the same object as the new one rather
    # than a proxy object, so it can be used transparently in +rescue+ blocks
    # etc.
    #
    #   PLANETS = %w(mercury venus earth mars jupiter saturn uranus neptune pluto)
    #
    #   # (In a later update, the original implementation of `PLANETS` has been removed.)
    #
    #   PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune)
    #   include ActiveSupport::Deprecation::DeprecatedConstantAccessor
    #   deprecate_constant 'PLANETS', 'PLANETS_POST_2006'
    #
    #   PLANETS.map { |planet| planet.capitalize }
    #   # => DEPRECATION WARNING: PLANETS is deprecated! Use PLANETS_POST_2006 instead.
    #        (Backtrace information(trim non-ascii characters))
    #        ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
    module DeprecatedConstantAccessor
      def self.included: (untyped base) -> untyped
    end
  end
end

module ActiveSupport
  class Deprecation
    module InstanceDelegator
      # :nodoc:
      def self.included: (untyped base) -> untyped

      module ClassMethods
        # :nodoc:
        def include: (untyped included_module) -> untyped

        def method_added: (untyped method_name) -> untyped
      end

      module OverrideDelegators
        # :nodoc:
        def warn: (?untyped? message, ?untyped? callstack) -> untyped

        def deprecation_warning: (untyped deprecated_method_name, ?untyped? message, ?untyped? caller_backtrace) -> untyped
      end
    end
  end
end

module ActiveSupport
  class Deprecation
    module MethodWrapper
      # Declare that a method has been deprecated.
      #
      #   class Fred
      #     def aaa; end
      #     def bbb; end
      #     def ccc; end
      #     def ddd; end
      #     def eee; end
      #   end
      #
      # Using the default deprecator:
      #   ActiveSupport::Deprecation.deprecate_methods(Fred, :aaa, bbb: :zzz, ccc: 'use Bar#ccc instead')
      #   # => Fred
      #
      #   Fred.new.aaa
      #   # DEPRECATION WARNING: aaa is deprecated and will be removed from Rails 5.1. (called from irb_binding at (irb):10)
      #   # => nil
      #
      #   Fred.new.bbb
      #   # DEPRECATION WARNING: bbb is deprecated and will be removed from Rails 5.1 (use zzz instead). (called from irb_binding at (irb):11)
      #   # => nil
      #
      #   Fred.new.ccc
      #   # DEPRECATION WARNING: ccc is deprecated and will be removed from Rails 5.1 (use Bar#ccc instead). (called from irb_binding at (irb):12)
      #   # => nil
      #
      # Passing in a custom deprecator:
      #   custom_deprecator = ActiveSupport::Deprecation.new('next-release', 'MyGem')
      #   ActiveSupport::Deprecation.deprecate_methods(Fred, ddd: :zzz, deprecator: custom_deprecator)
      #   # => [:ddd]
      #
      #   Fred.new.ddd
      #   DEPRECATION WARNING: ddd is deprecated and will be removed from MyGem next-release (use zzz instead). (called from irb_binding at (irb):15)
      #   # => nil
      #
      # Using a custom deprecator directly:
      #   custom_deprecator = ActiveSupport::Deprecation.new('next-release', 'MyGem')
      #   custom_deprecator.deprecate_methods(Fred, eee: :zzz)
      #   # => [:eee]
      #
      #   Fred.new.eee
      #   DEPRECATION WARNING: eee is deprecated and will be removed from MyGem next-release (use zzz instead). (called from irb_binding at (irb):18)
      #   # => nil
      def deprecate_methods: (untyped target_module, *untyped method_names) -> untyped
    end
  end
end

module ActiveSupport
  class Deprecation
    class DeprecationProxy
      # nodoc:
      def self.new: (*untyped args) { () -> untyped } -> untyped

      # Don't give a deprecation warning on inspect since test/unit and error
      # logs rely on it for diagnostics.
      def inspect: () -> untyped

      private

      def method_missing: (untyped called, *untyped args) { () -> untyped } -> untyped
    end

    # DeprecatedObjectProxy transforms an object into a deprecated one. It
    # takes an object, a deprecation message and optionally a deprecator. The
    # deprecator defaults to +ActiveSupport::Deprecator+ if none is specified.
    #
    #   deprecated_object = ActiveSupport::Deprecation::DeprecatedObjectProxy.new(Object.new, "This object is now deprecated")
    #   # => #<Object:0x007fb9b34c34b0>
    #
    #   deprecated_object.to_s
    #   DEPRECATION WARNING: This object is now deprecated.
    #   (Backtrace)
    #   # => "#<Object:0x007fb9b34c34b0>"
    class DeprecatedObjectProxy < DeprecationProxy
      def initialize: (untyped object, untyped message, ?untyped deprecator) -> untyped

      private

      def target: () -> untyped

      def warn: (untyped callstack, untyped called, untyped args) -> untyped
    end

    # DeprecatedInstanceVariableProxy transforms an instance variable into a
    # deprecated one. It takes an instance of a class, a method on that class
    # and an instance variable. It optionally takes a deprecator as the last
    # argument. The deprecator defaults to +ActiveSupport::Deprecator+ if none
    # is specified.
    #
    #   class Example
    #     def initialize
    #       @request = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(self, :request, :@request)
    #       @_request = :special_request
    #     end
    #
    #     def request
    #       @_request
    #     end
    #
    #     def old_request
    #       @request
    #     end
    #   end
    #
    #   example = Example.new
    #   # => #<Example:0x007fb9b31090b8 @_request=:special_request, @request=:special_request>
    #
    #   example.old_request.to_s
    #   # => DEPRECATION WARNING: @request is deprecated! Call request.to_s instead of
    #      @request.to_s
    #      (Backtrace information(trim non-ascii characters))
    #      "special_request"
    #
    #   example.request.to_s
    #   # => "special_request"
    class DeprecatedInstanceVariableProxy < DeprecationProxy
      def initialize: (untyped `instance`, untyped method, ?::String var, ?untyped deprecator) -> untyped

      private

      def target: () -> untyped

      def warn: (untyped callstack, untyped called, untyped args) -> untyped
    end

    # DeprecatedConstantProxy transforms a constant into a deprecated one. It
    # takes the names of an old (deprecated) constant and of a new constant
    # (both in string form) and optionally a deprecator. The deprecator defaults
    # to +ActiveSupport::Deprecator+ if none is specified. The deprecated constant
    # now returns the value of the new one.
    #
    #   PLANETS = %w(mercury venus earth mars jupiter saturn uranus neptune pluto)
    #
    #   # (In a later update, the original implementation of `PLANETS` has been removed.)
    #
    #   PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune)
    #   PLANETS = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('PLANETS', 'PLANETS_POST_2006')
    #
    #   PLANETS.map { |planet| planet.capitalize }
    #   # => DEPRECATION WARNING: PLANETS is deprecated! Use PLANETS_POST_2006 instead.
    #        (Backtrace information(trim non-ascii characters))
    #        ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
    class DeprecatedConstantProxy < Module
      def self.new: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped

      def initialize: (untyped old_const, untyped new_const, ?untyped deprecator, ?message: ::String message) -> untyped

      # Don't give a deprecation warning on inspect since test/unit and error
      # logs rely on it for diagnostics.
      def inspect: () -> untyped

      # Returns the class of the new constant.
      #
      #   PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune)
      #   PLANETS = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('PLANETS', 'PLANETS_POST_2006')
      #   PLANETS.class # => Array
      def class: () -> untyped

      private

      def target: () -> untyped

      def const_missing: (untyped name) -> untyped

      def method_missing: (untyped called, *untyped args) { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  class Deprecation
    module Reporting
      # Whether to print a message (silent mode)
      attr_accessor silenced: untyped

      # Name of gem where method is deprecated
      attr_accessor gem_name: untyped

      # Outputs a deprecation warning to the output configured by
      # <tt>ActiveSupport::Deprecation.behavior</tt>.
      #
      #   ActiveSupport::Deprecation.warn('something broke!')
      #   # => "DEPRECATION WARNING: something broke! (called from your_code.rb:1)"
      def warn: (?untyped? message, ?untyped? callstack) -> (nil | untyped)

      # Silence deprecation warnings within the block.
      #
      #   ActiveSupport::Deprecation.warn('something broke!')
      #   # => "DEPRECATION WARNING: something broke! (called from your_code.rb:1)"
      #
      #   ActiveSupport::Deprecation.silence do
      #     ActiveSupport::Deprecation.warn('something broke!')
      #   end
      #   # => nil
      def silence: () { () -> untyped } -> untyped

      def deprecation_warning: (untyped deprecated_method_name, ?untyped? message, ?untyped? caller_backtrace) -> untyped

      private

      # Outputs a deprecation warning message
      #
      #   deprecated_method_warning(:method_name)
      #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon}"
      #   deprecated_method_warning(:method_name, :another_method)
      #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon} (use another_method instead)"
      #   deprecated_method_warning(:method_name, "Optional message")
      #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon} (Optional message)"
      def deprecated_method_warning: (untyped method_name, ?untyped? message) -> untyped

      def deprecation_message: (untyped callstack, ?untyped? message) -> ::String

      def deprecation_caller_message: (untyped callstack) -> untyped

      def extract_callstack: (untyped callstack) -> (untyped | ::Array[untyped])

      def _extract_callstack: (untyped callstack) -> untyped

      RAILS_GEM_ROOT: untyped

      def ignored_callstack: (untyped path) -> untyped
    end
  end
end

module ActiveSupport
  # \Deprecation specifies the API used by Rails to deprecate methods, instance
  # variables, objects and constants.
  class Deprecation
    include Singleton

    include InstanceDelegator

    include Behavior

    include Reporting

    include MethodWrapper

    # The version number in which the deprecated behavior will be removed, by default.
    attr_accessor deprecation_horizon: untyped

    # It accepts two parameters on initialization. The first is a version of library
    # and the second is a library name.
    #
    #   ActiveSupport::Deprecation.new('2.0', 'MyLibrary')
    def initialize: (?::String deprecation_horizon, ?::String gem_name) -> untyped
  end
end

module ActiveSupport
  # This module provides an internal implementation to track descendants
  # which is faster than iterating through ObjectSpace.
  module DescendantsTracker
    def self.direct_descendants: (untyped klass) -> untyped

    def self.descendants: (untyped klass) -> untyped

    def self.clear: () -> untyped

    # This is the only method that is not thread safe, but is only ever called
    # during the eager loading phase.
    def self.store_inherited: (untyped klass, untyped descendant) -> untyped

    private

    def self.accumulate_descendants: (untyped klass, untyped acc) -> untyped

    public

    def inherited: (untyped base) -> untyped

    def direct_descendants: () -> untyped

    def descendants: () -> untyped

    class DescendantsArray
      # DescendantsArray is an array that contains weak references to classes.
      # :nodoc:
      include Enumerable[untyped]

      def initialize: () -> untyped

      def initialize_copy: (untyped orig) -> untyped

      def <<: (untyped klass) -> untyped

      def each: () { (untyped) -> untyped } -> untyped

      def refs_size: () -> untyped

      def cleanup!: () -> untyped

      def reject!: () { (untyped) -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  class Digest
    def self.hash_digest_class: () -> untyped

    def self.hash_digest_class=: (untyped klass) -> untyped

    def self.hexdigest: (untyped arg) -> untyped
  end
end

module ActiveSupport
  class Duration
    class ISO8601Parser
      # Parses a string formatted according to ISO 8601 Duration into the hash.
      #
      # See {ISO 8601}[https://en.wikipedia.org/wiki/ISO_8601#Durations] for more information.
      #
      # This parser allows negative parts to be present in pattern.
      # :nodoc:
      class ParsingError < ::ArgumentError
      end

      PERIOD_OR_COMMA: untyped

      PERIOD: ::String

      COMMA: ::String

      SIGN_MARKER: untyped

      DATE_MARKER: untyped

      TIME_MARKER: untyped

      DATE_COMPONENT: untyped

      TIME_COMPONENT: untyped

      DATE_TO_PART: ::Hash[untyped, untyped]

      TIME_TO_PART: ::Hash[untyped, untyped]

      DATE_COMPONENTS: ::Array[untyped]

      TIME_COMPONENTS: ::Array[untyped]

      attr_reader parts: untyped

      attr_reader scanner: untyped

      attr_accessor mode: untyped

      attr_accessor sign: untyped

      def initialize: (untyped string) -> untyped

      def parse!: () -> untyped

      private

      def finished?: () -> untyped

      # Parses number which can be a float with either comma or period.
      def number: () -> untyped

      def scan: (untyped pattern) -> untyped

      def raise_parsing_error: (?untyped? reason) -> untyped

      # Checks for various semantic errors as stated in ISO 8601 standard.
      def validate!: () -> ::TrueClass
    end
  end
end

module ActiveSupport
  class Duration
    class ISO8601Serializer
      # Serializes duration to string according to ISO 8601 Duration format.
      # :nodoc:
      def initialize: (untyped duration, ?precision: untyped? precision) -> untyped

      # Builds and returns output string.
      def serialize: () -> ("PT0S" | ::String)

      private

      # Return pair of duration's parts and whole duration sign.
      # Parts are summarized (as they can become repetitive due to addition, etc).
      # Zero parts are removed as not significant.
      # If all parts are negative it will negate all of them and return minus as a sign.
      def normalize: () -> ::Array[untyped]
    end
  end
end

module ActiveSupport
  # Provides accurate date and time measurements using Date#advance and
  # Time#advance, respectively. It mainly supports the methods on Numeric.
  #
  #   1.month.ago       # equivalent to Time.now.advance(months: -1)
  class Duration
    class Scalar < Numeric
      # nodoc:
      attr_reader value: untyped

      def initialize: (untyped value) -> untyped

      def coerce: (untyped other) -> ::Array[Scalar | untyped]

      def -@: () -> Scalar

      def <=>: (untyped other) -> untyped

      def +: (untyped other) -> untyped

      def -: (untyped other) -> untyped

      def *: (untyped other) -> untyped

      def /: (untyped other) -> untyped

      def %: (untyped other) -> untyped

      private

      def calculate: (untyped op, untyped other) -> untyped

      def raise_type_error: (untyped other) -> untyped
    end

    SECONDS_PER_MINUTE: ::Integer

    SECONDS_PER_HOUR: ::Integer

    SECONDS_PER_DAY: ::Integer

    SECONDS_PER_WEEK: ::Integer

    SECONDS_PER_MONTH: ::Integer

    SECONDS_PER_YEAR: ::Integer

    PARTS_IN_SECONDS: untyped

    PARTS: untyped

    attr_accessor value: untyped

    attr_accessor parts: untyped

    # Creates a new Duration from string formatted according to ISO 8601 Duration.
    #
    # See {ISO 8601}[https://en.wikipedia.org/wiki/ISO_8601#Durations] for more information.
    # This method allows negative parts to be present in pattern.
    # If invalid string is provided, it will raise +ActiveSupport::Duration::ISO8601Parser::ParsingError+.
    def self.parse: (untyped iso8601duration) -> untyped

    def self.===: (untyped other) -> untyped

    def self.seconds: (untyped value) -> untyped

    def self.minutes: (untyped value) -> untyped

    def self.hours: (untyped value) -> untyped

    def self.days: (untyped value) -> untyped

    def self.weeks: (untyped value) -> untyped

    def self.months: (untyped value) -> untyped

    def self.years: (untyped value) -> untyped

    # Creates a new Duration from a seconds value that is converted
    # to the individual parts:
    #
    #   ActiveSupport::Duration.build(31556952).parts # => {:years=>1}
    #   ActiveSupport::Duration.build(2716146).parts  # => {:months=>1, :days=>1}
    #
    def self.build: (untyped value) -> untyped

    private

    def self.calculate_total_seconds: (untyped parts) -> untyped

    public

    def initialize: (untyped value, untyped parts) -> untyped

    def coerce: (untyped other) -> untyped

    # Compares one Duration with another or a Numeric to this Duration.
    # Numeric values are treated as seconds.
    def <=>: (untyped other) -> untyped

    # Adds another Duration or a Numeric to this Duration. Numeric values
    # are treated as seconds.
    def +: (untyped other) -> untyped

    # Subtracts another Duration or a Numeric from this Duration. Numeric
    # values are treated as seconds.
    def -: (untyped other) -> untyped

    # Multiplies this Duration by a Numeric and returns a new Duration.
    def *: (untyped other) -> untyped

    # Divides this Duration by a Numeric and returns a new Duration.
    def /: (untyped other) -> untyped

    # Returns the modulo of this Duration by another Duration or Numeric.
    # Numeric values are treated as seconds.
    def %: (untyped other) -> untyped

    def -@: () -> Duration

    def is_a?: (untyped klass) -> untyped

    alias kind_of? is_a?

    def instance_of?: (untyped klass) -> untyped

    # Returns +true+ if +other+ is also a Duration instance with the
    # same +value+, or if <tt>other == value</tt>.
    def ==: (untyped other) -> untyped

    # Returns the amount of seconds a duration covers as a string.
    # For more information check to_i method.
    #
    #   1.day.to_s # => "86400"
    def to_s: () -> untyped

    # Returns the number of seconds that this Duration represents.
    #
    #   1.minute.to_i   # => 60
    #   1.hour.to_i     # => 3600
    #   1.day.to_i      # => 86400
    #
    # Note that this conversion makes some assumptions about the
    # duration of some periods, e.g. months are always 1/12 of year
    # and years are 365.2425 days:
    #
    #   # equivalent to (1.year / 12).to_i
    #   1.month.to_i    # => 2629746
    #
    #   # equivalent to 365.2425.days.to_i
    #   1.year.to_i     # => 31556952
    #
    # In such cases, Ruby's core
    # Date[https://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html] and
    # Time[https://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html] should be used for precision
    # date and time arithmetic.
    def to_i: () -> untyped

    # Returns +true+ if +other+ is also a Duration instance, which has the
    # same parts as this one.
    def eql?: (untyped other) -> untyped

    def hash: () -> untyped

    # Calculates a new Time or Date that is as far in the future
    # as this Duration represents.
    def since: (?untyped time) -> ::ActiveSupport::TimeWithZone

    alias from_now since

    alias after since

    # Calculates a new Time or Date that is as far in the past
    # as this Duration represents.
    def ago: (?untyped time) -> ::ActiveSupport::TimeWithZone

    alias until ago

    alias before ago

    def inspect: () -> (::String | untyped)

    def as_json: (?untyped? options) -> untyped

    def init_with: (untyped coder) -> untyped

    def encode_with: (untyped coder) -> untyped

    # Build ISO 8601 Duration string for this duration.
    # The +precision+ parameter can be used to limit seconds' precision of duration.
    def iso8601: (?precision: untyped? precision) -> untyped

    private

    def sum: (untyped sign, ?untyped time) -> untyped

    def respond_to_missing?: (untyped method, untyped _) -> untyped

    def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped

    def raise_type_error: (untyped other) -> untyped
  end
end

module ActiveSupport
  class EncryptedConfiguration < EncryptedFile
    def initialize: (raise_if_missing_key: untyped raise_if_missing_key, env_key: untyped env_key, key_path: untyped key_path, config_path: untyped config_path) -> untyped

    # Allow a config to be started without a file present
    def read: () -> untyped

    def write: (untyped contents) -> untyped

    def config: () -> untyped

    private

    def options: () -> untyped

    def deserialize: (untyped config) -> untyped
  end
end

module ActiveSupport
  class EncryptedFile
    class MissingContentError < RuntimeError
      def initialize: (untyped content_path) -> untyped
    end

    class MissingKeyError < RuntimeError
      def initialize: (env_key: untyped env_key, key_path: untyped key_path) -> untyped
    end

    CIPHER: ::String

    def self.generate_key: () -> untyped

    attr_reader content_path: untyped

    attr_reader key_path: untyped

    attr_reader env_key: untyped

    attr_reader raise_if_missing_key: untyped

    def initialize: (raise_if_missing_key: untyped raise_if_missing_key, env_key: untyped env_key, key_path: untyped key_path, content_path: untyped content_path) -> untyped

    def key: () -> untyped

    def read: () -> untyped

    def write: (untyped contents) -> untyped

    def change: () { () -> untyped } -> untyped

    private

    def writing: (untyped contents) { (untyped) -> untyped } -> untyped

    def encrypt: (untyped contents) -> untyped

    def decrypt: (untyped contents) -> untyped

    def encryptor: () -> untyped

    def read_env_key: () -> untyped

    def read_key_file: () -> untyped

    def handle_missing_key: () -> untyped
  end
end

module ActiveSupport
  class EventedFileUpdateChecker
    # Allows you to "listen" to changes in a file system.
    # The evented file updater does not hit disk when checking for updates
    # instead it uses platform specific file system events to trigger a change
    # in state.
    #
    # The file checker takes an array of files to watch or a hash specifying directories
    # and file extensions to watch. It also takes a block that is called when
    # EventedFileUpdateChecker#execute is run or when EventedFileUpdateChecker#execute_if_updated
    # is run and there have been changes to the file system.
    #
    # Note: Forking will cause the first call to `updated?` to return `true`.
    #
    # Example:
    #
    #     checker = ActiveSupport::EventedFileUpdateChecker.new(["/tmp/foo"]) { puts "changed" }
    #     checker.updated?
    #     # => false
    #     checker.execute_if_updated
    #     # => nil
    #
    #     FileUtils.touch("/tmp/foo")
    #
    #     checker.updated?
    #     # => true
    #     checker.execute_if_updated
    #     # => "changed"
    #
    # nodoc: all
    def initialize: (untyped files, ?::Hash[untyped, untyped] dirs) { () -> untyped } -> untyped

    def updated?: () -> untyped

    def execute: () -> untyped

    def execute_if_updated: () { () -> untyped } -> untyped

    private

    def boot!: () -> untyped

    def shutdown!: () -> untyped

    def normalize_dirs!: () -> untyped

    def changed: (untyped modified, untyped added, untyped removed) -> untyped

    def watching?: (untyped file) -> untyped

    def directories_to_watch: () -> untyped

    class PathHelper
      def xpath: (untyped path) -> untyped

      def normalize_extension: (untyped ext) -> untyped

      # Given a collection of Pathname objects returns the longest subpath
      # common to all of them, or +nil+ if there is none.
      def longest_common_subpath: (untyped paths) -> (nil | untyped)

      # Returns the deepest existing ascendant, which could be the argument itself.
      def existing_parent: (untyped dir) -> untyped

      # Filters out directories which are descendants of others in the collection (stable).
      def filter_out_descendants: (untyped dirs) -> untyped

      private

      def ascendant_of?: (untyped base, untyped other) -> untyped
    end
  end
end

module ActiveSupport
  class ExecutionWrapper
    include ActiveSupport::Callbacks

    Null: untyped

    def self.complete!: () -> nil

    def self.to_run: (*untyped args) { () -> untyped } -> untyped

    def self.to_complete: (*untyped args) { () -> untyped } -> untyped

    class RunHook[T] < ::Struct[T]
      attr_accessor hook(): untyped

      # :nodoc:
      def before: (untyped target) -> untyped
    end

    class CompleteHook[T] < ::Struct[T]
      attr_accessor hook(): untyped

      # :nodoc:
      def before: (untyped target) -> untyped

      alias after before
    end

    # Register an object to be invoked during both the +run+ and
    # +complete+ steps.
    #
    # +hook.complete+ will be passed the value returned from +hook.run+,
    # and will only be invoked if +run+ has previously been called.
    # (Mostly, this means it won't be invoked if an exception occurs in
    # a preceding +to_run+ block; all ordinary +to_complete+ blocks are
    # invoked in that situation.)
    def self.register_hook: (untyped hook, ?outer: bool outer) -> untyped

    # Run this execution.
    #
    # Returns an instance, whose +complete!+ method *must* be invoked
    # after the work has been performed.
    #
    # Where possible, prefer +wrap+.
    def self.run!: () -> untyped

    # Perform the work in the supplied block as an execution.
    def self.wrap: () { () -> untyped } -> untyped

    # :nodoc:
    attr_accessor self.active: untyped

    def self.inherited: (untyped other) -> untyped

    def self.active?: () -> untyped

    def run!: () -> untyped

    # Complete this in-flight execution. This method *must* be called
    # exactly once on the result of any call to +run!+.
    #
    # Where possible, prefer +wrap+.
    def complete!: () -> untyped

    private

    def hook_state: () -> untyped
  end
end

module ActiveSupport
  class Executor < ExecutionWrapper
  end
end

module ActiveSupport
  # FileUpdateChecker specifies the API used by Rails to watch files
  # and control reloading. The API depends on four methods:
  #
  # * +initialize+ which expects two parameters and one block as
  #   described below.
  #
  # * +updated?+ which returns a boolean if there were updates in
  #   the filesystem or not.
  #
  # * +execute+ which executes the given block on initialization
  #   and updates the latest watched files and timestamp.
  #
  # * +execute_if_updated+ which just executes the block if it was updated.
  #
  # After initialization, a call to +execute_if_updated+ must execute
  # the block only if there was really a change in the filesystem.
  #
  # This class is used by Rails to reload the I18n framework whenever
  # they are changed upon a new request.
  #
  #   i18n_reloader = ActiveSupport::FileUpdateChecker.new(paths) do
  #     I18n.reload!
  #   end
  #
  #   ActiveSupport::Reloader.to_prepare do
  #     i18n_reloader.execute_if_updated
  #   end
  class FileUpdateChecker
    # It accepts two parameters on initialization. The first is an array
    # of files and the second is an optional hash of directories. The hash must
    # have directories as keys and the value is an array of extensions to be
    # watched under that directory.
    #
    # This method must also receive a block that will be called once a path
    # changes. The array of files and list of directories cannot be changed
    # after FileUpdateChecker has been initialized.
    def initialize: (untyped files, ?::Hash[untyped, untyped] dirs) { () -> untyped } -> untyped

    # Check if any of the entries were updated. If so, the watched and/or
    # updated_at values are cached until the block is executed via +execute+
    # or +execute_if_updated+.
    def updated?: () -> untyped

    # Executes the given block and updates the latest watched files and
    # timestamp.
    def execute: () -> untyped

    # Execute the block given if updated.
    def execute_if_updated: () { () -> untyped } -> untyped

    private

    def watched: () -> untyped

    def updated_at: (untyped paths) -> untyped

    # This method returns the maximum mtime of the files in +paths+, or +nil+
    # if the array is empty.
    #
    # Files with a mtime in the future are ignored. Such abnormal situation
    # can happen for example if the user changes the clock by hand. It is
    # healthy to consider this edge case because with mtimes in the future
    # reloading is not triggered.
    def max_mtime: (untyped paths) -> untyped

    def compile_glob: (untyped hash) -> (nil | ::String)

    def escape: (untyped key) -> untyped

    def compile_ext: (untyped array) -> (nil | ::String)
  end
end

module ActiveSupport
  # Returns the version of the currently loaded Active Support as a <tt>Gem::Version</tt>.
  def self.gem_version: () -> Gem::Version

  module VERSION
    MAJOR: ::Integer

    MINOR: ::Integer

    TINY: ::Integer

    PRE: ::String

    STRING: untyped
  end
end

module ActiveSupport
  # A convenient wrapper for the zlib standard library that allows
  # compression/decompression of strings with gzip.
  #
  #   gzip = ActiveSupport::Gzip.compress('compress me!')
  #   # => "\x1F\x8B\b\x00o\x8D\xCDO\x00\x03K\xCE\xCF-(J-.V\xC8MU\x04\x00R>n\x83\f\x00\x00\x00"
  #
  #   ActiveSupport::Gzip.decompress(gzip)
  #   # => "compress me!"
  module Gzip
    class Stream < StringIO
      def initialize: () -> untyped

      def close: () -> untyped
    end

    # Decompresses a gzipped string.
    def self.decompress: (untyped source) -> untyped

    # Compresses a string using gzip.
    def self.compress: (untyped source, ?untyped level, ?untyped strategy) -> untyped
  end
end

module ActiveSupport
  # Implements a hash where keys <tt>:foo</tt> and <tt>"foo"</tt> are considered
  # to be the same.
  #
  #   rgb = ActiveSupport::HashWithIndifferentAccess.new
  #
  #   rgb[:black] = '#000000'
  #   rgb[:black]  # => '#000000'
  #   rgb['black'] # => '#000000'
  #
  #   rgb['white'] = '#FFFFFF'
  #   rgb[:white]  # => '#FFFFFF'
  #   rgb['white'] # => '#FFFFFF'
  #
  # Internally symbols are mapped to strings when used as keys in the entire
  # writing interface (calling <tt>[]=</tt>, <tt>merge</tt>, etc). This
  # mapping belongs to the public interface. For example, given:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1)
  #
  # You are guaranteed that the key is returned as a string:
  #
  #   hash.keys # => ["a"]
  #
  # Technically other types of keys are accepted:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1)
  #   hash[0] = 0
  #   hash # => {"a"=>1, 0=>0}
  #
  # but this class is intended for use cases where strings or symbols are the
  # expected keys and it is convenient to understand both as the same. For
  # example the +params+ hash in Ruby on Rails.
  #
  # Note that core extensions define <tt>Hash#with_indifferent_access</tt>:
  #
  #   rgb = { black: '#000000', white: '#FFFFFF' }.with_indifferent_access
  #
  # which may be handy.
  #
  # To access this class outside of Rails, require the core extension with:
  #
  #   require "active_support/core_ext/hash/indifferent_access"
  #
  # which will, in turn, require this file.
  class HashWithIndifferentAccess[T, U] < Hash[T, U]
    # Returns +true+ so that <tt>Array#extract_options!</tt> finds members of
    # this class.
    def extractable_options?: () -> ::TrueClass

    def with_indifferent_access: () -> untyped

    def nested_under_indifferent_access: () -> untyped

    def initialize: (?::Hash[untyped, untyped] constructor) -> untyped

    def self.[]: (*untyped args) -> untyped

    alias regular_writer []=

    alias regular_update update

    # Assigns a new value to the hash:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash[:key] = 'value'
    #
    # This value can be later fetched using either +:key+ or <tt>'key'</tt>.
    def []=: (untyped key, untyped value) -> untyped

    alias store []=

    # Updates the receiver in-place, merging in the hash passed as argument:
    #
    #   hash_1 = ActiveSupport::HashWithIndifferentAccess.new
    #   hash_1[:key] = 'value'
    #
    #   hash_2 = ActiveSupport::HashWithIndifferentAccess.new
    #   hash_2[:key] = 'New Value!'
    #
    #   hash_1.update(hash_2) # => {"key"=>"New Value!"}
    #
    # The argument can be either an
    # <tt>ActiveSupport::HashWithIndifferentAccess</tt> or a regular +Hash+.
    # In either case the merge respects the semantics of indifferent access.
    #
    # If the argument is a regular hash with keys +:key+ and +"key"+ only one
    # of the values end up in the receiver, but which one is unspecified.
    #
    # When given a block, the value for duplicated keys will be determined
    # by the result of invoking the block with the duplicated key, the value
    # in the receiver, and the value in +other_hash+. The rules for duplicated
    # keys follow the semantics of indifferent access:
    #
    #   hash_1[:key] = 10
    #   hash_2['key'] = 12
    #   hash_1.update(hash_2) { |key, old, new| old + new } # => {"key"=>22}
    def update: (untyped other_hash) { (untyped, untyped, untyped) -> untyped } -> untyped

    alias merge! update

    # Checks the hash for a key matching the argument passed in:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash['key'] = 'value'
    #   hash.key?(:key)  # => true
    #   hash.key?('key') # => true
    def key?: (untyped key) -> untyped

    alias include? key?

    alias has_key? key?

    alias member? key?

    # Same as <tt>Hash#[]</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   counters = ActiveSupport::HashWithIndifferentAccess.new
    #   counters[:foo] = 1
    #
    #   counters['foo'] # => 1
    #   counters[:foo]  # => 1
    #   counters[:zoo]  # => nil
    def []: (untyped key) -> untyped

    # Same as <tt>Hash#assoc</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   counters = ActiveSupport::HashWithIndifferentAccess.new
    #   counters[:foo] = 1
    #
    #   counters.assoc('foo') # => ["foo", 1]
    #   counters.assoc(:foo)  # => ["foo", 1]
    #   counters.assoc(:zoo)  # => nil
    def assoc: (untyped key) -> untyped

    # Same as <tt>Hash#fetch</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   counters = ActiveSupport::HashWithIndifferentAccess.new
    #   counters[:foo] = 1
    #
    #   counters.fetch('foo')          # => 1
    #   counters.fetch(:bar, 0)        # => 0
    #   counters.fetch(:bar) { |key| 0 } # => 0
    #   counters.fetch(:zoo)           # => KeyError: key not found: "zoo"
    def fetch: (untyped key, *untyped extras) -> untyped

    # Same as <tt>Hash#dig</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   counters = ActiveSupport::HashWithIndifferentAccess.new
    #   counters[:foo] = { bar: 1 }
    #
    #   counters.dig('foo', 'bar')     # => 1
    #   counters.dig(:foo, :bar)       # => 1
    #   counters.dig(:zoo)             # => nil
    def dig: (*untyped args) -> untyped

    # Same as <tt>Hash#default</tt> where the key passed as argument can be
    # either a string or a symbol:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new(1)
    #   hash.default                   # => 1
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new { |hash, key| key }
    #   hash.default                   # => nil
    #   hash.default('foo')            # => 'foo'
    #   hash.default(:foo)             # => 'foo'
    def default: (*untyped args) -> untyped

    # Returns an array of the values at the specified indices:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash[:a] = 'x'
    #   hash[:b] = 'y'
    #   hash.values_at('a', 'b') # => ["x", "y"]
    def values_at: (*untyped keys) -> untyped

    # Returns an array of the values at the specified indices, but also
    # raises an exception when one of the keys can't be found.
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash[:a] = 'x'
    #   hash[:b] = 'y'
    #   hash.fetch_values('a', 'b') # => ["x", "y"]
    #   hash.fetch_values('a', 'c') { |key| 'z' } # => ["x", "z"]
    #   hash.fetch_values('a', 'c') # => KeyError: key not found: "c"
    def fetch_values: (*untyped indices) { () -> untyped } -> untyped

    # Returns a shallow copy of the hash.
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new({ a: { b: 'b' } })
    #   dup  = hash.dup
    #   dup[:a][:c] = 'c'
    #
    #   hash[:a][:c] # => "c"
    #   dup[:a][:c]  # => "c"
    def dup: () -> untyped

    # This method has the same semantics of +update+, except it does not
    # modify the receiver but rather returns a new hash with indifferent
    # access with the result of the merge.
    def merge: (untyped hash) { () -> untyped } -> untyped

    # Like +merge+ but the other way around: Merges the receiver into the
    # argument and returns a new hash with indifferent access as result:
    #
    #   hash = ActiveSupport::HashWithIndifferentAccess.new
    #   hash['a'] = nil
    #   hash.reverse_merge(a: 0, b: 1) # => {"a"=>nil, "b"=>1}
    def reverse_merge: (untyped other_hash) -> untyped

    alias with_defaults reverse_merge

    # Same semantics as +reverse_merge+ but modifies the receiver in-place.
    def reverse_merge!: (untyped other_hash) -> untyped

    alias with_defaults! reverse_merge!

    # Replaces the contents of this hash with other_hash.
    #
    #   h = { "a" => 100, "b" => 200 }
    #   h.replace({ "c" => 300, "d" => 400 }) # => {"c"=>300, "d"=>400}
    def replace: (untyped other_hash) -> untyped

    # Removes the specified key from the hash.
    def delete: (untyped key) -> untyped

    def except: (*untyped keys) -> untyped

    alias without except

    def stringify_keys!: () -> untyped

    def deep_stringify_keys!: () -> untyped

    def stringify_keys: () -> untyped

    def deep_stringify_keys: () -> untyped

    def symbolize_keys: () -> untyped

    alias to_options symbolize_keys

    def deep_symbolize_keys: () -> untyped

    def to_options!: () -> untyped

    def select: (*untyped args) { () -> untyped } -> untyped

    def reject: (*untyped args) { () -> untyped } -> untyped

    def transform_values: (*untyped args) { () -> untyped } -> untyped

    def transform_keys: (*untyped args) { () -> untyped } -> untyped

    def transform_keys!: () { (untyped) -> untyped } -> untyped

    def slice: (*untyped keys) -> untyped

    def slice!: (*untyped keys) -> untyped

    def compact: () -> untyped

    # Convert to a regular hash with string keys.
    def to_hash: () -> untyped

    private

    def convert_key: (untyped key) -> untyped

    def convert_value: (untyped value, ?::Hash[untyped, untyped] options) -> untyped

    def set_defaults: (untyped target) -> untyped
  end
end

# NOTE: HashWithIndifferentAccess and ActiveSupport::HashWithIndifferentAccess are the same object
#       but RBS doesn't have class alias syntax
class HashWithIndifferentAccess[T, U] < ActiveSupport::HashWithIndifferentAccess[T, U]
end

module I18n
  class Railtie < Rails::Railtie
    # Setup i18n configuration.
    def self.initialize_i18n: (untyped app) -> (nil | untyped)

    def self.include_fallbacks_module: () -> untyped

    def self.init_fallbacks: (untyped fallbacks) -> untyped

    def self.validate_fallbacks: (untyped fallbacks) -> untyped

    def self.watched_dirs_with_extensions: (untyped paths) -> untyped
  end
end

# -
# Defines the standard inflection rules. These are the starting point for
# new projects and are not considered complete. The current set of inflection
# rules is frozen. This means, we do not change them to become more complete.
# This is a safety measure to keep existing applications from breaking.
# +
module ActiveSupport
end

module ActiveSupport
  module Inflector
    extend ::ActiveSupport::Inflector

    # A singleton instance of this class is yielded by Inflector.inflections,
    # which can then be used to specify additional inflection rules. If passed
    # an optional locale, rules for other languages can be specified. The
    # default locale is <tt>:en</tt>. Only rules for English are provided.
    #
    #   ActiveSupport::Inflector.inflections(:en) do |inflect|
    #     inflect.plural /^(ox)$/i, '\1\2en'
    #     inflect.singular /^(ox)en/i, '\1'
    #
    #     inflect.irregular 'octopus', 'octopi'
    #
    #     inflect.uncountable 'equipment'
    #   end
    #
    # New rules are added at the top. So in the example above, the irregular
    # rule for octopus will now be the first of the pluralization and
    # singularization rules that is runs. This guarantees that your rules run
    # before any of the rules that may already have been loaded.
    class Inflections
      class Uncountables[T] < Array[T]
        def initialize: () -> untyped

        def delete: (untyped entry) -> untyped

        def <<: (*untyped word) -> untyped

        def add: (untyped words) -> untyped

        def uncountable?: (untyped str) -> untyped

        private

        def to_regex: (untyped string) -> ::Regexp
      end

      def self.instance: (?::Symbol locale) -> untyped

      attr_reader plurals: untyped

      attr_reader singulars: untyped

      attr_reader uncountables: untyped

      attr_reader humans: untyped

      attr_reader acronyms: untyped

      attr_reader acronyms_camelize_regex: untyped

      attr_reader acronyms_underscore_regex: untyped

      def initialize: () -> untyped

      def initialize_dup: (untyped orig) -> untyped

      # Specifies a new acronym. An acronym must be specified as it will appear
      # in a camelized string. An underscore string that contains the acronym
      # will retain the acronym when passed to +camelize+, +humanize+, or
      # +titleize+. A camelized string that contains the acronym will maintain
      # the acronym when titleized or humanized, and will convert the acronym
      # into a non-delimited single lowercase word when passed to +underscore+.
      #
      #   acronym 'HTML'
      #   titleize 'html'     # => 'HTML'
      #   camelize 'html'     # => 'HTML'
      #   underscore 'MyHTML' # => 'my_html'
      #
      # The acronym, however, must occur as a delimited unit and not be part of
      # another word for conversions to recognize it:
      #
      #   acronym 'HTTP'
      #   camelize 'my_http_delimited' # => 'MyHTTPDelimited'
      #   camelize 'https'             # => 'Https', not 'HTTPs'
      #   underscore 'HTTPS'           # => 'http_s', not 'https'
      #
      #   acronym 'HTTPS'
      #   camelize 'https'   # => 'HTTPS'
      #   underscore 'HTTPS' # => 'https'
      #
      # Note: Acronyms that are passed to +pluralize+ will no longer be
      # recognized, since the acronym will not occur as a delimited unit in the
      # pluralized result. To work around this, you must specify the pluralized
      # form as an acronym as well:
      #
      #    acronym 'API'
      #    camelize(pluralize('api')) # => 'Apis'
      #
      #    acronym 'APIs'
      #    camelize(pluralize('api')) # => 'APIs'
      #
      # +acronym+ may be used to specify any word that contains an acronym or
      # otherwise needs to maintain a non-standard capitalization. The only
      # restriction is that the word must begin with a capital letter.
      #
      #   acronym 'RESTful'
      #   underscore 'RESTful'           # => 'restful'
      #   underscore 'RESTfulController' # => 'restful_controller'
      #   titleize 'RESTfulController'   # => 'RESTful Controller'
      #   camelize 'restful'             # => 'RESTful'
      #   camelize 'restful_controller'  # => 'RESTfulController'
      #
      #   acronym 'McDonald'
      #   underscore 'McDonald' # => 'mcdonald'
      #   camelize 'mcdonald'   # => 'McDonald'
      def acronym: (untyped word) -> untyped

      # Specifies a new pluralization rule and its replacement. The rule can
      # either be a string or a regular expression. The replacement should
      # always be a string that may include references to the matched data from
      # the rule.
      def plural: (untyped rule, untyped replacement) -> untyped

      # Specifies a new singularization rule and its replacement. The rule can
      # either be a string or a regular expression. The replacement should
      # always be a string that may include references to the matched data from
      # the rule.
      def singular: (untyped rule, untyped replacement) -> untyped

      # Specifies a new irregular that applies to both pluralization and
      # singularization at the same time. This can only be used for strings, not
      # regular expressions. You simply pass the irregular in singular and
      # plural form.
      #
      #   irregular 'octopus', 'octopi'
      #   irregular 'person', 'people'
      def irregular: (untyped singular, untyped plural) -> untyped

      # Specifies words that are uncountable and should not be inflected.
      #
      #   uncountable 'money'
      #   uncountable 'money', 'information'
      #   uncountable %w( money information rice )
      def uncountable: (*untyped words) -> untyped

      # Specifies a humanized form of a string by a regular expression rule or
      # by a string mapping. When using a regular expression based replacement,
      # the normal humanize formatting is called after the replacement. When a
      # string is used, the human form should be specified as desired (example:
      # 'The name', not 'the_name').
      #
      #   human /_cnt$/i, '\1_count'
      #   human 'legacy_col_person_name', 'Name'
      def human: (untyped rule, untyped replacement) -> untyped

      # Clears the loaded inflections within a given scope (default is
      # <tt>:all</tt>). Give the scope as a symbol of the inflection type, the
      # options are: <tt>:plurals</tt>, <tt>:singulars</tt>, <tt>:uncountables</tt>,
      # <tt>:humans</tt>.
      #
      #   clear :all
      #   clear :plurals
      def clear: (?::Symbol scope) -> untyped

      private

      def define_acronym_regex_patterns: () -> untyped
    end

    # Yields a singleton instance of Inflector::Inflections so you can specify
    # additional inflector rules. If passed an optional locale, rules for other
    # languages can be specified. If not specified, defaults to <tt>:en</tt>.
    # Only rules for English are provided.
    #
    #   ActiveSupport::Inflector.inflections(:en) do |inflect|
    #     inflect.uncountable 'rails'
    #   end
    def inflections: (?::Symbol locale) { (untyped) -> untyped } -> untyped
  end
end

module ActiveSupport
  # The Inflector transforms words from singular to plural, class names to table
  # names, modularized class names to ones without, and class names to foreign
  # keys. The default inflections for pluralization, singularization, and
  # uncountable words are kept in inflections.rb.
  #
  # The Rails core team has stated patches for the inflections library will not
  # be accepted in order to avoid breaking legacy applications which may be
  # relying on errant inflections. If you discover an incorrect inflection and
  # require it for your application or wish to define rules for languages other
  # than English, please correct or add them yourself (explained below).
  module Inflector
    extend ::ActiveSupport::Inflector

    # Returns the plural form of the word in the string.
    #
    # If passed an optional +locale+ parameter, the word will be
    # pluralized using rules defined for that language. By default,
    # this parameter is set to <tt>:en</tt>.
    #
    #   pluralize('post')             # => "posts"
    #   pluralize('octopus')          # => "octopi"
    #   pluralize('sheep')            # => "sheep"
    #   pluralize('words')            # => "words"
    #   pluralize('CamelOctopus')     # => "CamelOctopi"
    #   pluralize('ley', :es)         # => "leyes"
    def pluralize: (untyped word, ?::Symbol locale) -> untyped

    # The reverse of #pluralize, returns the singular form of a word in a
    # string.
    #
    # If passed an optional +locale+ parameter, the word will be
    # singularized using rules defined for that language. By default,
    # this parameter is set to <tt>:en</tt>.
    #
    #   singularize('posts')            # => "post"
    #   singularize('octopi')           # => "octopus"
    #   singularize('sheep')            # => "sheep"
    #   singularize('word')             # => "word"
    #   singularize('CamelOctopi')      # => "CamelOctopus"
    #   singularize('leyes', :es)       # => "ley"
    def singularize: (untyped word, ?::Symbol locale) -> untyped

    # Converts strings to UpperCamelCase.
    # If the +uppercase_first_letter+ parameter is set to false, then produces
    # lowerCamelCase.
    #
    # Also converts '/' to '::' which is useful for converting
    # paths to namespaces.
    #
    #   camelize('active_model')                # => "ActiveModel"
    #   camelize('active_model', false)         # => "activeModel"
    #   camelize('active_model/errors')         # => "ActiveModel::Errors"
    #   camelize('active_model/errors', false)  # => "activeModel::Errors"
    #
    # As a rule of thumb you can think of +camelize+ as the inverse of
    # #underscore, though there are cases where that does not hold:
    #
    #   camelize(underscore('SSLError'))        # => "SslError"
    def camelize: (untyped term, ?bool uppercase_first_letter) -> untyped

    # Makes an underscored, lowercase form from the expression in the string.
    #
    # Changes '::' to '/' to convert namespaces to paths.
    #
    #   underscore('ActiveModel')         # => "active_model"
    #   underscore('ActiveModel::Errors') # => "active_model/errors"
    #
    # As a rule of thumb you can think of +underscore+ as the inverse of
    # #camelize, though there are cases where that does not hold:
    #
    #   camelize(underscore('SSLError'))  # => "SslError"
    def underscore: (untyped camel_cased_word) -> untyped

    # Tweaks an attribute name for display to end users.
    #
    # Specifically, performs these transformations:
    #
    # * Applies human inflection rules to the argument.
    # * Deletes leading underscores, if any.
    # * Removes a "_id" suffix if present.
    # * Replaces underscores with spaces, if any.
    # * Downcases all words except acronyms.
    # * Capitalizes the first word.
    # The capitalization of the first word can be turned off by setting the
    # +:capitalize+ option to false (default is true).
    #
    # The trailing '_id' can be kept and capitalized by setting the
    # optional parameter +keep_id_suffix+ to true (default is false).
    #
    #   humanize('employee_salary')                  # => "Employee salary"
    #   humanize('author_id')                        # => "Author"
    #   humanize('author_id', capitalize: false)     # => "author"
    #   humanize('_id')                              # => "Id"
    #   humanize('author_id', keep_id_suffix: true)  # => "Author Id"
    #
    # If "SSL" was defined to be an acronym:
    #
    #   humanize('ssl_error') # => "SSL error"
    #
    def humanize: (untyped lower_case_and_underscored_word, ?keep_id_suffix: bool keep_id_suffix, ?capitalize: bool capitalize) -> untyped

    # Converts just the first character to uppercase.
    #
    #   upcase_first('what a Lovely Day') # => "What a Lovely Day"
    #   upcase_first('w')                 # => "W"
    #   upcase_first('')                  # => ""
    def upcase_first: (untyped string) -> untyped

    # Capitalizes all the words and replaces some characters in the string to
    # create a nicer looking title. +titleize+ is meant for creating pretty
    # output. It is not used in the Rails internals.
    #
    # The trailing '_id','Id'.. can be kept and capitalized by setting the
    # optional parameter +keep_id_suffix+ to true.
    # By default, this parameter is false.
    #
    # +titleize+ is also aliased as +titlecase+.
    #
    #   titleize('man from the boondocks')                       # => "Man From The Boondocks"
    #   titleize('x-men: the last stand')                        # => "X Men: The Last Stand"
    #   titleize('TheManWithoutAPast')                           # => "The Man Without A Past"
    #   titleize('raiders_of_the_lost_ark')                      # => "Raiders Of The Lost Ark"
    #   titleize('string_ending_with_id', keep_id_suffix: true)  # => "String Ending With Id"
    def titleize: (untyped word, ?keep_id_suffix: bool keep_id_suffix) -> untyped

    # Creates the name of a table like Rails does for models to table names.
    # This method uses the #pluralize method on the last word in the string.
    #
    #   tableize('RawScaledScorer') # => "raw_scaled_scorers"
    #   tableize('ham_and_egg')     # => "ham_and_eggs"
    #   tableize('fancyCategory')   # => "fancy_categories"
    def tableize: (untyped class_name) -> untyped

    # Creates a class name from a plural table name like Rails does for table
    # names to models. Note that this returns a string and not a Class (To
    # convert to an actual class follow +classify+ with #constantize).
    #
    #   classify('ham_and_eggs') # => "HamAndEgg"
    #   classify('posts')        # => "Post"
    #
    # Singular names are not handled correctly:
    #
    #   classify('calculus')     # => "Calculu"
    def classify: (untyped table_name) -> untyped

    # Replaces underscores with dashes in the string.
    #
    #   dasherize('puni_puni') # => "puni-puni"
    def dasherize: (untyped underscored_word) -> untyped

    # Removes the module part from the expression in the string.
    #
    #   demodulize('ActiveSupport::Inflector::Inflections') # => "Inflections"
    #   demodulize('Inflections')                           # => "Inflections"
    #   demodulize('::Inflections')                         # => "Inflections"
    #   demodulize('')                                      # => ""
    #
    # See also #deconstantize.
    def demodulize: (untyped path) -> untyped

    # Removes the rightmost segment from the constant expression in the string.
    #
    #   deconstantize('Net::HTTP')   # => "Net"
    #   deconstantize('::Net::HTTP') # => "::Net"
    #   deconstantize('String')      # => ""
    #   deconstantize('::String')    # => ""
    #   deconstantize('')            # => ""
    #
    # See also #demodulize.
    def deconstantize: (untyped path) -> untyped

    # Creates a foreign key name from a class name.
    # +separate_class_name_and_id_with_underscore+ sets whether
    # the method should put '_' between the name and 'id'.
    #
    #   foreign_key('Message')        # => "message_id"
    #   foreign_key('Message', false) # => "messageid"
    #   foreign_key('Admin::Post')    # => "post_id"
    def foreign_key: (untyped class_name, ?bool separate_class_name_and_id_with_underscore) -> untyped

    # Tries to find a constant with the name specified in the argument string.
    #
    #   constantize('Module')   # => Module
    #   constantize('Foo::Bar') # => Foo::Bar
    #
    # The name is assumed to be the one of a top-level constant, no matter
    # whether it starts with "::" or not. No lexical context is taken into
    # account:
    #
    #   C = 'outside'
    #   module M
    #     C = 'inside'
    #     C                # => 'inside'
    #     constantize('C') # => 'outside', same as ::C
    #   end
    #
    # NameError is raised when the name is not in CamelCase or the constant is
    # unknown.
    def constantize: (untyped camel_cased_word) -> untyped

    # Tries to find a constant with the name specified in the argument string.
    #
    #   safe_constantize('Module')   # => Module
    #   safe_constantize('Foo::Bar') # => Foo::Bar
    #
    # The name is assumed to be the one of a top-level constant, no matter
    # whether it starts with "::" or not. No lexical context is taken into
    # account:
    #
    #   C = 'outside'
    #   module M
    #     C = 'inside'
    #     C                     # => 'inside'
    #     safe_constantize('C') # => 'outside', same as ::C
    #   end
    #
    # +nil+ is returned when the name is not in CamelCase or the constant (or
    # part of it) is unknown.
    #
    #   safe_constantize('blargle')                  # => nil
    #   safe_constantize('UnknownModule')            # => nil
    #   safe_constantize('UnknownModule::Foo::Bar')  # => nil
    def safe_constantize: (untyped camel_cased_word) -> untyped

    # Returns the suffix that should be added to a number to denote the position
    # in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    #
    #   ordinal(1)     # => "st"
    #   ordinal(2)     # => "nd"
    #   ordinal(1002)  # => "nd"
    #   ordinal(1003)  # => "rd"
    #   ordinal(-11)   # => "th"
    #   ordinal(-1021) # => "st"
    def ordinal: (untyped number) -> untyped

    # Turns a number into an ordinal string used to denote the position in an
    # ordered sequence such as 1st, 2nd, 3rd, 4th.
    #
    #   ordinalize(1)     # => "1st"
    #   ordinalize(2)     # => "2nd"
    #   ordinalize(1002)  # => "1002nd"
    #   ordinalize(1003)  # => "1003rd"
    #   ordinalize(-11)   # => "-11th"
    #   ordinalize(-1021) # => "-1021st"
    def ordinalize: (untyped number) -> untyped

    private

    # Mounts a regular expression, returned as a string to ease interpolation,
    # that will match part by part the given constant.
    #
    #   const_regexp("Foo::Bar::Baz") # => "Foo(::Bar(::Baz)?)?"
    #   const_regexp("::")            # => "::"
    def const_regexp: (untyped camel_cased_word) -> untyped

    # Applies inflection rules for +singularize+ and +pluralize+.
    #
    # If passed an optional +locale+ parameter, the uncountables will be
    # found for that locale.
    #
    #  apply_inflections('post', inflections.plurals, :en)    # => "posts"
    #  apply_inflections('posts', inflections.singulars, :en) # => "post"
    def apply_inflections: (untyped word, untyped rules, ?::Symbol locale) -> untyped
  end
end

module ActiveSupport
  module Inflector
    # Replaces non-ASCII characters with an ASCII approximation, or if none
    # exists, a replacement character which defaults to "?".
    #
    #    transliterate('(trim non-ascii characters)r(trim non-ascii characters)sk(trim non-ascii characters)bing')
    #    # => "AEroskobing"
    #
    # Default approximations are provided for Western/Latin characters,
    # e.g, "(trim non-ascii characters)", "(trim non-ascii characters)", "(trim non-ascii characters)", "(trim non-ascii characters)", etc.
    #
    # This method is I18n aware, so you can set up custom approximations for a
    # locale. This can be useful, for example, to transliterate German's "(trim non-ascii characters)"
    # and "(trim non-ascii characters)" to "ue" and "oe", or to add support for transliterating Russian
    # to ASCII.
    #
    # In order to make your custom transliterations available, you must set
    # them as the <tt>i18n.transliterate.rule</tt> i18n key:
    #
    #   # Store the transliterations in locales/de.yml
    #   i18n:
    #     transliterate:
    #       rule:
    #         (trim non-ascii characters): "ue"
    #         (trim non-ascii characters): "oe"
    #
    #   # Or set them using Ruby
    #   I18n.backend.store_translations(:de, i18n: {
    #     transliterate: {
    #       rule: {
    #         '(trim non-ascii characters)' => 'ue',
    #         '(trim non-ascii characters)' => 'oe'
    #       }
    #     }
    #   })
    #
    # The value for <tt>i18n.transliterate.rule</tt> can be a simple Hash that
    # maps characters to ASCII approximations as shown above, or, for more
    # complex requirements, a Proc:
    #
    #   I18n.backend.store_translations(:de, i18n: {
    #     transliterate: {
    #       rule: ->(string) { MyTransliterator.transliterate(string) }
    #     }
    #   })
    #
    # Now you can have different transliterations for each locale:
    #
    #   transliterate('J(trim non-ascii characters)rgen', locale: :en)
    #   # => "Jurgen"
    #
    #   transliterate('J(trim non-ascii characters)rgen', locale: :de)
    #   # => "Juergen"
    #
    # Transliteration is restricted to UTF-8, US-ASCII and GB18030 strings
    # Other encodings will raise an ArgumentError.
    def transliterate: (untyped string, ?::String replacement, ?locale: untyped? locale) -> untyped

    # Replaces special characters in a string so that it may be used as part of
    # a 'pretty' URL.
    #
    #   parameterize("Donald E. Knuth") # => "donald-e-knuth"
    #   parameterize("^tr(trim non-ascii characters)s|Jolie-- ")  # => "tres-jolie"
    #
    # To use a custom separator, override the +separator+ argument.
    #
    #   parameterize("Donald E. Knuth", separator: '_') # => "donald_e_knuth"
    #   parameterize("^tr(trim non-ascii characters)s|Jolie__ ", separator: '_')  # => "tres_jolie"
    #
    # To preserve the case of the characters in a string, use the +preserve_case+ argument.
    #
    #   parameterize("Donald E. Knuth", preserve_case: true) # => "Donald-E-Knuth"
    #   parameterize("^tr(trim non-ascii characters)s|Jolie-- ", preserve_case: true) # => "tres-Jolie"
    #
    # It preserves dashes and underscores unless they are used as separators:
    #
    #   parameterize("^tr(trim non-ascii characters)s|Jolie__ ")                 # => "tres-jolie__"
    #   parameterize("^tr(trim non-ascii characters)s|Jolie-- ", separator: "_") # => "tres_jolie--"
    #   parameterize("^tr(trim non-ascii characters)s_Jolie-- ", separator: ".") # => "tres_jolie--"
    #
    # If the optional parameter +locale+ is specified,
    # the word will be parameterized as a word of that language.
    # By default, this parameter is set to <tt>nil</tt> and it will use
    # the configured <tt>I18n.locale<tt>.
    def parameterize: (untyped string, ?locale: untyped? locale, ?preserve_case: bool preserve_case, ?separator: ::String separator) -> untyped
  end
end

module ActiveSupport
  module JSON
    # matches YAML-formatted dates
    DATE_REGEX: untyped

    DATETIME_REGEX: untyped

    # Parses a JSON string (JavaScript Object Notation) into a hash.
    # See http://www.json.org for more info.
    #
    #   ActiveSupport::JSON.decode("{\"team\":\"rails\",\"players\":\"36\"}")
    #   => {"team" => "rails", "players" => "36"}
    def self.decode: (untyped json) -> untyped

    # Returns the class of the error that will be raised when there is an
    # error in decoding JSON. Using this method means you won't directly
    # depend on the ActiveSupport's JSON implementation, in case it changes
    # in the future.
    #
    #   begin
    #     obj = ActiveSupport::JSON.decode(some_string)
    #   rescue ActiveSupport::JSON.parse_error
    #     Rails.logger.warn("Attempted to decode invalid JSON: #{some_string}")
    #   end
    def self.parse_error: () -> untyped

    private

    def self.convert_dates_from: (untyped data) -> untyped
  end
end

module ActiveSupport
  module JSON
    # Dumps objects in JSON (JavaScript Object Notation).
    # See http://www.json.org for more info.
    #
    #   ActiveSupport::JSON.encode({ team: 'rails', players: '36' })
    #   # => "{\"team\":\"rails\",\"players\":\"36\"}"
    def self.encode: (untyped value, ?untyped? options) -> untyped

    module Encoding
      class JSONGemEncoder
        # nodoc:
        # nodoc:
        attr_reader options: untyped

        def initialize: (?untyped? options) -> untyped

        # Encode the given object into a JSON string
        def encode: (untyped value) -> untyped

        private

        # Rails does more escaping than the JSON gem natively does (we
        # escape \u2028 and \u2029 and optionally >, <, & to work around
        # certain browser problems).
        ESCAPED_CHARS: ::Hash[untyped, untyped]

        ESCAPE_REGEX_WITH_HTML_ENTITIES: untyped

        ESCAPE_REGEX_WITHOUT_HTML_ENTITIES: untyped

        class EscapedString < String
          # This class wraps all the strings we see and does the extra escaping
          # nodoc:
          def to_json: () -> untyped

          def to_s: () -> untyped
        end

        # Convert an object into a "JSON-ready" representation composed of
        # primitives like Hash, Array, String, Numeric,
        # and +true+/+false+/+nil+.
        # Recursively calls #as_json to the object to recursively build a
        # fully JSON-ready object.
        #
        # This allows developers to implement #as_json without having to
        # worry about what base types of objects they are allowed to return
        # or having to remember to call #as_json recursively.
        #
        # Note: the +options+ hash passed to +object.to_json+ is only passed
        # to +object.as_json+, not any of this method's recursive +#as_json+
        # calls.
        def jsonify: (untyped value) -> untyped

        # Encode a "jsonified" Ruby data structure using the JSON gem
        def stringify: (untyped jsonified) -> untyped
      end

      # If true, use ISO 8601 format for dates and times. Otherwise, fall back
      # to the Active Support legacy format.
      attr_accessor self.use_standard_json_time_format: untyped

      # If true, encode >, <, & as escaped unicode sequences (e.g. > as \u003e)
      # as a safety measure.
      attr_accessor self.escape_html_entities_in_json: untyped

      # Sets the precision of encoded time values.
      # Defaults to 3 (equivalent to millisecond precision)
      attr_accessor self.time_precision: untyped

      # Sets the encoder used by Rails to encode Ruby objects into JSON strings
      # in +Object#to_json+ and +ActiveSupport::JSON.encode+.
      attr_accessor self.json_encoder: untyped
    end
  end
end

module ActiveSupport
  # KeyGenerator is a simple wrapper around OpenSSL's implementation of PBKDF2.
  # It can be used to derive a number of keys for various purposes from a given secret.
  # This lets Rails applications have a single secure secret, but avoid reusing that
  # key in multiple incompatible contexts.
  class KeyGenerator
    def initialize: (untyped secret, ?::Hash[untyped, untyped] options) -> untyped

    # Returns a derived key suitable for use.  The default key_size is chosen
    # to be compatible with the default settings of ActiveSupport::MessageVerifier.
    # i.e. OpenSSL::Digest::SHA1#block_length
    def generate_key: (untyped salt, ?::Integer key_size) -> untyped
  end

  # CachingKeyGenerator is a wrapper around KeyGenerator which allows users to avoid
  # re-executing the key generation process when it's called using the same salt and
  # key_size.
  class CachingKeyGenerator
    def initialize: (untyped key_generator) -> untyped

    # Returns a derived key suitable for use.
    def generate_key: (*untyped args) -> untyped
  end
end

module ActiveSupport
  # lazy_load_hooks allows Rails to lazily load a lot of components and thus
  # making the app boot faster. Because of this feature now there is no need to
  # require <tt>ActiveRecord::Base</tt> at boot time purely to apply
  # configuration. Instead a hook is registered that applies configuration once
  # <tt>ActiveRecord::Base</tt> is loaded. Here <tt>ActiveRecord::Base</tt> is
  # used as example but this feature can be applied elsewhere too.
  #
  # Here is an example where +on_load+ method is called to register a hook.
  #
  #   initializer 'active_record.initialize_timezone' do
  #     ActiveSupport.on_load(:active_record) do
  #       self.time_zone_aware_attributes = true
  #       self.default_timezone = :utc
  #     end
  #   end
  #
  # When the entirety of +ActiveRecord::Base+ has been
  # evaluated then +run_load_hooks+ is invoked. The very last line of
  # +ActiveRecord::Base+ is:
  #
  #   ActiveSupport.run_load_hooks(:active_record, ActiveRecord::Base)
  module LazyLoadHooks
    def self.extended: (untyped base) -> untyped

    # Declares a block that will be executed when a Rails component is fully
    # loaded.
    #
    # Options:
    #
    # * <tt>:yield</tt> - Yields the object that run_load_hooks to +block+.
    # * <tt>:run_once</tt> - Given +block+ will run only once.
    def on_load: (untyped name, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

    def run_load_hooks: (untyped name, ?untyped base) -> untyped

    private

    def with_execution_control: (untyped name, untyped block, untyped once) { () -> untyped } -> untyped

    def execute_hook: (untyped name, untyped base, untyped options, untyped block) -> untyped
  end

  extend LazyLoadHooks
end

module ActiveSupport
  class LogSubscriber
    # Provides some helpers to deal with testing log subscribers by setting up
    # notifications. Take for instance Active Record subscriber tests:
    #
    #   class SyncLogSubscriberTest < ActiveSupport::TestCase
    #     include ActiveSupport::LogSubscriber::TestHelper
    #
    #     setup do
    #       ActiveRecord::LogSubscriber.attach_to(:active_record)
    #     end
    #
    #     def test_basic_query_logging
    #       Developer.all.to_a
    #       wait
    #       assert_equal 1, @logger.logged(:debug).size
    #       assert_match(/Developer Load/, @logger.logged(:debug).last)
    #       assert_match(/SELECT \* FROM "developers"/, @logger.logged(:debug).last)
    #     end
    #   end
    #
    # All you need to do is to ensure that your log subscriber is added to
    # Rails::Subscriber, as in the second line of the code above. The test
    # helpers are responsible for setting up the queue, subscriptions and
    # turning colors in logs off.
    #
    # The messages are available in the @logger instance, which is a logger with
    # limited powers (it actually does not send anything to your output), and
    # you can collect them doing @logger.logged(level), where level is the level
    # used in logging, like info, debug, warn and so on.
    module TestHelper
      def setup: () -> untyped

      def teardown: () -> untyped

      class MockLogger
        include ::Logger::Severity

        attr_reader flush_count: untyped

        attr_accessor level: untyped

        def initialize: (?untyped level) -> untyped

        def method_missing: (untyped level, ?untyped? message) { () -> untyped } -> untyped

        def logged: (untyped level) -> untyped

        def flush: () -> untyped
      end

      # Wait notifications to be published.
      def wait: () -> untyped

      # Overwrite if you use another logger in your log subscriber.
      #
      #   def logger
      #     ActiveRecord::Base.logger = @logger
      #   end
      def set_logger: (untyped logger) -> untyped
    end
  end
end

module ActiveSupport
  # <tt>ActiveSupport::LogSubscriber</tt> is an object set to consume
  # <tt>ActiveSupport::Notifications</tt> with the sole purpose of logging them.
  # The log subscriber dispatches notifications to a registered object based
  # on its given namespace.
  #
  # An example would be Active Record log subscriber responsible for logging
  # queries:
  #
  #   module ActiveRecord
  #     class LogSubscriber < ActiveSupport::LogSubscriber
  #       def sql(event)
  #         info "#{event.payload[:name]} (#{event.duration}) #{event.payload[:sql]}"
  #       end
  #     end
  #   end
  #
  # And it's finally registered as:
  #
  #   ActiveRecord::LogSubscriber.attach_to :active_record
  #
  # Since we need to know all instance methods before attaching the log
  # subscriber, the line above should be called after your
  # <tt>ActiveRecord::LogSubscriber</tt> definition.
  #
  # After configured, whenever a <tt>"sql.active_record"</tt> notification is published,
  # it will properly dispatch the event
  # (<tt>ActiveSupport::Notifications::Event</tt>) to the sql method.
  #
  # Being an <tt>ActiveSupport::Notifications</tt> consumer,
  # <tt>ActiveSupport::LogSubscriber</tt> exposes a simple interface to check if
  # instrumented code raises an exception. It is common to log a different
  # message in case of an error, and this can be achieved by extending
  # the previous example:
  #
  #   module ActiveRecord
  #     class LogSubscriber < ActiveSupport::LogSubscriber
  #       def sql(event)
  #         exception = event.payload[:exception]
  #
  #         if exception
  #           exception_object = event.payload[:exception_object]
  #
  #           error "[ERROR] #{event.payload[:name]}: #{exception.join(', ')} " \
  #                 "(#{exception_object.backtrace.first})"
  #         else
  #           # standard logger code
  #         end
  #       end
  #     end
  #   end
  #
  # Log subscriber also has some helpers to deal with logging and automatically
  # flushes all logs when the request finishes
  # (via <tt>action_dispatch.callback</tt> notification) in a Rails environment.
  class LogSubscriber < Subscriber
    # Embed in a String to clear all previous ANSI sequences.
    CLEAR: ::String

    BOLD: ::String

    # Colors
    BLACK: ::String

    RED: ::String

    GREEN: ::String

    YELLOW: ::String

    BLUE: ::String

    MAGENTA: ::String

    CYAN: ::String

    WHITE: ::String

    def self.logger: () -> untyped

    attr_writer self.logger: untyped

    def self.log_subscribers: () -> untyped

    # Flush all log_subscribers' logger.
    def self.flush_all!: () -> untyped

    def logger: () -> untyped

    def start: (untyped name, untyped id, untyped payload) -> untyped

    def finish: (untyped name, untyped id, untyped payload) -> untyped

    private

    def color: (untyped text, untyped color, ?bool bold) -> (untyped | ::String)
  end
end

module ActiveSupport
  class Logger < ::Logger
    include LoggerSilence

    # Returns true if the logger destination matches one of the sources
    #
    #   logger = Logger.new(STDOUT)
    #   ActiveSupport::Logger.logger_outputs_to?(logger, STDOUT)
    #   # => true
    def self.logger_outputs_to?: (untyped logger, *untyped sources) -> untyped

    def self.broadcast: (untyped logger) -> untyped

    def initialize: (*untyped args, **untyped kwargs) -> untyped

    # Simple formatter which only displays the message.
    class SimpleFormatter < ::Logger::Formatter
      # This method is invoked when a log event occurs
      def call: (untyped severity, untyped timestamp, untyped progname, untyped msg) -> ::String
    end
  end
end

module LoggerSilence
  extend ActiveSupport::Concern

  include ActiveSupport::LoggerSilence
end

module ActiveSupport
  module LoggerSilence
    extend ActiveSupport::Concern

    include ActiveSupport::LoggerThreadSafeLevel

    # Silences the logger for the duration of the block.
    def silence: (?untyped temporary_level) { (untyped) -> untyped } -> untyped
  end
end

module ActiveSupport
  module LoggerThreadSafeLevel
    # :nodoc:
    extend ActiveSupport::Concern

    def after_initialize: () -> untyped

    def local_log_id: () -> untyped

    def local_level: () -> untyped

    def local_level=: (untyped level) -> untyped

    def level: () -> untyped

    def add: (untyped severity, ?untyped? message, ?untyped? progname) { () -> untyped } -> (::TrueClass | untyped)
  end
end

module ActiveSupport
  # MessageEncryptor is a simple way to encrypt values which get stored
  # somewhere you don't trust.
  #
  # The cipher text and initialization vector are base64 encoded and returned
  # to you.
  #
  # This can be used in situations similar to the <tt>MessageVerifier</tt>, but
  # where you don't want users to be able to determine the value of the payload.
  #
  #   len   = ActiveSupport::MessageEncryptor.key_len
  #   salt  = SecureRandom.random_bytes(len)
  #   key   = ActiveSupport::KeyGenerator.new('password').generate_key(salt, len) # => "\x89\xE0\x156\xAC..."
  #   crypt = ActiveSupport::MessageEncryptor.new(key)                            # => #<ActiveSupport::MessageEncryptor ...>
  #   encrypted_data = crypt.encrypt_and_sign('my secret data')                   # => "NlFBTTMwOUV5UlA1QlNEN2xkY2d6eThYWWh..."
  #   crypt.decrypt_and_verify(encrypted_data)                                    # => "my secret data"
  #
  # === Confining messages to a specific purpose
  #
  # By default any message can be used throughout your app. But they can also be
  # confined to a specific +:purpose+.
  #
  #   token = crypt.encrypt_and_sign("this is the chair", purpose: :login)
  #
  # Then that same purpose must be passed when verifying to get the data back out:
  #
  #   crypt.decrypt_and_verify(token, purpose: :login)    # => "this is the chair"
  #   crypt.decrypt_and_verify(token, purpose: :shipping) # => nil
  #   crypt.decrypt_and_verify(token)                     # => nil
  #
  # Likewise, if a message has no purpose it won't be returned when verifying with
  # a specific purpose.
  #
  #   token = crypt.encrypt_and_sign("the conversation is lively")
  #   crypt.decrypt_and_verify(token, purpose: :scare_tactics) # => nil
  #   crypt.decrypt_and_verify(token)                          # => "the conversation is lively"
  #
  # === Making messages expire
  #
  # By default messages last forever and verifying one year from now will still
  # return the original value. But messages can be set to expire at a given
  # time with +:expires_in+ or +:expires_at+.
  #
  #   crypt.encrypt_and_sign(parcel, expires_in: 1.month)
  #   crypt.encrypt_and_sign(doowad, expires_at: Time.now.end_of_year)
  #
  # Then the messages can be verified and returned up to the expire time.
  # Thereafter, verifying returns +nil+.
  #
  # === Rotating keys
  #
  # MessageEncryptor also supports rotating out old configurations by falling
  # back to a stack of encryptors. Call +rotate+ to build and add an encryptor
  # so +decrypt_and_verify+ will also try the fallback.
  #
  # By default any rotated encryptors use the values of the primary
  # encryptor unless specified otherwise.
  #
  # You'd give your encryptor the new defaults:
  #
  #   crypt = ActiveSupport::MessageEncryptor.new(@secret, cipher: "aes-256-gcm")
  #
  # Then gradually rotate the old values out by adding them as fallbacks. Any message
  # generated with the old values will then work until the rotation is removed.
  #
  #   crypt.rotate old_secret            # Fallback to an old secret instead of @secret.
  #   crypt.rotate cipher: "aes-256-cbc" # Fallback to an old cipher instead of aes-256-gcm.
  #
  # Though if both the secret and the cipher was changed at the same time,
  # the above should be combined into:
  #
  #   crypt.rotate old_secret, cipher: "aes-256-cbc"
  class MessageEncryptor
    def self.default_cipher: () -> untyped

    module NullSerializer
      # nodoc:
      def self.load: (untyped value) -> untyped

      def self.dump: (untyped value) -> untyped
    end

    module NullVerifier
      # nodoc:
      def self.verify: (untyped value) -> untyped

      def self.generate: (untyped value) -> untyped
    end

    class InvalidMessage < StandardError
    end

    OpenSSLCipherError: untyped

    # Initialize a new MessageEncryptor. +secret+ must be at least as long as
    # the cipher key size. For the default 'aes-256-gcm' cipher, this is 256
    # bits. If you are using a user-entered secret, you can generate a suitable
    # key by using <tt>ActiveSupport::KeyGenerator</tt> or a similar key
    # derivation function.
    #
    # First additional parameter is used as the signature key for +MessageVerifier+.
    # This allows you to specify keys to encrypt and sign data.
    #
    #    ActiveSupport::MessageEncryptor.new('secret', 'signature_secret')
    #
    # Options:
    # * <tt>:cipher</tt>     - Cipher to use. Can be any cipher returned by
    #   <tt>OpenSSL::Cipher.ciphers</tt>. Default is 'aes-256-gcm'.
    # * <tt>:digest</tt> - String of digest to use for signing. Default is
    #   +SHA1+. Ignored when using an AEAD cipher like 'aes-256-gcm'.
    # * <tt>:serializer</tt> - Object serializer to use. Default is +Marshal+.
    def initialize: (untyped secret, *untyped signature_key_or_options) -> untyped

    # Encrypt and sign a message. We need to sign the message in order to avoid
    # padding attacks. Reference: https://www.limited-entropy.com/padding-oracle-attacks/.
    def encrypt_and_sign: (untyped value, ?purpose: untyped? purpose, ?expires_in: untyped? expires_in, ?expires_at: untyped? expires_at) -> untyped

    # Decrypt and verify a message. We need to verify the message in order to
    # avoid padding attacks. Reference: https://www.limited-entropy.com/padding-oracle-attacks/.
    def decrypt_and_verify: (untyped data, ?purpose: untyped? purpose) -> untyped

    # Given a cipher, returns the key length of the cipher to help generate the key of desired size
    def self.key_len: (?untyped cipher) -> untyped

    private

    def _encrypt: (untyped value, **untyped metadata_options) -> untyped

    def _decrypt: (untyped encrypted_message, untyped purpose) -> untyped

    def new_cipher: () -> OpenSSL::Cipher

    attr_reader verifier: untyped

    def aead_mode?: () -> untyped

    def resolve_verifier: () -> untyped
  end
end

module ActiveSupport
  # +MessageVerifier+ makes it easy to generate and verify messages which are
  # signed to prevent tampering.
  #
  # This is useful for cases like remember-me tokens and auto-unsubscribe links
  # where the session store isn't suitable or available.
  #
  # Remember Me:
  #   cookies[:remember_me] = @verifier.generate([@user.id, 2.weeks.from_now])
  #
  # In the authentication filter:
  #
  #   id, time = @verifier.verify(cookies[:remember_me])
  #   if Time.now < time
  #     self.current_user = User.find(id)
  #   end
  #
  # By default it uses Marshal to serialize the message. If you want to use
  # another serialization method, you can set the serializer in the options
  # hash upon initialization:
  #
  #   @verifier = ActiveSupport::MessageVerifier.new('s3Krit', serializer: YAML)
  #
  # +MessageVerifier+ creates HMAC signatures using SHA1 hash algorithm by default.
  # If you want to use a different hash algorithm, you can change it by providing
  # +:digest+ key as an option while initializing the verifier:
  #
  #   @verifier = ActiveSupport::MessageVerifier.new('s3Krit', digest: 'SHA256')
  #
  # === Confining messages to a specific purpose
  #
  # By default any message can be used throughout your app. But they can also be
  # confined to a specific +:purpose+.
  #
  #   token = @verifier.generate("this is the chair", purpose: :login)
  #
  # Then that same purpose must be passed when verifying to get the data back out:
  #
  #   @verifier.verified(token, purpose: :login)    # => "this is the chair"
  #   @verifier.verified(token, purpose: :shipping) # => nil
  #   @verifier.verified(token)                     # => nil
  #
  #   @verifier.verify(token, purpose: :login)      # => "this is the chair"
  #   @verifier.verify(token, purpose: :shipping)   # => ActiveSupport::MessageVerifier::InvalidSignature
  #   @verifier.verify(token)                       # => ActiveSupport::MessageVerifier::InvalidSignature
  #
  # Likewise, if a message has no purpose it won't be returned when verifying with
  # a specific purpose.
  #
  #   token = @verifier.generate("the conversation is lively")
  #   @verifier.verified(token, purpose: :scare_tactics) # => nil
  #   @verifier.verified(token)                          # => "the conversation is lively"
  #
  #   @verifier.verify(token, purpose: :scare_tactics)   # => ActiveSupport::MessageVerifier::InvalidSignature
  #   @verifier.verify(token)                            # => "the conversation is lively"
  #
  # === Making messages expire
  #
  # By default messages last forever and verifying one year from now will still
  # return the original value. But messages can be set to expire at a given
  # time with +:expires_in+ or +:expires_at+.
  #
  #   @verifier.generate(parcel, expires_in: 1.month)
  #   @verifier.generate(doowad, expires_at: Time.now.end_of_year)
  #
  # Then the messages can be verified and returned up to the expire time.
  # Thereafter, the +verified+ method returns +nil+ while +verify+ raises
  # <tt>ActiveSupport::MessageVerifier::InvalidSignature</tt>.
  #
  # === Rotating keys
  #
  # MessageVerifier also supports rotating out old configurations by falling
  # back to a stack of verifiers. Call +rotate+ to build and add a verifier to
  # so either +verified+ or +verify+ will also try verifying with the fallback.
  #
  # By default any rotated verifiers use the values of the primary
  # verifier unless specified otherwise.
  #
  # You'd give your verifier the new defaults:
  #
  #   verifier = ActiveSupport::MessageVerifier.new(@secret, digest: "SHA512", serializer: JSON)
  #
  # Then gradually rotate the old values out by adding them as fallbacks. Any message
  # generated with the old values will then work until the rotation is removed.
  #
  #   verifier.rotate old_secret          # Fallback to an old secret instead of @secret.
  #   verifier.rotate digest: "SHA256"    # Fallback to an old digest instead of SHA512.
  #   verifier.rotate serializer: Marshal # Fallback to an old serializer instead of JSON.
  #
  # Though the above would most likely be combined into one rotation:
  #
  #   verifier.rotate old_secret, digest: "SHA256", serializer: Marshal
  class MessageVerifier
    class InvalidSignature < StandardError
    end

    def initialize: (untyped secret, ?::Hash[untyped, untyped] options) -> untyped

    # Checks if a signed message could have been generated by signing an object
    # with the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   signed_message = verifier.generate 'a private message'
    #   verifier.valid_message?(signed_message) # => true
    #
    #   tampered_message = signed_message.chop # editing the message invalidates the signature
    #   verifier.valid_message?(tampered_message) # => false
    def valid_message?: (untyped signed_message) -> (nil | untyped)

    # Decodes the signed message using the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #
    #   signed_message = verifier.generate 'a private message'
    #   verifier.verified(signed_message) # => 'a private message'
    #
    # Returns +nil+ if the message was not signed with the same secret.
    #
    #   other_verifier = ActiveSupport::MessageVerifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verified(signed_message) # => nil
    #
    # Returns +nil+ if the message is not Base64-encoded.
    #
    #   invalid_message = "f--46a0120593880c733a53b6dad75b42ddc1c8996d"
    #   verifier.verified(invalid_message) # => nil
    #
    # Raises any error raised while decoding the signed message.
    #
    #   incompatible_message = "test--dad7b06c94abba8d46a15fafaef56c327665d5ff"
    #   verifier.verified(incompatible_message) # => TypeError: incompatible marshal file format
    def verified: (untyped signed_message, ?purpose: untyped? purpose) -> untyped

    # Decodes the signed message using the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   signed_message = verifier.generate 'a private message'
    #
    #   verifier.verify(signed_message) # => 'a private message'
    #
    # Raises +InvalidSignature+ if the message was not signed with the same
    # secret or was not Base64-encoded.
    #
    #   other_verifier = ActiveSupport::MessageVerifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verify(signed_message) # => ActiveSupport::MessageVerifier::InvalidSignature
    def verify: (*untyped args, **untyped options) -> untyped

    # Generates a signed message for the provided value.
    #
    # The message is signed with the +MessageVerifier+'s secret. Without knowing
    # the secret, the original value cannot be extracted from the message.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   verifier.generate 'a private message' # => "BAhJIhRwcml2YXRlLW1lc3NhZ2UGOgZFVA==--e2d724331ebdee96a10fb99b089508d1c72bd772"
    def generate: (untyped value, ?purpose: untyped? purpose, ?expires_in: untyped? expires_in, ?expires_at: untyped? expires_at) -> ::String

    private

    def encode: (untyped data) -> untyped

    def decode: (untyped data) -> untyped

    def generate_digest: (untyped data) -> untyped
  end
end

module ActiveSupport
  module Messages
    class Metadata
      # nodoc:
      # nodoc:
      def initialize: (untyped message, ?untyped? expires_at, ?untyped? purpose) -> untyped

      def as_json: (?::Hash[untyped, untyped] options) -> { _rails: { message: untyped, exp: untyped, pur: untyped } }

      def self.wrap: (untyped message, ?purpose: untyped? purpose, ?expires_in: untyped? expires_in, ?expires_at: untyped? expires_at) -> untyped

      def self.verify: (untyped message, untyped purpose) -> untyped

      private

      def self.pick_expiry: (untyped expires_at, untyped expires_in) -> untyped

      def self.extract_metadata: (untyped message) -> untyped

      def self.encode: (untyped message) -> untyped

      def self.decode: (untyped message) -> untyped

      public

      def verify: (untyped purpose) -> untyped

      private

      def match?: (untyped purpose) -> untyped

      def fresh?: () -> untyped
    end
  end
end

module ActiveSupport
  module Messages
    class RotationConfiguration
      # :nodoc:
      attr_reader signed: untyped

      # :nodoc:
      attr_reader encrypted: untyped

      def initialize: () -> untyped

      def rotate: (untyped kind, *untyped args) -> untyped
    end
  end
end

module ActiveSupport
  module Messages
    module Rotator
      # :nodoc:
      def initialize: (**untyped options) -> untyped

      def rotate: (*untyped secrets, **untyped options) -> untyped

      module Encryptor
        include Rotator

        def decrypt_and_verify: (*untyped args, ?on_rotation: untyped? on_rotation, **untyped options) -> untyped

        private

        def build_rotation: (?untyped secret, ?untyped sign_secret, untyped options) -> untyped
      end

      module Verifier
        include Rotator

        def verified: (*untyped args, ?on_rotation: untyped? on_rotation, **untyped options) -> untyped

        private

        def build_rotation: (?untyped secret, untyped options) -> untyped
      end

      private

      def run_rotations: (untyped on_rotation) { (untyped) -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Multibyte
    # nodoc:
    # nodoc:
    # Chars enables you to work transparently with UTF-8 encoding in the Ruby
    # String class without having extensive knowledge about the encoding. A
    # Chars object accepts a string upon initialization and proxies String
    # methods in an encoding safe manner. All the normal String methods are also
    # implemented on the proxy.
    #
    # String methods are proxied through the Chars object, and can be accessed
    # through the +mb_chars+ method. Methods which would normally return a
    # String object now return a Chars object so methods can be chained.
    #
    #   'The Perfect String  '.mb_chars.downcase.strip
    #   # => #<ActiveSupport::Multibyte::Chars:0x007fdc434ccc10 @wrapped_string="the perfect string">
    #
    # Chars objects are perfectly interchangeable with String objects as long as
    # no explicit class checks are made. If certain methods do explicitly check
    # the class, call +to_s+ before you pass chars objects to them.
    #
    #   bad.explicit_checking_method 'T'.mb_chars.downcase.to_s
    #
    # The default Chars implementation assumes that the encoding of the string
    # is UTF-8, if you want to handle different encodings you can write your own
    # multibyte string handler and configure it through
    # ActiveSupport::Multibyte.proxy_class.
    #
    #   class CharsForUTF32
    #     def size
    #       @wrapped_string.size / 4
    #     end
    #
    #     def self.accepts?(string)
    #       string.length % 4 == 0
    #     end
    #   end
    #
    #   ActiveSupport::Multibyte.proxy_class = CharsForUTF32
    class Chars
      include Comparable

      attr_reader wrapped_string: untyped

      alias to_s wrapped_string

      alias to_str wrapped_string

      # Creates a new Chars instance by wrapping _string_.
      def initialize: (untyped string) -> untyped

      # Forward all undefined methods to the wrapped string.
      def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped

      # Returns +true+ if _obj_ responds to the given method. Private methods
      # are included in the search only if the optional second parameter
      # evaluates to +true+.
      def respond_to_missing?: (untyped method, untyped include_private) -> untyped

      # Returns +true+ when the proxy class can handle the string. Returns
      # +false+ otherwise.
      def self.consumes?: (untyped string) -> untyped

      # Works just like <tt>String#split</tt>, with the exception that the items
      # in the resulting list are Chars instances instead of String. This makes
      # chaining methods easier.
      #
      #   'Caf(trim non-ascii characters) p(trim non-ascii characters)rifer(trim non-ascii characters)l'.mb_chars.split(/(trim non-ascii characters)/).map { |part| part.upcase.to_s } # => ["CAF", " P", "RIFER(trim non-ascii characters)L"]
      def split: (*untyped args) -> untyped

      # Works like <tt>String#slice!</tt>, but returns an instance of
      # Chars, or +nil+ if the string was not modified. The string will not be
      # modified if the range given is out of bounds
      #
      #   string = 'Welcome'
      #   string.mb_chars.slice!(3)    # => #<ActiveSupport::Multibyte::Chars:0x000000038109b8 @wrapped_string="c">
      #   string # => 'Welome'
      #   string.mb_chars.slice!(0..3) # => #<ActiveSupport::Multibyte::Chars:0x00000002eb80a0 @wrapped_string="Welo">
      #   string # => 'me'
      def slice!: (*untyped args) -> untyped

      # Reverses all characters in the string.
      #
      #   'Caf(trim non-ascii characters)'.mb_chars.reverse.to_s # => '(trim non-ascii characters)faC'
      def reverse: () -> untyped

      # Limits the byte size of the string to a number of bytes without breaking
      # characters. Usable when the storage for a string is limited for some
      # reason.
      #
      #   '(trim non-ascii characters)'.mb_chars.limit(7).to_s # => "(trim non-ascii characters)"
      def limit: (untyped limit) -> untyped

      # Capitalizes the first letter of every word, when possible.
      #
      #   "(trim non-ascii characters)L QUE SE ENTER(trim non-ascii characters)".mb_chars.titleize.to_s    # => "(trim non-ascii characters)l Que Se Enter(trim non-ascii characters)"
      #   "(trim non-ascii characters)".mb_chars.titleize.to_s               # => "(trim non-ascii characters)"
      def titleize: () -> untyped

      alias titlecase titleize

      # Returns the KC normalization of the string by default. NFKC is
      # considered the best normalization form for passing strings to databases
      # and validations.
      #
      # * <tt>form</tt> - The form you want to normalize in. Should be one of the following:
      #   <tt>:c</tt>, <tt>:kc</tt>, <tt>:d</tt>, or <tt>:kd</tt>. Default is
      #   ActiveSupport::Multibyte::Unicode.default_normalization_form
      def normalize: (?untyped? form) -> untyped

      # Performs canonical decomposition on all the characters.
      #
      #   '(trim non-ascii characters)'.length                         # => 2
      #   '(trim non-ascii characters)'.mb_chars.decompose.to_s.length # => 3
      def decompose: () -> untyped

      # Performs composition on all the characters.
      #
      #   '(trim non-ascii characters)'.length                       # => 3
      #   '(trim non-ascii characters)'.mb_chars.compose.to_s.length # => 2
      def compose: () -> untyped

      # Returns the number of grapheme clusters in the string.
      #
      #   '(trim non-ascii characters)'.mb_chars.length   # => 4
      #   '(trim non-ascii characters)'.mb_chars.grapheme_length # => 3
      def grapheme_length: () -> untyped

      # Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent
      # resulting in a valid UTF-8 string.
      #
      # Passing +true+ will forcibly tidy all bytes, assuming that the string's
      # encoding is entirely CP1252 or ISO-8859-1.
      def tidy_bytes: (?bool force) -> untyped

      def as_json: (?untyped? options) -> untyped

      private

      def chars: (untyped string) -> untyped
    end
  end
end

module ActiveSupport
  module Multibyte
    module Unicode
      extend ::ActiveSupport::Multibyte::Unicode

      # A list of all available normalization forms.
      # See https://www.unicode.org/reports/tr15/tr15-29.html for more
      # information about normalization.
      NORMALIZATION_FORMS: ::Array[untyped]

      NORMALIZATION_FORM_ALIASES: ::Hash[untyped, untyped]

      # The Unicode version that is supported by the implementation
      UNICODE_VERSION: untyped

      # The default normalization used for operations that require
      # normalization. It can be set to any of the normalizations
      # in NORMALIZATION_FORMS.
      #
      #   ActiveSupport::Multibyte::Unicode.default_normalization_form = :c
      attr_accessor default_normalization_form: untyped

      # Unpack the string at grapheme boundaries. Returns a list of character
      # lists.
      #
      #   Unicode.unpack_graphemes('(trim non-ascii characters)') # => [[2325, 2381], [2359], [2367]]
      #   Unicode.unpack_graphemes('Caf(trim non-ascii characters)') # => [[67], [97], [102], [233]]
      def unpack_graphemes: (untyped string) -> untyped

      # Reverse operation of unpack_graphemes.
      #
      #   Unicode.pack_graphemes(Unicode.unpack_graphemes('(trim non-ascii characters)')) # => '(trim non-ascii characters)'
      def pack_graphemes: (untyped unpacked) -> untyped

      # Decompose composed characters to the decomposed form.
      def decompose: (untyped `type`, untyped codepoints) -> untyped

      # Compose decomposed characters to the composed form.
      def compose: (untyped codepoints) -> untyped

      # Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent
      # resulting in a valid UTF-8 string.
      #
      # Passing +true+ will forcibly tidy all bytes, assuming that the string's
      # encoding is entirely CP1252 or ISO-8859-1.
      def tidy_bytes: (untyped string, ?bool force) -> untyped

      # Returns the KC normalization of the string by default. NFKC is
      # considered the best normalization form for passing strings to databases
      # and validations.
      #
      # * <tt>string</tt> - The string to perform normalization on.
      # * <tt>form</tt> - The form you want to normalize in. Should be one of
      #   the following: <tt>:c</tt>, <tt>:kc</tt>, <tt>:d</tt>, or <tt>:kd</tt>.
      #   Default is ActiveSupport::Multibyte::Unicode.default_normalization_form.
      def normalize: (untyped string, ?untyped? form) -> untyped

      private

      def recode_windows1252_chars: (untyped string) -> untyped
    end
  end
end

module ActiveSupport
  # nodoc:
  module Multibyte
    # The proxy class returned when calling mb_chars. You can use this accessor
    # to configure your own proxy class so you can support other encodings. See
    # the ActiveSupport::Multibyte::Chars implementation for an example how to
    # do this.
    #
    #   ActiveSupport::Multibyte.proxy_class = CharsForUTF32
    def self.proxy_class=: (untyped klass) -> untyped

    # Returns the current proxy class.
    def self.proxy_class: () -> untyped
  end
end

module ActiveSupport
  module Notifications
    # This is a default queue implementation that ships with Notifications.
    # It just pushes events to all registered log subscribers.
    #
    # This class is thread safe. All methods are reentrant.
    class Fanout
      include Mutex_m

      def initialize: () -> untyped

      def subscribe: (?untyped? pattern, ?untyped? callable) { () -> untyped } -> untyped

      def unsubscribe: (untyped subscriber_or_name) -> untyped

      def start: (untyped name, untyped id, untyped payload) -> untyped

      def finish: (untyped name, untyped id, untyped payload, ?untyped listeners) -> untyped

      def publish: (untyped name, *untyped args) -> untyped

      def listeners_for: (untyped name) -> untyped

      def listening?: (untyped name) -> untyped

      # This is a sync queue, so there is no waiting.
      def wait: () -> nil

      module Subscribers
        # :nodoc:
        def self.new: (untyped pattern, untyped listener) -> untyped

        def self.event_object_subscriber: (untyped pattern, untyped block) -> untyped

        def self.wrap_all: (untyped pattern, untyped subscriber) -> untyped

        class Matcher
          # nodoc:
          attr_reader pattern: untyped

          # nodoc:
          attr_reader exclusions: untyped

          def self.wrap: (untyped pattern) -> untyped

          def initialize: (untyped pattern) -> untyped

          def unsubscribe!: (untyped name) -> untyped

          def ===: (untyped name) -> untyped
        end

        class Evented
          # nodoc:
          attr_reader pattern: untyped

          def initialize: (untyped pattern, untyped delegate) -> untyped

          def publish: (untyped name, *untyped args) -> untyped

          def start: (untyped name, untyped id, untyped payload) -> untyped

          def finish: (untyped name, untyped id, untyped payload) -> untyped

          def subscribed_to?: (untyped name) -> untyped

          def matches?: (untyped name) -> untyped

          def unsubscribe!: (untyped name) -> untyped
        end

        class Timed < Evented
          # :nodoc:
          def publish: (untyped name, *untyped args) -> untyped

          def start: (untyped name, untyped id, untyped payload) -> untyped

          def finish: (untyped name, untyped id, untyped payload) -> untyped
        end

        class EventObject < Evented
          def start: (untyped name, untyped id, untyped payload) -> untyped

          def finish: (untyped name, untyped id, untyped payload) -> untyped

          private

          def build_event: (untyped name, untyped id, untyped payload) -> ActiveSupport::Notifications::Event
        end

        class AllMessages
          # :nodoc:
          def initialize: (untyped delegate) -> untyped

          def start: (untyped name, untyped id, untyped payload) -> untyped

          def finish: (untyped name, untyped id, untyped payload) -> untyped

          def publish: (untyped name, *untyped args) -> untyped

          def subscribed_to?: (untyped name) -> ::TrueClass

          def unsubscribe!: () -> ::FalseClass

          alias matches? ===
        end
      end
    end
  end
end

module ActiveSupport
  module Notifications
    # Instrumenters are stored in a thread local.
    class Instrumenter
      attr_reader id: untyped

      def initialize: (untyped notifier) -> untyped

      # Given a block, instrument it by measuring the time taken to execute
      # and publish it. Without a block, simply send a message via the
      # notifier. Notice that events get sent even if an error occurs in the
      # passed-in block.
      def instrument: (untyped name, ?::Hash[untyped, untyped] payload) { (untyped) -> untyped } -> untyped

      # Send a start notification with +name+ and +payload+.
      def start: (untyped name, untyped payload) -> untyped

      # Send a finish notification with +name+ and +payload+.
      def finish: (untyped name, untyped payload) -> untyped

      def finish_with_state: (untyped listeners_state, untyped name, untyped payload) -> untyped

      private

      def unique_id: () -> untyped
    end

    class Event
      attr_reader name: untyped

      attr_reader time: untyped

      attr_reader end: untyped

      attr_reader transaction_id: untyped

      attr_reader payload: untyped

      attr_reader children: untyped

      def self.clock_gettime_supported?: () -> untyped

      def initialize: (untyped name, untyped start, untyped ending, untyped transaction_id, untyped payload) -> untyped

      # Record information at the time this event starts
      def start!: () -> untyped

      # Record information at the time this event finishes
      def finish!: () -> untyped

      def end=: (untyped ending) -> untyped

      # Returns the CPU time (in milliseconds) passed since the call to
      # +start!+ and the call to +finish!+
      def cpu_time: () -> untyped

      # Returns the idle time time (in milliseconds) passed since the call to
      # +start!+ and the call to +finish!+
      def idle_time: () -> untyped

      # Returns the number of allocations made since the call to +start!+ and
      # the call to +finish!+
      def allocations: () -> untyped

      # Returns the difference in milliseconds between when the execution of the
      # event started and when it ended.
      #
      #   ActiveSupport::Notifications.subscribe('wait') do |*args|
      #     @event = ActiveSupport::Notifications::Event.new(*args)
      #   end
      #
      #   ActiveSupport::Notifications.instrument('wait') do
      #     sleep 1
      #   end
      #
      #   @event.duration # => 1000.138
      def duration: () -> untyped

      def <<: (untyped event) -> untyped

      def parent_of?: (untyped event) -> untyped

      private

      def now: () -> untyped

      def now_cpu: () -> untyped

      def now_allocations: () -> untyped
    end
  end
end

module ActiveSupport
  # = Notifications
  #
  # <tt>ActiveSupport::Notifications</tt> provides an instrumentation API for
  # Ruby.
  #
  # == Instrumenters
  #
  # To instrument an event you just need to do:
  #
  #   ActiveSupport::Notifications.instrument('render', extra: :information) do
  #     render plain: 'Foo'
  #   end
  #
  # That first executes the block and then notifies all subscribers once done.
  #
  # In the example above +render+ is the name of the event, and the rest is called
  # the _payload_. The payload is a mechanism that allows instrumenters to pass
  # extra information to subscribers. Payloads consist of a hash whose contents
  # are arbitrary and generally depend on the event.
  #
  # == Subscribers
  #
  # You can consume those events and the information they provide by registering
  # a subscriber.
  #
  #   ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload|
  #     name    # => String, name of the event (such as 'render' from above)
  #     start   # => Time, when the instrumented block started execution
  #     finish  # => Time, when the instrumented block ended execution
  #     id      # => String, unique ID for the instrumenter that fired the event
  #     payload # => Hash, the payload
  #   end
  #
  # For instance, let's store all "render" events in an array:
  #
  #   events = []
  #
  #   ActiveSupport::Notifications.subscribe('render') do |*args|
  #     events << ActiveSupport::Notifications::Event.new(*args)
  #   end
  #
  # That code returns right away, you are just subscribing to "render" events.
  # The block is saved and will be called whenever someone instruments "render":
  #
  #   ActiveSupport::Notifications.instrument('render', extra: :information) do
  #     render plain: 'Foo'
  #   end
  #
  #   event = events.first
  #   event.name      # => "render"
  #   event.duration  # => 10 (in milliseconds)
  #   event.payload   # => { extra: :information }
  #
  # The block in the <tt>subscribe</tt> call gets the name of the event, start
  # timestamp, end timestamp, a string with a unique identifier for that event's instrumenter
  # (something like "535801666f04d0298cd6"), and a hash with the payload, in
  # that order.
  #
  # If an exception happens during that particular instrumentation the payload will
  # have a key <tt>:exception</tt> with an array of two elements as value: a string with
  # the name of the exception class, and the exception message.
  # The <tt>:exception_object</tt> key of the payload will have the exception
  # itself as the value:
  #
  #   event.payload[:exception]         # => ["ArgumentError", "Invalid value"]
  #   event.payload[:exception_object]  # => #<ArgumentError: Invalid value>
  #
  # As the earlier example depicts, the class <tt>ActiveSupport::Notifications::Event</tt>
  # is able to take the arguments as they come and provide an object-oriented
  # interface to that data.
  #
  # It is also possible to pass an object which responds to <tt>call</tt> method
  # as the second parameter to the <tt>subscribe</tt> method instead of a block:
  #
  #   module ActionController
  #     class PageRequest
  #       def call(name, started, finished, unique_id, payload)
  #         Rails.logger.debug ['notification:', name, started, finished, unique_id, payload].join(' ')
  #       end
  #     end
  #   end
  #
  #   ActiveSupport::Notifications.subscribe('process_action.action_controller', ActionController::PageRequest.new)
  #
  # resulting in the following output within the logs including a hash with the payload:
  #
  #   notification: process_action.action_controller 2012-04-13 01:08:35 +0300 2012-04-13 01:08:35 +0300 af358ed7fab884532ec7 {
  #      controller: "Devise::SessionsController",
  #      action: "new",
  #      params: {"action"=>"new", "controller"=>"devise/sessions"},
  #      format: :html,
  #      method: "GET",
  #      path: "/login/sign_in",
  #      status: 200,
  #      view_runtime: 279.3080806732178,
  #      db_runtime: 40.053
  #    }
  #
  # You can also subscribe to all events whose name matches a certain regexp:
  #
  #   ActiveSupport::Notifications.subscribe(/render/) do |*args|
  #     ...
  #   end
  #
  # and even pass no argument to <tt>subscribe</tt>, in which case you are subscribing
  # to all events.
  #
  # == Temporary Subscriptions
  #
  # Sometimes you do not want to subscribe to an event for the entire life of
  # the application. There are two ways to unsubscribe.
  #
  # WARNING: The instrumentation framework is designed for long-running subscribers,
  # use this feature sparingly because it wipes some internal caches and that has
  # a negative impact on performance.
  #
  # === Subscribe While a Block Runs
  #
  # You can subscribe to some event temporarily while some block runs. For
  # example, in
  #
  #   callback = lambda {|*args| ... }
  #   ActiveSupport::Notifications.subscribed(callback, "sql.active_record") do
  #     ...
  #   end
  #
  # the callback will be called for all "sql.active_record" events instrumented
  # during the execution of the block. The callback is unsubscribed automatically
  # after that.
  #
  # === Manual Unsubscription
  #
  # The +subscribe+ method returns a subscriber object:
  #
  #   subscriber = ActiveSupport::Notifications.subscribe("render") do |*args|
  #     ...
  #   end
  #
  # To prevent that block from being called anymore, just unsubscribe passing
  # that reference:
  #
  #   ActiveSupport::Notifications.unsubscribe(subscriber)
  #
  # You can also unsubscribe by passing the name of the subscriber object. Note
  # that this will unsubscribe all subscriptions with the given name:
  #
  #   ActiveSupport::Notifications.unsubscribe("render")
  #
  # Subscribers using a regexp or other pattern-matching object will remain subscribed
  # to all events that match their original pattern, unless those events match a string
  # passed to `unsubscribe`:
  #
  #   subscriber = ActiveSupport::Notifications.subscribe(/render/) { }
  #   ActiveSupport::Notifications.unsubscribe('render_template.action_view')
  #   subscriber.matches?('render_template.action_view') # => false
  #   subscriber.matches?('render_partial.action_view') # => true
  #
  # == Default Queue
  #
  # Notifications ships with a queue implementation that consumes and publishes events
  # to all log subscribers. You can use any queue implementation you want.
  #
  module Notifications
    attr_accessor self.notifier: untyped

    def self.publish: (untyped name, *untyped args) -> untyped

    def self.instrument: (untyped name, ?::Hash[untyped, untyped] payload) { (untyped) -> untyped } -> untyped

    # Subscribe to a given event name with the passed +block+.
    #
    # You can subscribe to events by passing a String to match exact event
    # names, or by passing a Regexp to match all events that match a pattern.
    #
    #   ActiveSupport::Notifications.subscribe(/render/) do |*args|
    #     @event = ActiveSupport::Notifications::Event.new(*args)
    #   end
    #
    # The +block+ will receive five parameters with information about the event:
    #
    #   ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload|
    #     name    # => String, name of the event (such as 'render' from above)
    #     start   # => Time, when the instrumented block started execution
    #     finish  # => Time, when the instrumented block ended execution
    #     id      # => String, unique ID for the instrumenter that fired the event
    #     payload # => Hash, the payload
    #   end
    #
    # If the block passed to the method only takes one parameter,
    # it will yield an event object to the block:
    #
    #   ActiveSupport::Notifications.subscribe(/render/) do |event|
    #     @event = event
    #   end
    def self.subscribe: (*untyped args) { () -> untyped } -> untyped

    def self.subscribed: (untyped callback, *untyped args) { () -> untyped } -> untyped

    def self.unsubscribe: (untyped subscriber_or_name) -> untyped

    def self.instrumenter: () -> untyped

    class InstrumentationRegistry
      # This class is a registry which holds all of the +Instrumenter+ objects
      # in a particular thread local. To access the +Instrumenter+ object for a
      # particular +notifier+, you can call the following method:
      #
      #   InstrumentationRegistry.instrumenter_for(notifier)
      #
      # The instrumenters for multiple notifiers are held in a single instance of
      # this class.
      # :nodoc:
      extend ActiveSupport::PerThreadRegistry

      def initialize: () -> untyped

      def instrumenter_for: (untyped notifier) -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    class NumberConverter
      attr_reader number: untyped

      attr_reader opts: untyped

      DEFAULTS: ::Hash[untyped, untyped]

      def self.convert: (untyped number, untyped options) -> untyped

      def initialize: (untyped number, untyped options) -> untyped

      def execute: () -> untyped

      private

      def options: () -> untyped

      def format_options: () -> untyped

      def default_format_options: () -> untyped

      def i18n_format_options: () -> untyped

      def translate_number_value_with_default: (untyped key, **untyped i18n_options) -> untyped

      def translate_in_locale: (untyped key, **untyped i18n_options) -> untyped

      def default_value: (untyped key) -> untyped

      def valid_float?: () -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    class NumberToCurrencyConverter < NumberConverter
      def convert: () -> untyped

      private

      def options: () -> untyped

      def i18n_opts: () -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    class NumberToDelimitedConverter < NumberConverter
      DEFAULT_DELIMITER_REGEX: untyped

      def convert: () -> untyped

      private

      def parts: () -> untyped

      def delimiter_pattern: () -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    class NumberToHumanConverter < NumberConverter
      # :nodoc:
      DECIMAL_UNITS: ::Hash[untyped, untyped]

      INVERTED_DECIMAL_UNITS: untyped

      def convert: () -> untyped

      private

      def format: () -> untyped

      def determine_unit: (untyped units, untyped exponent) -> untyped

      def calculate_exponent: (untyped units) -> untyped

      def unit_exponents: (untyped units) -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    class NumberToHumanSizeConverter < NumberConverter
      # nodoc:
      STORAGE_UNITS: ::Array[untyped]

      def convert: () -> untyped

      private

      def conversion_format: () -> untyped

      def unit: () -> untyped

      def storage_unit_key: () -> ::String

      def exponent: () -> untyped

      def smaller_than_base?: () -> untyped

      def base: () -> 1024
    end
  end
end

module ActiveSupport
  module NumberHelper
    class NumberToPercentageConverter < NumberConverter
      def convert: () -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    class NumberToPhoneConverter < NumberConverter
      # nodoc:
      def convert: () -> untyped

      private

      def convert_to_phone_number: (untyped number) -> untyped

      def convert_with_area_code: (untyped number) -> untyped

      def convert_without_area_code: (untyped number) -> untyped

      def start_with_delimiter?: (untyped number) -> untyped

      def delimiter: () -> untyped

      def country_code: (untyped code) -> untyped

      def phone_ext: (untyped ext) -> untyped

      def regexp_pattern: (untyped default_pattern) -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    class NumberToRoundedConverter < NumberConverter
      def convert: () -> untyped

      private

      def strip_insignificant_zeros: () -> untyped

      def format_number: (untyped number) -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    class RoundingHelper
      # :nodoc:
      attr_reader options: untyped

      def initialize: (untyped options) -> untyped

      def round: (untyped number) -> untyped

      def digit_count: (untyped number) -> (1 | untyped)

      private

      def round_without_significant: (untyped number) -> untyped

      def round_significant: (untyped number) -> (0 | untyped)

      def convert_to_decimal: (untyped number) -> untyped

      def precision: () -> untyped

      def significant: () -> untyped

      def absolute_number: (untyped number) -> untyped
    end
  end
end

module ActiveSupport
  module NumberHelper
    extend ActiveSupport::Autoload

    extend ::ActiveSupport::NumberHelper

    # Formats a +number+ into a phone number (US by default e.g., (555)
    # 123-9876). You can customize the format in the +options+ hash.
    #
    # ==== Options
    #
    # * <tt>:area_code</tt> - Adds parentheses around the area code.
    # * <tt>:delimiter</tt> - Specifies the delimiter to use
    #   (defaults to "-").
    # * <tt>:extension</tt> - Specifies an extension to add to the
    #   end of the generated number.
    # * <tt>:country_code</tt> - Sets the country code for the phone
    #   number.
    # * <tt>:pattern</tt> - Specifies how the number is divided into three
    #   groups with the custom regexp to override the default format.
    # ==== Examples
    #
    #   number_to_phone(5551234)                                     # => "555-1234"
    #   number_to_phone('5551234')                                   # => "555-1234"
    #   number_to_phone(1235551234)                                  # => "123-555-1234"
    #   number_to_phone(1235551234, area_code: true)                 # => "(123) 555-1234"
    #   number_to_phone(1235551234, delimiter: ' ')                  # => "123 555 1234"
    #   number_to_phone(1235551234, area_code: true, extension: 555) # => "(123) 555-1234 x 555"
    #   number_to_phone(1235551234, country_code: 1)                 # => "+1-123-555-1234"
    #   number_to_phone('123a456')                                   # => "123a456"
    #
    #   number_to_phone(1235551234, country_code: 1, extension: 1343, delimiter: '.')
    #   # => "+1.123.555.1234 x 1343"
    #
    #   number_to_phone(75561234567, pattern: /(\d{1,4})(\d{4})(\d{4})$/, area_code: true)
    #   # => "(755) 6123-4567"
    #   number_to_phone(13312345678, pattern: /(\d{3})(\d{4})(\d{4})$/)
    #   # => "133-1234-5678"
    def number_to_phone: (untyped number, ?::Hash[untyped, untyped] options) -> untyped

    # Formats a +number+ into a currency string (e.g., $13.65). You
    # can customize the format in the +options+ hash.
    #
    # The currency unit and number formatting of the current locale will be used
    # unless otherwise specified in the provided options. No currency conversion
    # is performed. If the user is given a way to change their locale, they will
    # also be able to change the relative value of the currency displayed with
    # this helper. If your application will ever support multiple locales, you
    # may want to specify a constant <tt>:locale</tt> option or consider
    # using a library capable of currency conversion.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the level of precision (defaults
    #   to 2).
    # * <tt>:unit</tt> - Sets the denomination of the currency
    #   (defaults to "$").
    # * <tt>:separator</tt> - Sets the separator between the units
    #   (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to ",").
    # * <tt>:format</tt> - Sets the format for non-negative numbers
    #   (defaults to "%u%n").  Fields are <tt>%u</tt> for the
    #   currency, and <tt>%n</tt> for the number.
    # * <tt>:negative_format</tt> - Sets the format for negative
    #   numbers (defaults to prepending a hyphen to the formatted
    #   number given by <tt>:format</tt>).  Accepts the same fields
    #   than <tt>:format</tt>, except <tt>%n</tt> is here the
    #   absolute value of the number.
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +false+).
    #
    # ==== Examples
    #
    #   number_to_currency(1234567890.50)                # => "$1,234,567,890.50"
    #   number_to_currency(1234567890.506)               # => "$1,234,567,890.51"
    #   number_to_currency(1234567890.506, precision: 3) # => "$1,234,567,890.506"
    #   number_to_currency(1234567890.506, locale: :fr)  # => "1 234 567 890,51 (trim non-ascii characters)"
    #   number_to_currency('123a456')                    # => "$123a456"
    #
    #   number_to_currency("123a456", raise: true)       # => InvalidNumberError
    #
    #   number_to_currency(-0.456789, precision: 0)
    #   # => "$0"
    #   number_to_currency(-1234567890.50, negative_format: '(%u%n)')
    #   # => "($1,234,567,890.50)"
    #   number_to_currency(1234567890.50, unit: '&pound;', separator: ',', delimiter: '')
    #   # => "&pound;1234567890,50"
    #   number_to_currency(1234567890.50, unit: '&pound;', separator: ',', delimiter: '', format: '%n %u')
    #   # => "1234567890,50 &pound;"
    #   number_to_currency(1234567890.50, strip_insignificant_zeros: true)
    #   # => "$1,234,567,890.5"
    def number_to_currency: (untyped number, ?::Hash[untyped, untyped] options) -> untyped

    # Formats a +number+ as a percentage string (e.g., 65%). You can
    # customize the format in the +options+ hash.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the precision of the number
    #   (defaults to 3). Keeps the number's precision if +nil+.
    # * <tt>:significant</tt> - If +true+, precision will be the number
    #   of significant_digits. If +false+, the number of fractional
    #   digits (defaults to +false+).
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to "").
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +false+).
    # * <tt>:format</tt> - Specifies the format of the percentage
    #   string The number field is <tt>%n</tt> (defaults to "%n%").
    #
    # ==== Examples
    #
    #   number_to_percentage(100)                                  # => "100.000%"
    #   number_to_percentage('98')                                 # => "98.000%"
    #   number_to_percentage(100, precision: 0)                    # => "100%"
    #   number_to_percentage(1000, delimiter: '.', separator: ',') # => "1.000,000%"
    #   number_to_percentage(302.24398923423, precision: 5)        # => "302.24399%"
    #   number_to_percentage(1000, locale: :fr)                    # => "1000,000%"
    #   number_to_percentage(1000, precision: nil)                 # => "1000%"
    #   number_to_percentage('98a')                                # => "98a%"
    #   number_to_percentage(100, format: '%n  %')                 # => "100.000  %"
    def number_to_percentage: (untyped number, ?::Hash[untyped, untyped] options) -> untyped

    # Formats a +number+ with grouped thousands using +delimiter+
    # (e.g., 12,324). You can customize the format in the +options+
    # hash.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to ",").
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter_pattern</tt> - Sets a custom regular expression used for
    #   deriving the placement of delimiter. Helpful when using currency formats
    #   like INR.
    #
    # ==== Examples
    #
    #   number_to_delimited(12345678)                    # => "12,345,678"
    #   number_to_delimited('123456')                    # => "123,456"
    #   number_to_delimited(12345678.05)                 # => "12,345,678.05"
    #   number_to_delimited(12345678, delimiter: '.')    # => "12.345.678"
    #   number_to_delimited(12345678, delimiter: ',')    # => "12,345,678"
    #   number_to_delimited(12345678.05, separator: ' ') # => "12,345,678 05"
    #   number_to_delimited(12345678.05, locale: :fr)    # => "12 345 678,05"
    #   number_to_delimited('112a')                      # => "112a"
    #   number_to_delimited(98765432.98, delimiter: ' ', separator: ',')
    #                                                    # => "98 765 432,98"
    #   number_to_delimited("123456.78",
    #     delimiter_pattern: /(\d+?)(?=(\d\d)+(\d)(?!\d))/)
    #                                                    # => "1,23,456.78"
    def number_to_delimited: (untyped number, ?::Hash[untyped, untyped] options) -> untyped

    # Formats a +number+ with the specified level of
    # <tt>:precision</tt> (e.g., 112.32 has a precision of 2 if
    # +:significant+ is +false+, and 5 if +:significant+ is +true+).
    # You can customize the format in the +options+ hash.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the precision of the number
    #   (defaults to 3). Keeps the number's precision if +nil+.
    # * <tt>:significant</tt> - If +true+, precision will be the number
    #   of significant_digits. If +false+, the number of fractional
    #   digits (defaults to +false+).
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to "").
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +false+).
    #
    # ==== Examples
    #
    #   number_to_rounded(111.2345)                                  # => "111.235"
    #   number_to_rounded(111.2345, precision: 2)                    # => "111.23"
    #   number_to_rounded(13, precision: 5)                          # => "13.00000"
    #   number_to_rounded(389.32314, precision: 0)                   # => "389"
    #   number_to_rounded(111.2345, significant: true)               # => "111"
    #   number_to_rounded(111.2345, precision: 1, significant: true) # => "100"
    #   number_to_rounded(13, precision: 5, significant: true)       # => "13.000"
    #   number_to_rounded(13, precision: nil)                        # => "13"
    #   number_to_rounded(111.234, locale: :fr)                      # => "111,234"
    #
    #   number_to_rounded(13, precision: 5, significant: true, strip_insignificant_zeros: true)
    #   # => "13"
    #
    #   number_to_rounded(389.32314, precision: 4, significant: true) # => "389.3"
    #   number_to_rounded(1111.2345, precision: 2, separator: ',', delimiter: '.')
    #   # => "1.111,23"
    def number_to_rounded: (untyped number, ?::Hash[untyped, untyped] options) -> untyped

    # Formats the bytes in +number+ into a more understandable
    # representation (e.g., giving it 1500 yields 1.5 KB). This
    # method is useful for reporting file sizes to users. You can
    # customize the format in the +options+ hash.
    #
    # See <tt>number_to_human</tt> if you want to pretty-print a
    # generic number.
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the precision of the number
    #   (defaults to 3).
    # * <tt>:significant</tt> - If +true+, precision will be the number
    #   of significant_digits. If +false+, the number of fractional
    #   digits (defaults to +true+)
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to "").
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +true+)
    #
    # ==== Examples
    #
    #   number_to_human_size(123)                                    # => "123 Bytes"
    #   number_to_human_size(1234)                                   # => "1.21 KB"
    #   number_to_human_size(12345)                                  # => "12.1 KB"
    #   number_to_human_size(1234567)                                # => "1.18 MB"
    #   number_to_human_size(1234567890)                             # => "1.15 GB"
    #   number_to_human_size(1234567890123)                          # => "1.12 TB"
    #   number_to_human_size(1234567890123456)                       # => "1.1 PB"
    #   number_to_human_size(1234567890123456789)                    # => "1.07 EB"
    #   number_to_human_size(1234567, precision: 2)                  # => "1.2 MB"
    #   number_to_human_size(483989, precision: 2)                   # => "470 KB"
    #   number_to_human_size(1234567, precision: 2, separator: ',')  # => "1,2 MB"
    #   number_to_human_size(1234567890123, precision: 5)            # => "1.1228 TB"
    #   number_to_human_size(524288000, precision: 5)                # => "500 MB"
    def number_to_human_size: (untyped number, ?::Hash[untyped, untyped] options) -> untyped

    # Pretty prints (formats and approximates) a number in a way it
    # is more readable by humans (eg.: 1200000000 becomes "1.2
    # Billion"). This is useful for numbers that can get very large
    # (and too hard to read).
    #
    # See <tt>number_to_human_size</tt> if you want to print a file
    # size.
    #
    # You can also define your own unit-quantifier names if you want
    # to use other decimal units (eg.: 1500 becomes "1.5
    # kilometers", 0.150 becomes "150 milliliters", etc). You may
    # define a wide range of unit quantifiers, even fractional ones
    # (centi, deci, mili, etc).
    #
    # ==== Options
    #
    # * <tt>:locale</tt> - Sets the locale to be used for formatting
    #   (defaults to current locale).
    # * <tt>:precision</tt> - Sets the precision of the number
    #   (defaults to 3).
    # * <tt>:significant</tt> - If +true+, precision will be the number
    #   of significant_digits. If +false+, the number of fractional
    #   digits (defaults to +true+)
    # * <tt>:separator</tt> - Sets the separator between the
    #   fractional and integer digits (defaults to ".").
    # * <tt>:delimiter</tt> - Sets the thousands delimiter (defaults
    #   to "").
    # * <tt>:strip_insignificant_zeros</tt> - If +true+ removes
    #   insignificant zeros after the decimal separator (defaults to
    #   +true+)
    # * <tt>:units</tt> - A Hash of unit quantifier names. Or a
    #   string containing an i18n scope where to find this hash. It
    #   might have the following keys:
    #   * *integers*: <tt>:unit</tt>, <tt>:ten</tt>,
    #     <tt>:hundred</tt>, <tt>:thousand</tt>, <tt>:million</tt>,
    #     <tt>:billion</tt>, <tt>:trillion</tt>,
    #     <tt>:quadrillion</tt>
    #   * *fractionals*: <tt>:deci</tt>, <tt>:centi</tt>,
    #     <tt>:mili</tt>, <tt>:micro</tt>, <tt>:nano</tt>,
    #     <tt>:pico</tt>, <tt>:femto</tt>
    # * <tt>:format</tt> - Sets the format of the output string
    #   (defaults to "%n %u"). The field types are:
    #   * %u - The quantifier (ex.: 'thousand')
    #   * %n - The number
    #
    # ==== Examples
    #
    #   number_to_human(123)                         # => "123"
    #   number_to_human(1234)                        # => "1.23 Thousand"
    #   number_to_human(12345)                       # => "12.3 Thousand"
    #   number_to_human(1234567)                     # => "1.23 Million"
    #   number_to_human(1234567890)                  # => "1.23 Billion"
    #   number_to_human(1234567890123)               # => "1.23 Trillion"
    #   number_to_human(1234567890123456)            # => "1.23 Quadrillion"
    #   number_to_human(1234567890123456789)         # => "1230 Quadrillion"
    #   number_to_human(489939, precision: 2)        # => "490 Thousand"
    #   number_to_human(489939, precision: 4)        # => "489.9 Thousand"
    #   number_to_human(1234567, precision: 4,
    #                            significant: false) # => "1.2346 Million"
    #   number_to_human(1234567, precision: 1,
    #                            separator: ',',
    #                            significant: false) # => "1,2 Million"
    #
    #   number_to_human(500000000, precision: 5)           # => "500 Million"
    #   number_to_human(12345012345, significant: false)   # => "12.345 Billion"
    #
    # Non-significant zeros after the decimal separator are stripped
    # out by default (set <tt>:strip_insignificant_zeros</tt> to
    # +false+ to change that):
    #
    # number_to_human(12.00001)                                       # => "12"
    # number_to_human(12.00001, strip_insignificant_zeros: false)     # => "12.0"
    #
    # ==== Custom Unit Quantifiers
    #
    # You can also use your own custom unit quantifiers:
    #  number_to_human(500000, units: { unit: 'ml', thousand: 'lt' })  # => "500 lt"
    #
    # If in your I18n locale you have:
    #
    #   distance:
    #     centi:
    #       one: "centimeter"
    #       other: "centimeters"
    #     unit:
    #       one: "meter"
    #       other: "meters"
    #     thousand:
    #       one: "kilometer"
    #       other: "kilometers"
    #     billion: "gazillion-distance"
    #
    # Then you could do:
    #
    #   number_to_human(543934, units: :distance)            # => "544 kilometers"
    #   number_to_human(54393498, units: :distance)          # => "54400 kilometers"
    #   number_to_human(54393498000, units: :distance)       # => "54.4 gazillion-distance"
    #   number_to_human(343, units: :distance, precision: 1) # => "300 meters"
    #   number_to_human(1, units: :distance)                 # => "1 meter"
    #   number_to_human(0.34, units: :distance)              # => "34 centimeters"
    def number_to_human: (untyped number, ?::Hash[untyped, untyped] options) -> untyped
  end
end

module ActiveSupport
  class OptionMerger
    def initialize: (untyped context, untyped options) -> untyped

    private

    def method_missing: (untyped method, *untyped arguments) { () -> untyped } -> untyped

    def invoke_method: (untyped method, untyped arguments, untyped options) { () -> untyped } -> untyped
  end
end

module ActiveSupport
  # DEPRECATED: <tt>ActiveSupport::OrderedHash</tt> implements a hash that preserves
  # insertion order.
  #
  #   oh = ActiveSupport::OrderedHash.new
  #   oh[:a] = 1
  #   oh[:b] = 2
  #   oh.keys # => [:a, :b], this order is guaranteed
  #
  # Also, maps the +omap+ feature for YAML files
  # (See https://yaml.org/type/omap.html) to support ordered items
  # when loading from yaml.
  #
  # <tt>ActiveSupport::OrderedHash</tt> is namespaced to prevent conflicts
  # with other implementations.
  class OrderedHash[T, U] < ::Hash[T, U]
    def to_yaml_type: () -> "!tag:yaml.org,2002:omap"

    def encode_with: (untyped coder) -> untyped

    def select: (*untyped args) { () -> untyped } -> untyped

    def reject: (*untyped args) { () -> untyped } -> untyped

    def nested_under_indifferent_access: () -> untyped

    # Returns true to make sure that this hash is extractable via <tt>Array#extract_options!</tt>
    def extractable_options?: () -> ::TrueClass
  end
end

module ActiveSupport
  # Usually key value pairs are handled something like this:
  #
  #   h = {}
  #   h[:boy] = 'John'
  #   h[:girl] = 'Mary'
  #   h[:boy]  # => 'John'
  #   h[:girl] # => 'Mary'
  #   h[:dog]  # => nil
  #
  # Using +OrderedOptions+, the above code could be reduced to:
  #
  #   h = ActiveSupport::OrderedOptions.new
  #   h.boy = 'John'
  #   h.girl = 'Mary'
  #   h.boy  # => 'John'
  #   h.girl # => 'Mary'
  #   h.dog  # => nil
  #
  # To raise an exception when the value is blank, append a
  # bang to the key name, like:
  #
  #   h.dog! # => raises KeyError: :dog is blank
  #
  class OrderedOptions[T, U] < Hash[T, U]
    alias _get []

    def []=: (untyped key, untyped value) -> untyped

    def []: (untyped key) -> untyped

    def method_missing: (untyped name, *untyped args) -> untyped

    def respond_to_missing?: (untyped name, untyped include_private) -> ::TrueClass

    def extractable_options?: () -> ::TrueClass
  end

  # +InheritableOptions+ provides a constructor to build an +OrderedOptions+
  # hash inherited from another hash.
  #
  # Use this if you already have some hash and you want to create a new one based on it.
  #
  #   h = ActiveSupport::InheritableOptions.new({ girl: 'Mary', boy: 'John' })
  #   h.girl # => 'Mary'
  #   h.boy  # => 'John'
  class InheritableOptions[T, U] < OrderedOptions[T, U]
    def initialize: (?untyped? parent) -> untyped

    def inheritable_copy: () -> untyped
  end
end

module ActiveSupport
  # +ParameterFilter+ allows you to specify keys for sensitive data from
  # hash-like object and replace corresponding value. Filtering only certain
  # sub-keys from a hash is possible by using the dot notation:
  # 'credit_card.number'. If a proc is given, each key and value of a hash and
  # all sub-hashes are passed to it, where the value or the key can be replaced
  # using String#replace or similar methods.
  #
  #   ActiveSupport::ParameterFilter.new([:password])
  #   => replaces the value to all keys matching /password/i with "[FILTERED]"
  #
  #   ActiveSupport::ParameterFilter.new([:foo, "bar"])
  #   => replaces the value to all keys matching /foo|bar/i with "[FILTERED]"
  #
  #   ActiveSupport::ParameterFilter.new(["credit_card.code"])
  #   => replaces { credit_card: {code: "xxxx"} } with "[FILTERED]", does not
  #   change { file: { code: "xxxx"} }
  #
  #   ActiveSupport::ParameterFilter.new([-> (k, v) do
  #     v.reverse! if k =~ /secret/i
  #   end])
  #   => reverses the value to all keys matching /secret/i
  class ParameterFilter
    FILTERED: ::String

    # Create instance with given filters. Supported type of filters are +String+, +Regexp+, and +Proc+.
    # Other types of filters are treated as +String+ using +to_s+.
    # For +Proc+ filters, key, value, and optional original hash is passed to block arguments.
    #
    # ==== Options
    #
    # * <tt>:mask</tt> - A replaced object when filtered. Defaults to +"[FILTERED]"+
    def initialize: (?untyped filters, ?mask: untyped mask) -> untyped

    # Mask value of +params+ if key matches one of filters.
    def filter: (untyped params) -> untyped

    # Returns filtered value for given key. For +Proc+ filters, third block argument is not populated.
    def filter_param: (untyped key, untyped value) -> untyped

    private

    def compiled_filter: () -> untyped

    class CompiledFilter
      # :nodoc:
      def self.compile: (untyped filters, mask: untyped mask) -> untyped

      attr_reader regexps: untyped

      attr_reader deep_regexps: untyped

      attr_reader blocks: untyped

      def initialize: (untyped regexps, untyped deep_regexps, untyped blocks, mask: untyped mask) -> untyped

      def call: (untyped params, ?untyped parents, ?untyped original_params) -> untyped

      def value_for_key: (untyped key, untyped value, ?untyped parents, ?untyped? original_params) -> untyped
    end
  end
end

module ActiveSupport
  # NOTE: This approach has been deprecated for end-user code in favor of {thread_mattr_accessor}[rdoc-ref:Module#thread_mattr_accessor] and friends.
  # Please use that approach instead.
  #
  # This module is used to encapsulate access to thread local variables.
  #
  # Instead of polluting the thread locals namespace:
  #
  #   Thread.current[:connection_handler]
  #
  # you define a class that extends this module:
  #
  #   module ActiveRecord
  #     class RuntimeRegistry
  #       extend ActiveSupport::PerThreadRegistry
  #
  #       attr_accessor :connection_handler
  #     end
  #   end
  #
  # and invoke the declared instance accessors as class methods. So
  #
  #   ActiveRecord::RuntimeRegistry.connection_handler = connection_handler
  #
  # sets a connection handler local to the current thread, and
  #
  #   ActiveRecord::RuntimeRegistry.connection_handler
  #
  # returns a connection handler local to the current thread.
  #
  # This feature is accomplished by instantiating the class and storing the
  # instance as a thread local keyed by the class name. In the example above
  # a key "ActiveRecord::RuntimeRegistry" is stored in <tt>Thread.current</tt>.
  # The class methods proxy to said thread local instance.
  #
  # If the class has an initializer, it must accept no arguments.
  module PerThreadRegistry
    def self.extended: (untyped object) -> untyped

    def instance: () -> untyped

    private

    def method_missing: (untyped name, *untyped args) { () -> untyped } -> untyped
  end
end

module ActiveSupport
  # A class with no predefined methods that behaves similarly to Builder's
  # BlankSlate. Used for proxy classes.
  class ProxyObject < ::BasicObject
    # Let ActiveSupport::ProxyObject at least raise exceptions.
    def raise: (*untyped args) -> untyped
  end
end

module ActiveSupport
  class Railtie < Rails::Railtie
  end
end

module ActiveSupport
  # -
  # This class defines several callbacks:
  #
  #   to_prepare -- Run once at application startup, and also from
  #   +to_run+.
  #
  #   to_run -- Run before a work run that is reloading. If
  #   +reload_classes_only_on_change+ is true (the default), the class
  #   unload will have already occurred.
  #
  #   to_complete -- Run after a work run that has reloaded. If
  #   +reload_classes_only_on_change+ is false, the class unload will
  #   have occurred after the work run, but before this callback.
  #
  #   before_class_unload -- Run immediately before the classes are
  #   unloaded.
  #
  #   after_class_unload -- Run immediately after the classes are
  #   unloaded.
  #
  class Reloader < ExecutionWrapper
    # Registers a callback that will run once at application startup and every time the code is reloaded.
    def self.to_prepare: (*untyped args) { () -> untyped } -> untyped

    # Registers a callback that will run immediately before the classes are unloaded.
    def self.before_class_unload: (*untyped args) { () -> untyped } -> untyped

    # Registers a callback that will run immediately after the classes are unloaded.
    def self.after_class_unload: (*untyped args) { () -> untyped } -> untyped

    # Initiate a manual reload
    def self.reload!: () -> untyped

    def self.run!: () -> untyped

    # Run the supplied block as a work unit, reloading code as needed
    def self.wrap: () -> untyped

    def self.check!: () -> untyped

    def self.reloaded!: () -> untyped

    def self.prepare!: () -> untyped

    def initialize: () -> untyped

    # Acquire the ActiveSupport::Dependencies::Interlock unload lock,
    # ensuring it will be released automatically
    def require_unload_lock!: () -> untyped

    # Release the unload lock if it has been previously obtained
    def release_unload_lock!: () -> untyped

    def run!: () -> untyped

    def class_unload!: () { () -> untyped } -> untyped

    def complete!: () -> untyped
  end
end

module ActiveSupport
  # Rescuable module adds support for easier exception handling.
  module Rescuable
    extend Concern

    module ClassMethods
      # Rescue exceptions raised in controller actions.
      #
      # <tt>rescue_from</tt> receives a series of exception classes or class
      # names, and a trailing <tt>:with</tt> option with the name of a method
      # or a Proc object to be called to handle them. Alternatively a block can
      # be given.
      #
      # Handlers that take one argument will be called with the exception, so
      # that the exception can be inspected when dealing with it.
      #
      # Handlers are inherited. They are searched from right to left, from
      # bottom to top, and up the hierarchy. The handler of the first class for
      # which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if
      # any.
      #
      #   class ApplicationController < ActionController::Base
      #     rescue_from User::NotAuthorized, with: :deny_access # self defined exception
      #     rescue_from ActiveRecord::RecordInvalid, with: :show_errors
      #
      #     rescue_from 'MyAppError::Base' do |exception|
      #       render xml: exception, status: 500
      #     end
      #
      #     private
      #       def deny_access
      #         ...
      #       end
      #
      #       def show_errors(exception)
      #         exception.record.new_record? ? ...
      #       end
      #   end
      #
      # Exceptions raised inside exception handlers are not propagated up.
      def rescue_from: (*untyped klasses, ?with: untyped? with) { () -> untyped } -> untyped

      # Matches an exception to a handler based on the exception class.
      #
      # If no handler matches the exception, check for a handler matching the
      # (optional) exception.cause. If no handler matches the exception or its
      # cause, this returns +nil+, so you can deal with unhandled exceptions.
      # Be sure to re-raise unhandled exceptions if this is what you expect.
      #
      #     begin
      #       (trim non-ascii characters)
      #     rescue => exception
      #       rescue_with_handler(exception) || raise
      #     end
      #
      # Returns the exception if it was handled and +nil+ if it was not.
      def rescue_with_handler: (untyped exception, ?visited_exceptions: untyped visited_exceptions, ?object: untyped object) -> untyped

      def handler_for_rescue: (untyped exception, ?object: untyped object) -> untyped

      private

      def find_rescue_handler: (untyped exception) -> untyped

      def constantize_rescue_handler_class: (untyped class_or_name) -> untyped
    end

    # Delegates to the class method, but uses the instance as the subject for
    # rescue_from handlers (method calls, instance_exec blocks).
    def rescue_with_handler: (untyped exception) -> untyped

    def handler_for_rescue: (untyped exception) -> untyped
  end
end

module ActiveSupport
  module SecurityUtils
    # Constant time string comparison, for fixed length strings.
    #
    # The values compared should be of fixed length, such as strings
    # that have already been processed by HMAC. Raises in case of length mismatch.
    def self?.fixed_length_secure_compare: (untyped a, untyped b) -> untyped

    # Constant time string comparison, for variable length strings.
    #
    # The values are first processed by SHA256, so that we don't leak length info
    # via timing attacks.
    def self?.secure_compare: (untyped a, untyped b) -> untyped
  end
end

module ActiveSupport
  # Wrapping a string in this class gives you a prettier way to test
  # for equality. The value returned by <tt>Rails.env</tt> is wrapped
  # in a StringInquirer object, so instead of calling this:
  #
  #   Rails.env == 'production'
  #
  # you can call this:
  #
  #   Rails.env.production?
  #
  # == Instantiating a new StringInquirer
  #
  #   vehicle = ActiveSupport::StringInquirer.new('car')
  #   vehicle.car?   # => true
  #   vehicle.bike?  # => false
  class StringInquirer < String
    private

    def respond_to_missing?: (untyped method_name, ?bool include_private) -> untyped

    def method_missing: (untyped method_name, *untyped arguments) -> untyped
  end
end

module ActiveSupport
  # ActiveSupport::Subscriber is an object set to consume
  # ActiveSupport::Notifications. The subscriber dispatches notifications to
  # a registered object based on its given namespace.
  #
  # An example would be an Active Record subscriber responsible for collecting
  # statistics about queries:
  #
  #   module ActiveRecord
  #     class StatsSubscriber < ActiveSupport::Subscriber
  #       attach_to :active_record
  #
  #       def sql(event)
  #         Statsd.timing("sql.#{event.payload[:name]}", event.duration)
  #       end
  #     end
  #   end
  #
  # After configured, whenever a "sql.active_record" notification is published,
  # it will properly dispatch the event (ActiveSupport::Notifications::Event) to
  # the +sql+ method.
  #
  # We can detach a subscriber as well:
  #
  #   ActiveRecord::StatsSubscriber.detach_from(:active_record)
  class Subscriber
    # Attach the subscriber to a namespace.
    def self.attach_to: (untyped namespace, ?untyped subscriber, ?untyped notifier) -> untyped

    # Detach the subscriber from a namespace.
    def self.detach_from: (untyped namespace, ?untyped notifier) -> (nil | untyped)

    # Adds event subscribers for all new methods added to the class.
    def self.method_added: (untyped event) -> untyped

    def self.subscribers: () -> untyped

    private

    attr_reader self.subscriber: untyped

    attr_reader self.notifier: untyped

    attr_reader self.namespace: untyped

    def self.add_event_subscriber: (untyped event) -> (nil | untyped)

    def self.remove_event_subscriber: (untyped event) -> (nil | untyped)

    def self.find_attached_subscriber: () -> untyped

    def self.invalid_event?: (untyped event) -> untyped

    def self.prepare_pattern: (untyped event) -> ::String

    def self.pattern_subscribed?: (untyped pattern) -> untyped

    public

    attr_reader patterns: untyped

    def initialize: () -> untyped

    def start: (untyped name, untyped id, untyped payload) -> untyped

    def finish: (untyped name, untyped id, untyped payload) -> untyped

    private

    def event_stack: () -> untyped
  end

  class SubscriberQueueRegistry
    # This is a registry for all the event stacks kept for subscribers.
    #
    # See the documentation of <tt>ActiveSupport::PerThreadRegistry</tt>
    # for further details.
    # :nodoc:
    extend PerThreadRegistry

    def initialize: () -> untyped

    def get_queue: (untyped queue_key) -> untyped
  end
end

module ActiveSupport
  # Wraps any standard Logger object to provide tagging capabilities.
  #
  #   logger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
  #   logger.tagged('BCX') { logger.info 'Stuff' }                            # Logs "[BCX] Stuff"
  #   logger.tagged('BCX', "Jason") { logger.info 'Stuff' }                   # Logs "[BCX] [Jason] Stuff"
  #   logger.tagged('BCX') { logger.tagged('Jason') { logger.info 'Stuff' } } # Logs "[BCX] [Jason] Stuff"
  #
  # This is used by the default Rails.logger as configured by Railties to make
  # it easy to stamp log lines with subdomains, request ids, and anything else
  # to aid debugging of multi-user production applications.
  module TaggedLogging
    module Formatter
      # :nodoc:
      # This method is invoked when a log event occurs.
      def call: (untyped severity, untyped timestamp, untyped progname, untyped msg) -> untyped

      def tagged: (*untyped tags) { (untyped) -> untyped } -> untyped

      def push_tags: (*untyped tags) -> untyped

      def pop_tags: (?::Integer size) -> untyped

      def clear_tags!: () -> untyped

      def current_tags: () -> untyped

      def tags_text: () -> untyped
    end

    def self.new: (untyped logger) -> untyped

    def tagged: (*untyped tags) { (untyped) -> untyped } -> untyped

    def flush: () -> untyped
  end
end

module ActiveSupport
  class TestCase < ::Minitest::Test
    Assertion: untyped

    # Sets the order in which test cases are run.
    #
    #   ActiveSupport::TestCase.test_order = :random # => :random
    #
    # Valid values are:
    # * +:random+   (to run tests in random order)
    # * +:parallel+ (to run tests in parallel)
    # * +:sorted+   (to run tests alphabetically by method name)
    # * +:alpha+    (equivalent to +:sorted+)
    def self.test_order=: (untyped new_order) -> untyped

    # Returns the order in which test cases are run.
    #
    #   ActiveSupport::TestCase.test_order # => :random
    #
    # Possible values are +:random+, +:parallel+, +:alpha+, +:sorted+.
    # Defaults to +:random+.
    def self.test_order: () -> untyped

    # Parallelizes the test suite.
    #
    # Takes a +workers+ argument that controls how many times the process
    # is forked. For each process a new database will be created suffixed
    # with the worker number.
    #
    #   test-database-0
    #   test-database-1
    #
    # If <tt>ENV["PARALLEL_WORKERS"]</tt> is set the workers argument will be ignored
    # and the environment variable will be used instead. This is useful for CI
    # environments, or other environments where you may need more workers than
    # you do for local testing.
    #
    # If the number of workers is set to +1+ or fewer, the tests will not be
    # parallelized.
    #
    # If +workers+ is set to +:number_of_processors+, the number of workers will be
    # set to the actual core count on the machine you are on.
    #
    # The default parallelization method is to fork processes. If you'd like to
    # use threads instead you can pass <tt>with: :threads</tt> to the +parallelize+
    # method. Note the threaded parallelization does not create multiple
    # database and will not work with system tests at this time.
    #
    #   parallelize(workers: :number_of_processors, with: :threads)
    #
    # The threaded parallelization uses minitest's parallel executor directly.
    # The processes parallelization uses a Ruby DRb server.
    def self.parallelize: (?with: ::Symbol with, ?workers: ::Symbol workers) -> (nil | untyped)

    # Set up hook for parallel testing. This can be used if you have multiple
    # databases or any behavior that needs to be run after the process is forked
    # but before the tests run.
    #
    # Note: this feature is not available with the threaded parallelization.
    #
    # In your +test_helper.rb+ add the following:
    #
    #   class ActiveSupport::TestCase
    #     parallelize_setup do
    #       # create databases
    #     end
    #   end
    def self.parallelize_setup: () { (untyped) -> untyped } -> untyped

    # Clean up hook for parallel testing. This can be used to drop databases
    # if your app uses multiple write/read databases or other clean up before
    # the tests finish. This runs before the forked process is closed.
    #
    # Note: this feature is not available with the threaded parallelization.
    #
    # In your +test_helper.rb+ add the following:
    #
    #   class ActiveSupport::TestCase
    #     parallelize_teardown do
    #       # drop databases
    #     end
    #   end
    def self.parallelize_teardown: () { (untyped) -> untyped } -> untyped

    alias method_name name

    include ActiveSupport::Testing::TaggedLogging

    include ActiveSupport::Testing::Assertions

    include ActiveSupport::Testing::Deprecation

    include ActiveSupport::Testing::TimeHelpers

    include ActiveSupport::Testing::FileFixtures

    extend ActiveSupport::Testing::Declarative

    # test/unit backwards compatibility methods
    alias assert_raise assert_raises

    alias assert_not_empty refute_empty

    alias assert_not_equal refute_equal

    alias assert_not_in_delta refute_in_delta

    alias assert_not_in_epsilon refute_in_epsilon

    alias assert_not_includes refute_includes

    alias assert_not_instance_of refute_instance_of

    alias assert_not_kind_of refute_kind_of

    alias assert_no_match refute_match

    alias assert_not_nil refute_nil

    alias assert_not_operator refute_operator

    alias assert_not_predicate refute_predicate

    alias assert_not_respond_to refute_respond_to

    alias assert_not_same refute_same
  end
end

module ActiveSupport
  module Testing
    module Assertions
      UNTRACKED: untyped

      # Asserts that an expression is not truthy. Passes if <tt>object</tt> is
      # +nil+ or +false+. "Truthy" means "considered true in a conditional"
      # like <tt>if foo</tt>.
      #
      #   assert_not nil    # => true
      #   assert_not false  # => true
      #   assert_not 'foo'  # => Expected "foo" to be nil or false
      #
      # An error message can be specified.
      #
      #   assert_not foo, 'foo should be false'
      def assert_not: (untyped object, ?untyped? message) -> untyped

      # Assertion that the block should not raise an exception.
      #
      # Passes if evaluated code in the yielded block raises no exception.
      #
      #   assert_nothing_raised do
      #     perform_service(param: 'no_exception')
      #   end
      def assert_nothing_raised: () { () -> untyped } -> untyped

      # Test numeric difference between the return value of an expression as a
      # result of what is evaluated in the yielded block.
      #
      #   assert_difference 'Article.count' do
      #     post :create, params: { article: {...} }
      #   end
      #
      # An arbitrary expression is passed in and evaluated.
      #
      #   assert_difference 'Article.last.comments(:reload).size' do
      #     post :create, params: { comment: {...} }
      #   end
      #
      # An arbitrary positive or negative difference can be specified.
      # The default is <tt>1</tt>.
      #
      #   assert_difference 'Article.count', -1 do
      #     post :delete, params: { id: ... }
      #   end
      #
      # An array of expressions can also be passed in and evaluated.
      #
      #   assert_difference [ 'Article.count', 'Post.count' ], 2 do
      #     post :create, params: { article: {...} }
      #   end
      #
      # A hash of expressions/numeric differences can also be passed in and evaluated.
      #
      #   assert_difference ->{ Article.count } => 1, ->{ Notification.count } => 2 do
      #     post :create, params: { article: {...} }
      #   end
      #
      # A lambda or a list of lambdas can be passed in and evaluated:
      #
      #   assert_difference ->{ Article.count }, 2 do
      #     post :create, params: { article: {...} }
      #   end
      #
      #   assert_difference [->{ Article.count }, ->{ Post.count }], 2 do
      #     post :create, params: { article: {...} }
      #   end
      #
      # An error message can be specified.
      #
      #   assert_difference 'Article.count', -1, 'An Article should be destroyed' do
      #     post :delete, params: { id: ... }
      #   end
      def assert_difference: (untyped expression, *untyped args) { () -> untyped } -> untyped

      # Assertion that the numeric result of evaluating an expression is not
      # changed before and after invoking the passed in block.
      #
      #   assert_no_difference 'Article.count' do
      #     post :create, params: { article: invalid_attributes }
      #   end
      #
      # A lambda can be passed in and evaluated.
      #
      #   assert_no_difference -> { Article.count } do
      #     post :create, params: { article: invalid_attributes }
      #   end
      #
      # An error message can be specified.
      #
      #   assert_no_difference 'Article.count', 'An Article should not be created' do
      #     post :create, params: { article: invalid_attributes }
      #   end
      #
      # An array of expressions can also be passed in and evaluated.
      #
      #   assert_no_difference [ 'Article.count', -> { Post.count } ] do
      #     post :create, params: { article: invalid_attributes }
      #   end
      def assert_no_difference: (untyped expression, ?untyped? message) { () -> untyped } -> untyped

      # Assertion that the result of evaluating an expression is changed before
      # and after invoking the passed in block.
      #
      #   assert_changes 'Status.all_good?' do
      #     post :create, params: { status: { ok: false } }
      #   end
      #
      # You can pass the block as a string to be evaluated in the context of
      # the block. A lambda can be passed for the block as well.
      #
      #   assert_changes -> { Status.all_good? } do
      #     post :create, params: { status: { ok: false } }
      #   end
      #
      # The assertion is useful to test side effects. The passed block can be
      # anything that can be converted to string with #to_s.
      #
      #   assert_changes :@object do
      #     @object = 42
      #   end
      #
      # The keyword arguments :from and :to can be given to specify the
      # expected initial value and the expected value after the block was
      # executed.
      #
      #   assert_changes :@object, from: nil, to: :foo do
      #     @object = :foo
      #   end
      #
      # An error message can be specified.
      #
      #   assert_changes -> { Status.all_good? }, 'Expected the status to be bad' do
      #     post :create, params: { status: { incident: true } }
      #   end
      def assert_changes: (untyped expression, ?untyped? message, ?to: untyped to, ?from: untyped from) { () -> untyped } -> untyped

      # Assertion that the result of evaluating an expression is not changed before
      # and after invoking the passed in block.
      #
      #   assert_no_changes 'Status.all_good?' do
      #     post :create, params: { status: { ok: true } }
      #   end
      #
      # An error message can be specified.
      #
      #   assert_no_changes -> { Status.all_good? }, 'Expected the status to be good' do
      #     post :create, params: { status: { ok: false } }
      #   end
      def assert_no_changes: (untyped expression, ?untyped? message) { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    # Resolves a constant from a minitest spec name.
    #
    # Given the following spec-style test:
    #
    #   describe WidgetsController, :index do
    #     describe "authenticated user" do
    #       describe "returns widgets" do
    #         it "has a controller that exists" do
    #           assert_kind_of WidgetsController, @controller
    #         end
    #       end
    #     end
    #   end
    #
    # The test will have the following name:
    #
    #   "WidgetsController::index::authenticated user::returns widgets"
    #
    # The constant WidgetsController can be resolved from the name.
    # The following code will resolve the constant:
    #
    #   controller = determine_constant_from_test_name(name) do |constant|
    #     Class === constant && constant < ::ActionController::Metal
    #   end
    module ConstantLookup
      extend ::ActiveSupport::Concern

      module ClassMethods
        # :nodoc:
        def determine_constant_from_test_name: (untyped test_name) { (untyped) -> untyped } -> untyped
      end
    end
  end
end

module ActiveSupport
  module Testing
    module Declarative
      # Helper to define a test method using a String. Under the hood, it replaces
      # spaces with underscores and defines the test method.
      #
      #   test "verify something" do
      #     ...
      #   end
      def test: (untyped name) { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    module Deprecation
      # nodoc:
      def assert_deprecated: (?untyped? match, ?untyped? deprecator) { () -> untyped } -> untyped

      def assert_not_deprecated: (?untyped? deprecator) { () -> untyped } -> untyped

      def collect_deprecations: (?untyped? deprecator) { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    # Adds simple access to sample files called file fixtures.
    # File fixtures are normal files stored in
    # <tt>ActiveSupport::TestCase.file_fixture_path</tt>.
    #
    # File fixtures are represented as +Pathname+ objects.
    # This makes it easy to extract specific information:
    #
    #   file_fixture("example.txt").read # get the file's content
    #   file_fixture("example.mp3").size # get the file size
    module FileFixtures
      extend ActiveSupport::Concern

      # Returns a +Pathname+ to the fixture file named +fixture_name+.
      #
      # Raises +ArgumentError+ if +fixture_name+ can't be found.
      def file_fixture: (untyped fixture_name) -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    module Isolation
      def self.included: (untyped klass) -> untyped

      def self.forking_env?: () -> untyped

      def run: () -> untyped

      module Forking
        def run_in_isolation: () { () -> untyped } -> untyped
      end

      module Subprocess
        ORIG_ARGV: untyped

        # Crazy H4X to get this working in windows / jruby with
        # no forking.
        def run_in_isolation: () { () -> untyped } -> untyped
      end
    end
  end
end

module ActiveSupport
  module Testing
    module MethodCallAssertions
      private

      def assert_called: (untyped object, untyped method_name, ?untyped? message, ?returns: untyped? returns, ?times: ::Integer times) { () -> untyped } -> untyped

      def assert_called_with: (untyped object, untyped method_name, untyped args, ?returns: untyped? returns) { () -> untyped } -> untyped

      def assert_not_called: (untyped object, untyped method_name, ?untyped? message) { () -> untyped } -> untyped

      def assert_called_on_instance_of: (untyped klass, untyped method_name, ?untyped? message, ?returns: untyped? returns, ?times: ::Integer times) { () -> untyped } -> untyped

      def assert_not_called_on_instance_of: (untyped klass, untyped method_name, ?untyped? message) { () -> untyped } -> untyped

      def stub_any_instance: (untyped klass, ?instance: untyped `instance`) { (untyped) -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    class Parallelization
      # :nodoc:
      class Server
        include DRb::DRbUndumped

        def initialize: () -> untyped

        def record: (untyped reporter, untyped result) -> untyped

        def <<: (untyped o) -> untyped

        def length: () -> untyped

        def pop: () -> untyped
      end

      def self.after_fork_hook: () { () -> untyped } -> untyped

      def self.run_cleanup_hook: () { () -> untyped } -> untyped

      def initialize: (untyped queue_size) -> untyped

      def after_fork: (untyped worker) -> untyped

      def run_cleanup: (untyped worker) -> untyped

      def start: () -> untyped

      def <<: (untyped work) -> untyped

      def shutdown: () -> untyped

      private

      def add_setup_exception: (untyped result, untyped setup_exception) -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    # Adds support for +setup+ and +teardown+ callbacks.
    # These callbacks serve as a replacement to overwriting the
    # <tt>#setup</tt> and <tt>#teardown</tt> methods of your TestCase.
    #
    #   class ExampleTest < ActiveSupport::TestCase
    #     setup do
    #       # ...
    #     end
    #
    #     teardown do
    #       # ...
    #     end
    #   end
    module SetupAndTeardown
      def self.prepended: (untyped klass) -> untyped

      module ClassMethods
        # Add a callback, which runs before <tt>TestCase#setup</tt>.
        def setup: (*untyped args) { () -> untyped } -> untyped

        # Add a callback, which runs after <tt>TestCase#teardown</tt>.
        def teardown: (*untyped args) { () -> untyped } -> untyped
      end

      def before_setup: () -> untyped

      def after_teardown: () -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    module Stream
      private

      def silence_stream: (untyped stream) { () -> untyped } -> untyped

      def quietly: () { () -> untyped } -> untyped

      def capture: (untyped stream) { () -> untyped } -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    module TaggedLogging
      # Logs a "PostsControllerTest: test name" heading before each test to
      # make test.log easier to search and follow along with.
      # nodoc:
      attr_writer tagged_logger: untyped

      def before_setup: () -> untyped

      private

      def tagged_logger: () -> untyped
    end
  end
end

module ActiveSupport
  module Testing
    class SimpleStubs
      # :nodoc:
      class Stub[T] < ::Struct[T]
        attr_accessor object(): untyped

        attr_accessor method_name(): untyped

        attr_accessor original_method(): untyped
      end

      def initialize: () -> untyped

      def stub_object: (untyped object, untyped method_name) { () -> untyped } -> untyped

      def unstub_all!: () -> untyped

      def stubbing: (untyped object, untyped method_name) -> untyped

      private

      def unstub_object: (untyped stub) -> untyped
    end

    # Contains helpers that help you test passage of time.
    module TimeHelpers
      def after_teardown: () -> untyped

      # Changes current time to the time in the future or in the past by a given time difference by
      # stubbing +Time.now+, +Date.today+, and +DateTime.now+. The stubs are automatically removed
      # at the end of the test.
      #
      #   Time.current     # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel 1.day
      #   Time.current     # => Sun, 10 Nov 2013 15:34:49 EST -05:00
      #   Date.current     # => Sun, 10 Nov 2013
      #   DateTime.current # => Sun, 10 Nov 2013 15:34:49 -0500
      #
      # This method also accepts a block, which will return the current time back to its original
      # state at the end of the block:
      #
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel 1.day do
      #     User.create.created_at # => Sun, 10 Nov 2013 15:34:49 EST -05:00
      #   end
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      def travel: (untyped duration) { () -> untyped } -> untyped

      # Changes current time to the given time by stubbing +Time.now+,
      # +Date.today+, and +DateTime.now+ to return the time or date passed into this method.
      # The stubs are automatically removed at the end of the test.
      #
      #   Time.current     # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel_to Time.zone.local(2004, 11, 24, 01, 04, 44)
      #   Time.current     # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      #   Date.current     # => Wed, 24 Nov 2004
      #   DateTime.current # => Wed, 24 Nov 2004 01:04:44 -0500
      #
      # Dates are taken as their timestamp at the beginning of the day in the
      # application time zone. <tt>Time.current</tt> returns said timestamp,
      # and <tt>Time.now</tt> its equivalent in the system time zone. Similarly,
      # <tt>Date.current</tt> returns a date equal to the argument, and
      # <tt>Date.today</tt> the date according to <tt>Time.now</tt>, which may
      # be different. (Note that you rarely want to deal with <tt>Time.now</tt>,
      # or <tt>Date.today</tt>, in order to honor the application time zone
      # please always use <tt>Time.current</tt> and <tt>Date.current</tt>.)
      #
      # Note that the usec for the time passed will be set to 0 to prevent rounding
      # errors with external services, like MySQL (which will round instead of floor,
      # leading to off-by-one-second errors).
      #
      # This method also accepts a block, which will return the current time back to its original
      # state at the end of the block:
      #
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel_to Time.zone.local(2004, 11, 24, 01, 04, 44) do
      #     Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      #   end
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      def travel_to: (untyped date_or_time) { () -> untyped } -> untyped

      # Returns the current time back to its original state, by removing the stubs added by
      # +travel+, +travel_to+, and +freeze_time+.
      #
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      #   travel_to Time.zone.local(2004, 11, 24, 01, 04, 44)
      #   Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00
      #   travel_back
      #   Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00
      def travel_back: () -> untyped

      alias unfreeze_time travel_back

      # Calls +travel_to+ with +Time.now+.
      #
      #   Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00
      #   freeze_time
      #   sleep(1)
      #   Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00
      #
      # This method also accepts a block, which will return the current time back to its original
      # state at the end of the block:
      #
      #   Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00
      #   freeze_time do
      #     sleep(1)
      #     User.create.created_at # => Sun, 09 Jul 2017 15:34:49 EST -05:00
      #   end
      #   Time.current # => Sun, 09 Jul 2017 15:34:50 EST -05:00
      def freeze_time: () { () -> untyped } -> untyped

      private

      def simple_stubs: () -> untyped
    end
  end
end

module ActiveSupport
end

module ActiveSupport
  # A Time-like class that can represent a time in any time zone. Necessary
  # because standard Ruby Time instances are limited to UTC and the
  # system's <tt>ENV['TZ']</tt> zone.
  #
  # You shouldn't ever need to create a TimeWithZone instance directly via +new+.
  # Instead use methods +local+, +parse+, +at+ and +now+ on TimeZone instances,
  # and +in_time_zone+ on Time and DateTime instances.
  #
  #   Time.zone = 'Eastern Time (US & Canada)'        # => 'Eastern Time (US & Canada)'
  #   Time.zone.local(2007, 2, 10, 15, 30, 45)        # => Sat, 10 Feb 2007 15:30:45 EST -05:00
  #   Time.zone.parse('2007-02-10 15:30:45')          # => Sat, 10 Feb 2007 15:30:45 EST -05:00
  #   Time.zone.at(1171139445)                        # => Sat, 10 Feb 2007 15:30:45 EST -05:00
  #   Time.zone.now                                   # => Sun, 18 May 2008 13:07:55 EDT -04:00
  #   Time.utc(2007, 2, 10, 20, 30, 45).in_time_zone  # => Sat, 10 Feb 2007 15:30:45 EST -05:00
  #
  # See Time and TimeZone for further documentation of these methods.
  #
  # TimeWithZone instances implement the same API as Ruby Time instances, so
  # that Time and TimeWithZone instances are interchangeable.
  #
  #   t = Time.zone.now                     # => Sun, 18 May 2008 13:27:25 EDT -04:00
  #   t.hour                                # => 13
  #   t.dst?                                # => true
  #   t.utc_offset                          # => -14400
  #   t.zone                                # => "EDT"
  #   t.to_s(:rfc822)                       # => "Sun, 18 May 2008 13:27:25 -0400"
  #   t + 1.day                             # => Mon, 19 May 2008 13:27:25 EDT -04:00
  #   t.beginning_of_year                   # => Tue, 01 Jan 2008 00:00:00 EST -05:00
  #   t > Time.utc(1999)                    # => true
  #   t.is_a?(Time)                         # => true
  #   t.is_a?(ActiveSupport::TimeWithZone)  # => true
  class TimeWithZone
    # Report class name as 'Time' to thwart type checking.
    def self.name: () -> "Time"

    PRECISIONS: untyped

    include Comparable

    include DateAndTime::Compatibility

    attr_reader time_zone: untyped

    def initialize: (untyped utc_time, untyped time_zone, ?untyped? local_time, ?untyped? period) -> untyped

    # Returns a <tt>Time</tt> instance that represents the time in +time_zone+.
    def time: () -> untyped

    # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
    def utc: () -> untyped

    alias comparable_time utc

    alias getgm utc

    alias getutc utc

    alias gmtime utc

    # Returns the underlying TZInfo::TimezonePeriod.
    def period: () -> untyped

    # Returns the simultaneous time in <tt>Time.zone</tt>, or the specified zone.
    def in_time_zone: (?(ActiveSupport::TimeZone | String) new_zone) -> ::ActiveSupport::TimeWithZone
                    | (false? zone) -> ::Time

    # Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.
    def localtime: (?untyped? utc_offset) -> untyped

    alias getlocal localtime

    # Returns true if the current time is within Daylight Savings Time for the
    # specified time zone.
    #
    #   Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)'
    #   Time.zone.parse("2012-5-30").dst?           # => true
    #   Time.zone.parse("2012-11-30").dst?          # => false
    def dst?: () -> untyped

    alias isdst dst?

    # Returns true if the current time zone is set to UTC.
    #
    #   Time.zone = 'UTC'                           # => 'UTC'
    #   Time.zone.now.utc?                          # => true
    #   Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)'
    #   Time.zone.now.utc?                          # => false
    def utc?: () -> untyped

    alias gmt? utc?

    # Returns the offset from current time to UTC time in seconds.
    def utc_offset: () -> untyped

    alias gmt_offset utc_offset

    alias gmtoff utc_offset

    # Returns a formatted string of the offset from UTC, or an alternative
    # string if the time zone is already UTC.
    #
    #   Time.zone = 'Eastern Time (US & Canada)'   # => "Eastern Time (US & Canada)"
    #   Time.zone.now.formatted_offset(true)       # => "-05:00"
    #   Time.zone.now.formatted_offset(false)      # => "-0500"
    #   Time.zone = 'UTC'                          # => "UTC"
    #   Time.zone.now.formatted_offset(true, "0")  # => "0"
    def formatted_offset: (?bool colon, ?untyped? alternate_utc_string) -> untyped

    # Returns the time zone abbreviation.
    #
    #   Time.zone = 'Eastern Time (US & Canada)'   # => "Eastern Time (US & Canada)"
    #   Time.zone.now.zone # => "EST"
    def zone: () -> untyped

    # Returns a string of the object's date, time, zone, and offset from UTC.
    #
    #   Time.zone.now.inspect # => "Thu, 04 Dec 2014 11:00:25 EST -05:00"
    def inspect: () -> ::String

    # Returns a string of the object's date and time in the ISO 8601 standard
    # format.
    #
    #   Time.zone.now.xmlschema  # => "2014-12-04T11:02:37-05:00"
    def xmlschema: (?::Integer fraction_digits) -> ::String

    alias iso8601 xmlschema

    alias rfc3339 xmlschema

    # Coerces time to a string for JSON encoding. The default format is ISO 8601.
    # You can get %Y/%m/%d %H:%M:%S +offset style by setting
    # <tt>ActiveSupport::JSON::Encoding.use_standard_json_time_format</tt>
    # to +false+.
    #
    #   # With ActiveSupport::JSON::Encoding.use_standard_json_time_format = true
    #   Time.utc(2005,2,1,15,15,10).in_time_zone("Hawaii").to_json
    #   # => "2005-02-01T05:15:10.000-10:00"
    #
    #   # With ActiveSupport::JSON::Encoding.use_standard_json_time_format = false
    #   Time.utc(2005,2,1,15,15,10).in_time_zone("Hawaii").to_json
    #   # => "2005/02/01 05:15:10 -1000"
    def as_json: (?untyped? options) -> untyped

    def init_with: (untyped coder) -> untyped

    def encode_with: (untyped coder) -> untyped

    # Returns a string of the object's date and time in the format used by
    # HTTP requests.
    #
    #   Time.zone.now.httpdate  # => "Tue, 01 Jan 2013 04:39:43 GMT"
    def httpdate: () -> untyped

    # Returns a string of the object's date and time in the RFC 2822 standard
    # format.
    #
    #   Time.zone.now.rfc2822  # => "Tue, 01 Jan 2013 04:51:39 +0000"
    def rfc2822: () -> untyped

    alias rfc822 rfc2822

    # Returns a string of the object's date and time.
    # Accepts an optional <tt>format</tt>:
    # * <tt>:default</tt> - default value, mimics Ruby Time#to_s format.
    # * <tt>:db</tt> - format outputs time in UTC :db time. See Time#to_formatted_s(:db).
    # * Any key in <tt>Time::DATE_FORMATS</tt> can be used. See active_support/core_ext/time/conversions.rb.
    def to_s: (?::Symbol format) -> untyped

    alias to_formatted_s to_s

    # Replaces <tt>%Z</tt> directive with +zone before passing to Time#strftime,
    # so that zone information is correct.
    def strftime: (untyped format) -> untyped

    # Use the time in UTC for comparisons.
    def <=>: (untyped other) -> untyped

    alias before? <

    alias after? >

    # Returns true if the current object's time is within the specified
    # +min+ and +max+ time.
    def between?: (untyped min, untyped max) -> untyped

    # Returns true if the current object's time is in the past.
    def past?: () -> untyped

    # Returns true if the current object's time falls within
    # the current day.
    def today?: () -> untyped

    # Returns true if the current object's time is in the future.
    def future?: () -> untyped

    # Returns +true+ if +other+ is equal to current object.
    def eql?: (untyped other) -> untyped

    def hash: () -> untyped

    # Adds an interval of time to the current object's time and returns that
    # value as a new TimeWithZone object.
    #
    #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
    #   now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28 EDT -04:00
    #   now + 1000          # => Sun, 02 Nov 2014 01:43:08 EDT -04:00
    #
    # If we're adding a Duration of variable length (i.e., years, months, days),
    # move forward from #time, otherwise move forward from #utc, for accuracy
    # when moving across DST boundaries.
    #
    # For instance, a time + 24.hours will advance exactly 24 hours, while a
    # time + 1.day will advance 23-25 hours, depending on the day.
    #
    #   now + 24.hours      # => Mon, 03 Nov 2014 00:26:28 EST -05:00
    #   now + 1.day         # => Mon, 03 Nov 2014 01:26:28 EST -05:00
    def +: ((Time | TimeWithZone | Numeric | Duration) other) -> TimeWithZone

    alias since +

    alias in +

    # Subtracts an interval of time and returns a new TimeWithZone object unless
    # the other value `acts_like?` time. Then it will return a Float of the difference
    # between the two times that represents the difference between the current
    # object's time and the +other+ time.
    #
    #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
    #   now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28 EST -05:00
    #   now - 1000          # => Mon, 03 Nov 2014 00:09:48 EST -05:00
    #
    # If subtracting a Duration of variable length (i.e., years, months, days),
    # move backward from #time, otherwise move backward from #utc, for accuracy
    # when moving across DST boundaries.
    #
    # For instance, a time - 24.hours will go subtract exactly 24 hours, while a
    # time - 1.day will subtract 23-25 hours, depending on the day.
    #
    #   now - 24.hours      # => Sun, 02 Nov 2014 01:26:28 EDT -04:00
    #   now - 1.day         # => Sun, 02 Nov 2014 00:26:28 EDT -04:00
    #
    # If both the TimeWithZone object and the other value act like Time, a Float
    # will be returned.
    #
    #   Time.zone.now - 1.day.ago # => 86399.999967
    #
    def -: ((TimeWithZone | Time) other) -> Float
         | ((Numeric | Duration) other) -> TimeWithZone

    # Subtracts an interval of time from the current object's time and returns
    # the result as a new TimeWithZone object.
    #
    #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
    #   now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28 EST -05:00
    #   now.ago(1000)       # => Mon, 03 Nov 2014 00:09:48 EST -05:00
    #
    # If we're subtracting a Duration of variable length (i.e., years, months,
    # days), move backward from #time, otherwise move backward from #utc, for
    # accuracy when moving across DST boundaries.
    #
    # For instance, <tt>time.ago(24.hours)</tt> will move back exactly 24 hours,
    # while <tt>time.ago(1.day)</tt> will move back 23-25 hours, depending on
    # the day.
    #
    #   now.ago(24.hours)   # => Sun, 02 Nov 2014 01:26:28 EDT -04:00
    #   now.ago(1.day)      # => Sun, 02 Nov 2014 00:26:28 EDT -04:00
    def ago: (untyped other) -> TimeWithZone

    # Returns a new +ActiveSupport::TimeWithZone+ where one or more of the elements have
    # been changed according to the +options+ parameter. The time options (<tt>:hour</tt>,
    # <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>) reset cascadingly,
    # so if only the hour is passed, then minute, sec, usec and nsec is set to 0. If the
    # hour and minute is passed, then sec, usec and nsec is set to 0. The +options+
    # parameter takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>,
    # <tt>:day</tt>, <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>,
    # <tt>:nsec</tt>, <tt>:offset</tt>, <tt>:zone</tt>. Pass either <tt>:usec</tt>
    # or <tt>:nsec</tt>, not both. Similarly, pass either <tt>:zone</tt> or
    # <tt>:offset</tt>, not both.
    #
    #   t = Time.zone.now          # => Fri, 14 Apr 2017 11:45:15 EST -05:00
    #   t.change(year: 2020)       # => Tue, 14 Apr 2020 11:45:15 EST -05:00
    #   t.change(hour: 12)         # => Fri, 14 Apr 2017 12:00:00 EST -05:00
    #   t.change(min: 30)          # => Fri, 14 Apr 2017 11:30:00 EST -05:00
    #   t.change(offset: "-10:00") # => Fri, 14 Apr 2017 11:45:15 HST -10:00
    #   t.change(zone: "Hawaii")   # => Fri, 14 Apr 2017 11:45:15 HST -10:00
    def change: (untyped options) -> TimeWithZone

    # Uses Date to provide precise Time calculations for years, months, and days
    # according to the proleptic Gregorian calendar. The result is returned as a
    # new TimeWithZone object.
    #
    # The +options+ parameter takes a hash with any of these keys:
    # <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>,
    # <tt>:hours</tt>, <tt>:minutes</tt>, <tt>:seconds</tt>.
    #
    # If advancing by a value of variable length (i.e., years, weeks, months,
    # days), move forward from #time, otherwise move forward from #utc, for
    # accuracy when moving across DST boundaries.
    #
    #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
    #   now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28 EDT -04:00
    #   now.advance(seconds: 1) # => Sun, 02 Nov 2014 01:26:29 EDT -04:00
    #   now.advance(minutes: 1) # => Sun, 02 Nov 2014 01:27:28 EDT -04:00
    #   now.advance(hours: 1)   # => Sun, 02 Nov 2014 01:26:28 EST -05:00
    #   now.advance(days: 1)    # => Mon, 03 Nov 2014 01:26:28 EST -05:00
    #   now.advance(weeks: 1)   # => Sun, 09 Nov 2014 01:26:28 EST -05:00
    #   now.advance(months: 1)  # => Tue, 02 Dec 2014 01:26:28 EST -05:00
    #   now.advance(years: 1)   # => Mon, 02 Nov 2015 01:26:28 EST -05:00
    def advance: (untyped options) -> TimeWithZone

    # Returns Array of parts of Time in sequence of
    # [seconds, minutes, hours, day, month, year, weekday, yearday, dst?, zone].
    #
    #   now = Time.zone.now     # => Tue, 18 Aug 2015 02:29:27 UTC +00:00
    #   now.to_a                # => [27, 29, 2, 18, 8, 2015, 2, 230, false, "UTC"]
    def to_a: () -> ::Array[untyped]

    # Returns the object's date and time as a floating point number of seconds
    # since the Epoch (January 1, 1970 00:00 UTC).
    #
    #   Time.zone.now.to_f # => 1417709320.285418
    def to_f: () -> untyped

    # Returns the object's date and time as an integer number of seconds
    # since the Epoch (January 1, 1970 00:00 UTC).
    #
    #   Time.zone.now.to_i # => 1417709320
    def to_i: () -> untyped

    alias tv_sec to_i

    # Returns the object's date and time as a rational number of seconds
    # since the Epoch (January 1, 1970 00:00 UTC).
    #
    #   Time.zone.now.to_r # => (708854548642709/500000)
    def to_r: () -> untyped

    # Returns an instance of DateTime with the timezone's UTC offset
    #
    #   Time.zone.now.to_datetime                         # => Tue, 18 Aug 2015 02:32:20 +0000
    #   Time.current.in_time_zone('Hawaii').to_datetime   # => Mon, 17 Aug 2015 16:32:20 -1000
    def to_datetime: () -> untyped

    # Returns an instance of +Time+, either with the same UTC offset
    # as +self+ or in the local system timezone depending on the setting
    # of +ActiveSupport.to_time_preserves_timezone+.
    def to_time: () -> untyped

    # So that +self+ <tt>acts_like?(:time)</tt>.
    def acts_like_time?: () -> ::TrueClass

    # Say we're a Time to thwart type checking.
    def is_a?: (untyped klass) -> untyped

    alias kind_of? is_a?

    # An instance of ActiveSupport::TimeWithZone is never blank
    def blank?: () -> ::FalseClass

    def freeze: () -> untyped

    def marshal_dump: () -> ::Array[untyped]

    def marshal_load: (untyped variables) -> untyped

    # respond_to_missing? is not called in some cases, such as when type conversion is
    # performed with Kernel#String
    def respond_to?: (untyped sym, ?bool include_priv) -> (::FalseClass | untyped)

    # Ensure proxy class responds to all methods that underlying time instance
    # responds to.
    def respond_to_missing?: (untyped sym, untyped include_priv) -> (::FalseClass | untyped)

    # Send the missing method to +time+ instance, and wrap result in a new
    # TimeWithZone with the existing +time_zone+.
    def method_missing: (untyped sym, *untyped args) { () -> untyped } -> untyped

    private

    def get_period_and_ensure_valid_local_time: (untyped period) -> untyped

    def transfer_time_values_to_utc_constructor: (untyped time) -> untyped

    def duration_of_variable_length?: (untyped obj) -> untyped

    def wrap_with_time_zone: (untyped time) -> untyped
  end
end

module ActiveSupport
  # The TimeZone class serves as a wrapper around TZInfo::Timezone instances.
  # It allows us to do the following:
  #
  # * Limit the set of zones provided by TZInfo to a meaningful subset of 134
  #   zones.
  # * Retrieve and display zones with a friendlier name
  #   (e.g., "Eastern Time (US & Canada)" instead of "America/New_York").
  # * Lazily load TZInfo::Timezone instances only when they're needed.
  # * Create ActiveSupport::TimeWithZone instances via TimeZone's +local+,
  #   +parse+, +at+ and +now+ methods.
  #
  # If you set <tt>config.time_zone</tt> in the Rails Application, you can
  # access this TimeZone object via <tt>Time.zone</tt>:
  #
  #   # application.rb:
  #   class Application < Rails::Application
  #     config.time_zone = 'Eastern Time (US & Canada)'
  #   end
  #
  #   Time.zone      # => #<ActiveSupport::TimeZone:0x514834...>
  #   Time.zone.name # => "Eastern Time (US & Canada)"
  #   Time.zone.now  # => Sun, 18 May 2008 14:30:44 EDT -04:00
  class TimeZone
    # Keys are Rails TimeZone names, values are TZInfo identifiers.
    MAPPING: ::Hash[untyped, untyped]

    UTC_OFFSET_WITH_COLON: ::String

    UTC_OFFSET_WITHOUT_COLON: untyped

    # Assumes self represents an offset from UTC in seconds (as returned from
    # Time#utc_offset) and turns this into an +HH:MM formatted string.
    #
    #   ActiveSupport::TimeZone.seconds_to_utc_offset(-21_600) # => "-06:00"
    def self.seconds_to_utc_offset: (untyped seconds, ?bool colon) -> untyped

    def self.find_tzinfo: (untyped name) -> TZInfo::Timezone

    alias self.create self.new

    # Returns a TimeZone instance with the given name, or +nil+ if no
    # such TimeZone instance exists. (This exists to support the use of
    # this class with the +composed_of+ macro.)
    def self.new: (untyped name) -> untyped

    # Returns an array of all TimeZone objects. There are multiple
    # TimeZone objects per time zone, in many cases, to make it easier
    # for users to find their own time zone.
    def self.all: () -> untyped

    # Locate a specific time zone object. If the argument is a string, it
    # is interpreted to mean the name of the timezone to locate. If it is a
    # numeric value it is either the hour offset, or the second offset, of the
    # timezone to find. (The first one with that offset will be returned.)
    # Returns +nil+ if no such time zone is known to the system.
    def self.[]: (untyped arg) -> untyped

    # A convenience method for returning a collection of TimeZone objects
    # for time zones in the USA.
    def self.us_zones: () -> untyped

    # A convenience method for returning a collection of TimeZone objects
    # for time zones in the country specified by its ISO 3166-1 Alpha2 code.
    def self.country_zones: (untyped country_code) -> untyped

    def self.clear: () -> untyped

    private

    def self.load_country_zones: (untyped code) -> untyped

    def self.zones_map: () -> untyped

    public

    include Comparable

    attr_reader name: untyped

    attr_reader tzinfo: untyped

    # Create a new TimeZone object with the given name and offset. The
    # offset is the number of seconds that this time zone is offset from UTC
    # (GMT). Seconds were chosen as the offset unit because that is the unit
    # that Ruby uses to represent time zone offsets (see Time#utc_offset).
    def initialize: (untyped name, ?untyped? utc_offset, ?untyped? tzinfo) -> untyped

    # Returns the offset of this time zone from UTC in seconds.
    def utc_offset: () -> untyped

    # Returns a formatted string of the offset from UTC, or an alternative
    # string if the time zone is already UTC.
    #
    #   zone = ActiveSupport::TimeZone['Central Time (US & Canada)']
    #   zone.formatted_offset        # => "-06:00"
    #   zone.formatted_offset(false) # => "-0600"
    def formatted_offset: (?bool colon, ?untyped? alternate_utc_string) -> untyped

    # Compare this time zone to the parameter. The two are compared first on
    # their offsets, and then by name.
    def <=>: (untyped zone) -> (nil | untyped)

    # Compare #name and TZInfo identifier to a supplied regexp, returning +true+
    # if a match is found.
    def =~: (untyped re) -> untyped

    # Returns a textual representation of this time zone.
    def to_s: () -> ::String

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from given values.
    #
    #   Time.zone = 'Hawaii'                    # => "Hawaii"
    #   Time.zone.local(2007, 2, 1, 15, 30, 45) # => Thu, 01 Feb 2007 15:30:45 HST -10:00
    def local: (*untyped args) -> ActiveSupport::TimeWithZone

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from number of seconds since the Unix epoch.
    #
    #   Time.zone = 'Hawaii'        # => "Hawaii"
    #   Time.utc(2000).to_f         # => 946684800.0
    #   Time.zone.at(946684800.0)   # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # A second argument can be supplied to specify sub-second precision.
    #
    #   Time.zone = 'Hawaii'                # => "Hawaii"
    #   Time.at(946684800, 123456.789).nsec # => 123456789
    def at: (*untyped args) -> untyped

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from an ISO 8601 string.
    #
    #   Time.zone = 'Hawaii'                     # => "Hawaii"
    #   Time.zone.iso8601('1999-12-31T14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # If the time components are missing then they will be set to zero.
    #
    #   Time.zone = 'Hawaii'            # => "Hawaii"
    #   Time.zone.iso8601('1999-12-31') # => Fri, 31 Dec 1999 00:00:00 HST -10:00
    #
    # If the string is invalid then an +ArgumentError+ will be raised unlike +parse+
    # which usually returns +nil+ when given an invalid date string.
    def iso8601: (untyped str) -> untyped

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from parsed string.
    #
    #   Time.zone = 'Hawaii'                   # => "Hawaii"
    #   Time.zone.parse('1999-12-31 14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # If upper components are missing from the string, they are supplied from
    # TimeZone#now:
    #
    #   Time.zone.now               # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #   Time.zone.parse('22:30:00') # => Fri, 31 Dec 1999 22:30:00 HST -10:00
    #
    # However, if the date component is not provided, but any other upper
    # components are supplied, then the day of the month defaults to 1:
    #
    #   Time.zone.parse('Mar 2000') # => Wed, 01 Mar 2000 00:00:00 HST -10:00
    #
    # If the string is invalid then an +ArgumentError+ could be raised.
    def parse: (untyped str, ?untyped now) -> untyped

    # Method for creating new ActiveSupport::TimeWithZone instance in time zone
    # of +self+ from an RFC 3339 string.
    #
    #   Time.zone = 'Hawaii'                     # => "Hawaii"
    #   Time.zone.rfc3339('2000-01-01T00:00:00Z') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # If the time or zone components are missing then an +ArgumentError+ will
    # be raised. This is much stricter than either +parse+ or +iso8601+ which
    # allow for missing components.
    #
    #   Time.zone = 'Hawaii'            # => "Hawaii"
    #   Time.zone.rfc3339('1999-12-31') # => ArgumentError: invalid date
    def rfc3339: (untyped str) -> TimeWithZone

    # Parses +str+ according to +format+ and returns an ActiveSupport::TimeWithZone.
    #
    # Assumes that +str+ is a time in the time zone +self+,
    # unless +format+ includes an explicit time zone.
    # (This is the same behavior as +parse+.)
    # In either case, the returned TimeWithZone has the timezone of +self+.
    #
    #   Time.zone = 'Hawaii'                   # => "Hawaii"
    #   Time.zone.strptime('1999-12-31 14:00:00', '%Y-%m-%d %H:%M:%S') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #
    # If upper components are missing from the string, they are supplied from
    # TimeZone#now:
    #
    #   Time.zone.now                              # => Fri, 31 Dec 1999 14:00:00 HST -10:00
    #   Time.zone.strptime('22:30:00', '%H:%M:%S') # => Fri, 31 Dec 1999 22:30:00 HST -10:00
    #
    # However, if the date component is not provided, but any other upper
    # components are supplied, then the day of the month defaults to 1:
    #
    #   Time.zone.strptime('Mar 2000', '%b %Y') # => Wed, 01 Mar 2000 00:00:00 HST -10:00
    def strptime: (untyped str, untyped format, ?untyped now) -> untyped

    # Returns an ActiveSupport::TimeWithZone instance representing the current
    # time in the time zone represented by +self+.
    #
    #   Time.zone = 'Hawaii'  # => "Hawaii"
    #   Time.zone.now         # => Wed, 23 Jan 2008 20:24:27 HST -10:00
    def now: () -> ActiveSupport::TimeWithZone

    # Returns the current date in this time zone.
    def today: () -> untyped

    # Returns the next date in this time zone.
    def tomorrow: () -> untyped

    # Returns the previous date in this time zone.
    def yesterday: () -> untyped

    # Adjust the given time to the simultaneous time in the time zone
    # represented by +self+. Returns a Time.utc() instance -- if you want an
    # ActiveSupport::TimeWithZone instance, use Time#in_time_zone() instead.
    def utc_to_local: (untyped time) -> untyped

    # Adjust the given time to the simultaneous time in UTC. Returns a
    # Time.utc() instance.
    def local_to_utc: (untyped time, ?bool dst) -> untyped

    # Available so that TimeZone instances respond like TZInfo::Timezone
    # instances.
    def period_for_utc: (untyped time) -> untyped

    # Available so that TimeZone instances respond like TZInfo::Timezone
    # instances.
    def period_for_local: (untyped time, ?bool dst) -> untyped

    def periods_for_local: (untyped time) -> untyped

    def init_with: (untyped coder) -> untyped

    def encode_with: (untyped coder) -> untyped

    private

    def parts_to_time: (untyped parts, untyped now) -> (nil | untyped)

    def time_now: () -> untyped
  end
end

module ActiveSupport
  # Returns the version of the currently loaded ActiveSupport as a <tt>Gem::Version</tt>
  def self.version: () -> untyped
end

module ActiveSupport
  module XmlMini_JDOM
    # nodoc:
    extend ::ActiveSupport::XmlMini_JDOM

    CONTENT_KEY: ::String

    NODE_TYPE_NAMES: ::Array[untyped]

    # Parse an XML Document string or IO into a simple hash using Java's jdom.
    # data::
    #   XML Document string or IO to parse
    def parse: (untyped data) -> untyped

    private

    # Convert an XML element and merge into the hash
    #
    # hash::
    #   Hash to merge the converted element into.
    # element::
    #   XML element to merge into hash
    def merge_element!: (untyped hash, untyped element, untyped depth) -> untyped

    def delete_empty: (untyped hash) -> untyped

    # Actually converts an XML document element into a data structure.
    #
    # element::
    #   The document element to be collapsed.
    def collapse: (untyped element, untyped depth) -> untyped

    # Merge all the texts of an element into the hash
    #
    # hash::
    #   Hash to add the converted element to.
    # element::
    #   XML element whose texts are to me merged into the hash
    def merge_texts!: (untyped hash, untyped element) -> untyped

    # Adds a new key/value pair to an existing Hash. If the key to be added
    # already exists and the existing value associated with key is not
    # an Array, it will be wrapped in an Array. Then the new value is
    # appended to that Array.
    #
    # hash::
    #   Hash to add key/value pair to.
    # key::
    #   Key to be added.
    # value::
    #   Value to be associated with key.
    def merge!: (untyped hash, untyped key, untyped value) -> untyped

    # Converts the attributes array of an XML element into a hash.
    # Returns an empty Hash if node has no attributes.
    #
    # element::
    #   XML element to extract attributes from.
    def get_attributes: (untyped element) -> untyped

    # Determines if a document element has text content
    #
    # element::
    #   XML element to be checked.
    def texts: (untyped element) -> untyped

    # Determines if a document element has text content
    #
    # element::
    #   XML element to be checked.
    def empty_content?: (untyped element) -> untyped
  end
end

module ActiveSupport
  module XmlMini_LibXML
    # nodoc:
    extend ::ActiveSupport::XmlMini_LibXML

    # Parse an XML Document string or IO into a simple hash using libxml.
    # data::
    #   XML Document string or IO to parse
    def parse: (untyped data) -> untyped
  end
end

module LibXML
  module Conversions
    module Document
      # nodoc:
      # nodoc:
      # nodoc:
      def to_hash: () -> untyped
    end

    module Node
      # nodoc:
      CONTENT_ROOT: ::String

      # Convert XML document to hash.
      #
      # hash::
      #   Hash to merge the converted element into.
      def to_hash: (?::Hash[untyped, untyped] hash) -> untyped
    end
  end
end

module ActiveSupport
  module XmlMini_LibXMLSAX
    # nodoc:
    extend ::ActiveSupport::XmlMini_LibXMLSAX

    # Class that will build the hash while the XML document
    # is being parsed using SAX events.
    class HashBuilder
      include LibXML::XML::SaxParser::Callbacks

      CONTENT_KEY: ::String

      HASH_SIZE_KEY: ::String

      attr_reader hash: untyped

      def current_hash: () -> untyped

      def on_start_document: () -> untyped

      def on_end_document: () -> untyped

      def on_start_element: (untyped name, ?::Hash[untyped, untyped] attrs) -> untyped

      def on_end_element: (untyped name) -> untyped

      def on_characters: (untyped string) -> untyped

      alias on_cdata_block on_characters
    end

    attr_accessor document_class: untyped

    def parse: (untyped data) -> untyped
  end
end

module ActiveSupport
  module XmlMini_Nokogiri
    # nodoc:
    extend ::ActiveSupport::XmlMini_Nokogiri

    # Parse an XML Document string or IO into a simple hash using libxml / nokogiri.
    # data::
    #   XML Document string or IO to parse
    def parse: (untyped data) -> untyped

    module Conversions
      module Document
        # nodoc:
        # nodoc:
        def to_hash: () -> untyped
      end

      module Node
        # nodoc:
        CONTENT_ROOT: ::String

        # Convert XML document to hash.
        #
        # hash::
        #   Hash to merge the converted element into.
        def to_hash: (?::Hash[untyped, untyped] hash) -> untyped
      end
    end
  end
end

module ActiveSupport
  module XmlMini_NokogiriSAX
    # nodoc:
    extend ::ActiveSupport::XmlMini_NokogiriSAX

    # Class that will build the hash while the XML document
    # is being parsed using SAX events.
    class HashBuilder < Nokogiri::XML::SAX::Document
      CONTENT_KEY: ::String

      HASH_SIZE_KEY: ::String

      attr_reader hash: untyped

      def current_hash: () -> untyped

      def start_document: () -> untyped

      def end_document: () -> untyped

      def error: (untyped error_message) -> untyped

      def start_element: (untyped name, ?untyped attrs) -> untyped

      def end_element: (untyped name) -> untyped

      def characters: (untyped string) -> untyped

      alias cdata_block characters
    end

    attr_accessor document_class: untyped

    def parse: (untyped data) -> untyped
  end
end

module ActiveSupport
  module XmlMini_REXML
    # nodoc:
    extend ::ActiveSupport::XmlMini_REXML

    CONTENT_KEY: ::String

    # Parse an XML Document string or IO into a simple hash.
    #
    # Same as XmlSimple::xml_in but doesn't shoot itself in the foot,
    # and uses the defaults from Active Support.
    #
    # data::
    #   XML Document string or IO to parse
    def parse: (untyped data) -> untyped

    private

    # Convert an XML element and merge into the hash
    #
    # hash::
    #   Hash to merge the converted element into.
    # element::
    #   XML element to merge into hash
    def merge_element!: (untyped hash, untyped element, untyped depth) -> untyped

    # Actually converts an XML document element into a data structure.
    #
    # element::
    #   The document element to be collapsed.
    def collapse: (untyped element, untyped depth) -> untyped

    # Merge all the texts of an element into the hash
    #
    # hash::
    #   Hash to add the converted element to.
    # element::
    #   XML element whose texts are to me merged into the hash
    def merge_texts!: (untyped hash, untyped element) -> untyped

    # Adds a new key/value pair to an existing Hash. If the key to be added
    # already exists and the existing value associated with key is not
    # an Array, it will be wrapped in an Array. Then the new value is
    # appended to that Array.
    #
    # hash::
    #   Hash to add key/value pair to.
    # key::
    #   Key to be added.
    # value::
    #   Value to be associated with key.
    def merge!: (untyped hash, untyped key, untyped value) -> untyped

    # Converts the attributes array of an XML element into a hash.
    # Returns an empty Hash if node has no attributes.
    #
    # element::
    #   XML element to extract attributes from.
    def get_attributes: (untyped element) -> untyped

    # Determines if a document element has text content
    #
    # element::
    #   XML element to be checked.
    def empty_content?: (untyped element) -> untyped
  end
end

module ActiveSupport
  # = XmlMini
  #
  # To use the much faster libxml parser:
  #   gem 'libxml-ruby', '=0.9.7'
  #   XmlMini.backend = 'LibXML'
  module XmlMini
    extend ::ActiveSupport::XmlMini

    module FileLike
      # This module decorates files deserialized using Hash.from_xml with
      # the <tt>original_filename</tt> and <tt>content_type</tt> methods.
      # nodoc:
      attr_writer original_filename: untyped

      # This module decorates files deserialized using Hash.from_xml with
      # the <tt>original_filename</tt> and <tt>content_type</tt> methods.
      # nodoc:
      attr_writer content_type: untyped

      def original_filename: () -> untyped

      def content_type: () -> untyped
    end

    DEFAULT_ENCODINGS: ::Hash[untyped, untyped]

    TYPE_NAMES: ::Hash[untyped, untyped]

    FORMATTING: ::Hash[untyped, untyped]

    PARSING: ::Hash[untyped, untyped]

    attr_accessor depth: untyped

    def backend: () -> untyped

    def backend=: (untyped name) -> untyped

    def with_backend: (untyped name) { () -> untyped } -> untyped

    def to_tag: (untyped key, untyped value, untyped options) -> untyped

    def rename_key: (untyped key, ?::Hash[untyped, untyped] options) -> untyped

    private

    def _dasherize: (untyped key) -> ::String

    # TODO: Add support for other encodings
    def _parse_binary: (untyped bin, untyped entity) -> untyped

    def _parse_file: (untyped file, untyped entity) -> untyped

    def current_thread_backend: () -> untyped

    def current_thread_backend=: (untyped name) -> untyped

    def cast_backend_name_to_module: (untyped name) -> untyped
  end
end

module ActiveSupport
  extend ActiveSupport::Autoload

  def self.eager_load!: () -> untyped

  def self.to_time_preserves_timezone: () -> untyped

  def self.to_time_preserves_timezone=: (untyped value) -> untyped
end

class Object
  # Benchmark realtime in milliseconds.
  #
  #   Benchmark.realtime { User.all }
  #   # => 8.0e-05
  #
  #   Benchmark.ms { User.all }
  #   # => 0.074
  def self.ms: () { () -> untyped } -> untyped

  public

  def unescape: (untyped str, ?untyped escaped) -> untyped
end
